--/makedoc title Documentation for Win32lib v0.60.6

--/topic introduction
--/i "see also:" /"General Info"
--/code
--------------------NOTICE-------------------------------*
-- Software ID: win32lib
-- Version:     0.60.6 19/September/2004
-- Copyright:   (c) 2000 /"David Cuny" and friends
--              All rights reserved.
-- Licence:
-- This software is provided 'as-is', without any express or implied warranty.
-- In no event will the authors be held liable for any damages arising from
-- the use of this software.
--
-- Permission is granted to anyone to use this software for any purpose,
-- including commercial applications, and to alter it and redistribute it
-- freely, subject to the following restrictictions:
-- 1. The origin of this software must not be misrepresented; you must not
--    claim that you wrote the original software.
-- 2. If you use this software in a product, acknowedgement in the product's
--    documenation and binary are required.
-- 3. Altered source versions, and works substantially derived from the it,
--    must...
--   a) be plainly be marked as such,
--   b) not be misrepresented as the original software,
--   c) include this notice, unaltered.
--------------------End of NOTICE------------------------*
--/endcode

--/topic Authors
--/info
--A bit of background on the authors of this library.
--
--/bm "David Cuny" /n
--David originally wrote Win32lib in an attempt to create a platform independant
-- GUI add-on for Euphoria.
--
--/bm "Matthew Lewis" /n
--Matthew implemented most of the common Windows controls
--
--/bm "Derek Parnell" /n
--Derek has acted as custodian once David could no longer concentrate on the library.
-- Since then he has reorganised the code and implemented improvements
-- based on submissions from the many users of the library.
--

--/topic General Info
--/info
-- Some background and historical notes about win32lib.
-- The library was originally developed by /"David Cuny", and over time, a
-- number of other people have made additions and corrections. Where
-- appropriate the work that other people have contributed is marked thus...
--/code
--     -- Begin ~<person's name>~
--     -- End   ~<person's name>~
--/endcode
-- This library provides access to the /i"Window32 API" from a fairly high
-- level, hiding most of the guts from the user.
--
--See also: /lit'<a href="win32geninfo.html">Further Information</a>'

--/topic Frequently Asked Questions
--/info
-- Questions and Answers that are often sought by new comers to Win32lib.
-- This section contains the answers to many questions that beginners have.
--Details in /lit'<a href="w32faq.htm">Win32Lib FAQ</a>'

---/topic Known Bugs
-- Okay, so not everything is perfect. At least we admit it!
-- The following are known bugs. They will probably be fixed before the next major release.
--/define
--/term ??description of a bug??
--/enddefine


--/topic Defaults
--/info
--Setting the default values that Win32lib applications use.
--There are a number of values that Win32lib uses that can be changed
-- on a per application basis. These new values are specified using the
-- operating system's SET environment symbol command.
--
--The symbol to use is 'w32Defaults'. This takes a comma separated list of
--keyword/value pairs. The keyword is delimited from the value by a colon ':'
-- character.
--
--/b FONT /n
--Unless you explicitly specify a font for a control, the get the
-- Win32lib default font.
--The default font used for text is /b"MS Sans Serif 8-point Normal". You can change
-- this with the /i Font keyword. It is followed by a list of one to three
-- values enclosed in brackets.
--
-- Font:{ /b facename, /b size, /b style } /n
--where /i facename is the name of the font, /i size is the point-size required,
-- and /i style is an integer whose value is the sum of ...
--/code
--    Normal    = 0
--    Bold      = 1
--    Italic    = 2
--    Underline = 4
--    Strikeout = 8
--/endcode
--Thus to get /b Bold and /i Italic you add 1 and 2 and make the /i style value
--equal 3.
--
--Example:
--/code
--      set w32Defaults=Font:(Comic Sans MS,12,3)
--/endcode

-----------------------------------------------------------------------------

--/topic Change History
-- This records, in brief, the major changes done to the source code.
-- Where possible, the appropriate people are given credit as well.
-- See details in /lit'<a href="change.htm">Changes</a>'

-----------------------------------------------------------------------------
-- info on topics

-----------------------------------------------------------------------------
--/topic System Attributes
--/info
-- These are routines that let you inspect and alter attributes of various system-wide elements.

-----------------------------------------------------------------------------
--/topic Values
--/info
-- These are routines that let you inspect and alter the current value of a control.
-- This is usually a text value but also include checkboxes,
-- progress bars, and scroll bars.

--/topic Attributes
--/info
-- These are routines that let you inspect and alter attributes of controls.
-- For more specialized routines, see:
--
-- /li /"Edit Control": Working with text edit controls
--          ( /EditText, /MleText ).
-- /li /"List Control": Working with lists ( /List, /SortedList ),
--          combos ( /Combo, /SortedCombo ), etc.
-- /li /"ListView Control"
-- /li /"MonthCalendar Control"
-- /li /"RichEdit Control"
-- /li /"TreeView Control"
-- /li /"Scroll Control": Working with scrollbars ( /HScroll, /VScroll )
--          trackbars ( /HTrackBar, /VTrackbar ) and the /ProgressBar.
-- /li /"UpDown Control"

-----------------------------------------------------------------------------
--/topic Controls
--/info
-- Controls are the basic elements of Windows programs.
-- You can /create them, query and change /Attributes, and respond to
-- /Events.
--
-- See Also: /Attributes

--/topic Forms
--/info
--Forms are a combination of a Window and its controls.
--Win32lib enables easy ways of creating a form and writing event handlers for it.

-----------------------------------------------------------------------------
--/topic Menus
--/info
-- Routines that deal with menu and menuitem handling.

-----------------------------------------------------------------------------
--/topic Dialogs
--/info
-- These are functions the bring up common dialogs.

-----------------------------------------------------------------------------
--/topic Edit Control
--/info
-- These are routines that let you inspect and alter attributes of the text edit controls
-- Such as /EditText, /MleText and /RichEdit.

-----------------------------------------------------------------------------
--/topic Events
--/info
-- Events are routines that are triggered in response to actions taken by the user.
-- Application events, like mouse clicks, key presses, resizing windows, and so on,
-- are the basis for invoking user-developed routines. Once an application calls /WinMain,
-- Windows takes over and only runs the user code when an event, that has been nominated
-- by the user, occurs. To nominate which events the application wishes to respond to, the
-- application must register event handlers for each control/event combination that is relevent.
--
-- To establish an event handler, you use the /setHandler() routine. This links together
-- three things: A control, an Event Type, and a Routine that you write. /n
--Example:
--/code
--      setHandler(okButton, w32HClick, routine_id("myClickHandler"))
--/endcode
--
-- The event handler routine that you write is always passed three parameters: /n
--  /i"integer self" This is the id of the control that triggered the event. /n
--  /i"integer event" This is the Win32lib code for the event type that was
-- triggered. /n
-- /i"sequence parms" This is zero of more parameters that are specific to
-- the type of event being triggered.
--
-- A given event handler can be shared by many controls. In this case, you can use
-- the /i self and /i event parameters to determine your actions.
--/code
--   procedure myClickHandler(integer self, integer event, sequence parms)
--       if self = okBtn then
--          . . .
--       else
--          . . .
--       end if
--   end procedure
--   setHandler({okBtn,cancelBtn}, w32HClick, routine_id("myClickHandler"))
--/endcode

-----------------------------------------------------------------------------
--/topic Fonts
--/info
-- These routines allow you to work with text.
-- Such as displaying text, changing the font, and so on.

-----------------------------------------------------------------------------
--/topic Graphics
--/info
-- These are routines that allow you to draw on controls.
-- Usually used with a /Window, /Pixmap or /Printer.
--
-- The predefined colors are:
--/code
--  Black, NavyBlue, Blue, BrightBlue
--  ForestGreen, Green, Cyan, SkyBlue
--  BrightGreen, BrightCyan, DarkGray, Eggplant
--  Red, Magenta, DarkBrown, Olive
--  Gray, Brown, LightGray, Purple
--  White, BrightRed, BrightMagenta, Violet
--  Orange, Pink, Yellow, Parchment, BrightWhite
--/endcode

-----------------------------------------------------------------------------
--/topic List Control
--/info
-- These are routines that let you inspect and alter attributes of controls with lists
-- This includes /Combo, /DropDownList, /List, /SimpleCombo,
-- /SortedCombo, /SortedList.
--
-- The first item in a list is 1, not 0. This makes it consistant with
-- Euphoria's indexing method, but can be a bit confusing if you are
-- used to working with zero-based arrays.

-----------------------------------------------------------------------------
--/topic Low Level Routines
--/info
-- These routines give you access to low-level internals.
-- Such as C data structures, the device context,
-- and other Win32 API goodies.

-----------------------------------------------------------------------------
--/topic Mouse
--/info
-- These are routines that deal with the mouse and mouse pointer.

-----------------------------------------------------------------------------
--/topic Printing
--/info
-- These are routines that allow you to interact with the /Printer.

-----------------------------------------------------------------------------
--/topic Scroll Control
--/info
-- These routines let you inspect and alter attributes of the scroll bar controls.
-- Including /HScroll and /VScroll and track bar controls /HTrackBar
-- and /VTrackBar.

--/topic Updown Control
--/info
-- These routines let you manage the attributes of the UpDown control.

-----------------------------------------------------------------------------
--/topic Types
--/info
-- These are data types defined by Win32Lib.

-----------------------------------------------------------------------------
--/topic Utilities
--/info
-- These are useful routines that don't seem to fit in any other category.

-----------------------------------------------------------------------------
--/topic XPM
--/info
-- These routines deal with a portable graphics file format called XPM
-- XPM stands for "X Pixmap". XPM graphics can be embedded in programs as text data.

-----------------------------------------------------------------------------
--/topic ListView Control
--/info
-- These routines deal with the /ListView common control. /n
-- It is important to know that each item in a list view has a unique ID
-- number. In other words, no two listview items have the same ID value,
-- regardless of which listview it they are in. The item ID is not the same
-- as its index value. The index value is where in a list view the item is
-- positioned. The ID is used as a way to identify an item without referring
-- to its column values or position. When you add an item using /addLVItem,
-- you get the item's ID returned. /n
--  The following routines support /ListView as well as other controls:
-- /li /deleteItem
-- /li /eraseItems
-- /li /getIndex
-- /li /getItem
-- /li /getData
-- /li /findItem
--
-- The following routines are specific to the /b ListView control.
--
--/li /addLVItem
--/li /getLVAllChecked
--/li /getLVAllText
--/li /getLVChecked
--/li /getLVCount
--/li /getLVItem
--/li /getLVItemlParam
--/li /getLVItemText
--/li /getLVSelected
--/li /getLVSelectedCount
--/li /getLVSelectedText
--/li /hitTestLV
--/li /insertLVColumn
--/li /insertLVItem
--/li /setLVAttr
--/li /setLVChecked
--/li /setLVInsert
--/li /setLVItem
--/li /setLVItemlParam
--/li /setLVItemText
--/li /setLVStyle
--/li /struct_LVCOLUMN
--/li /struct_LVFINDINFO
--/li /struct_LVITEM


-----------------------------------------------------------------------------
--/topic TreeView Control
--/info
-- These routines deal with the /TreeView common control.
-- The following routines support /TreeView as well as other controls:
-- /li /deleteItem
-- /li /eraseItems
-- /li /getIndex
-- /li /getItem
-- /li /getData
--
-- The following routines are specific to the /b TreeView control.
--
--/li /addTVItem
--/li /expandTV
--/li /getTVIndex
--/li /getTVParent
--/li /getTVSelectedText
--/li /getTVText
--/li /hitTestTV
--/li /removeTVItem
--/li /setTVImages
--/li /setTVParent
--/li /setTVText
--/li /struct_TVHITTESTINFO
--/li /struct_TVINSERTSTRUCT
--/li /struct_TVITEM

-----------------------------------------------------------------------------
--/topic Image Lists
--/info
-- These routines deal with win32lib's /ImageList controls.

-----------------------------------------------------------------------------
--/topic MonthCalendar Control
--/info
-- These routines work with /MonthCalendar Controls:

-----------------------------------------------------------------------------
--/topic RichEdit Control
--/info
-- In addition to the specialized /RichEdit control routines.
-- The /"Edit Control" routines also work with /RichEdit Controls:
-- /li /clear( object )
-- /li /copy( object )
-- /li /cut( object )
-- /li /paste( object )
-- /li /undo( object )

--/topic Miscellaneous
--/info
--Routines that don't easily fit into other categories.

--/topic Text
--/info
--Routines that deal with text output.

without trace
--without profile
without warning


object VOID
-- Various routine ids used internally.
global integer
    r_activateTabItems,
    r_addItem,
    r_addStyle,
    r_addToBand,
    r_AppCallback,
    r_attachPopup,
    r_autoclose,
    r_closeWindow,
    r_colorValue,
    r_createBrush,
    r_createEx,
    r_createForm,
    r_createPen,
    r_defineUserProperty,
    r_deleteUserProperty,
    r_destroy,
    r_doEvents,
    r_drawRectangle,
    r_defaultProcessing,
    r_eventLoop,
    r_findChildren,
    r_findParent,
    r_getCaption,
    r_getClientRect,
    r_getCount,
    r_getCtlSize,
    r_getData,
    r_getDC,
    r_getEdit,
    r_getFormIds,
    r_getHandle,
    r_getIdFromDC,
    r_getIndex,
    r_getItem,
    r_getKeyMasks,
    r_getKeyState,
    r_getLVItemText,
    r_getMainWindow,
    r_getPixel,
    r_getPointerRelPos,
    r_getRect,
    r_getScrollPos,
    r_getText,
    r_getTextWidth,
    r_getUserProperty,
    r_isChecked,
    r_isVisible,
    r_libCleanUp,
    r_loadBitmapFromFile,
    r_lvSortitems,
    r_moveZOrder,
    r_openDialog,
    r_openWindow,
    r_registerNotification,
    r_releaseDC,
    r_setBackColor,
    r_setBitmap,
    r_setBuddy,
    r_setControlSet,
    r_setCheck,
    r_setClientRect,
    r_setCtlSize,
    r_setEnable,
    r_setFocus,
    r_setFont,
    r_setHintEx,
    r_setIcon,
    r_setIndex,
    r_setLVItem,
    r_setLVStyle,
    r_setMousePointer,
    r_setPenColor,
    r_setPenPos,
    r_setRect,
    r_setScrollChange,
    r_setScrollPos,
    r_setScrollRange,
    r_setSubFields,
    r_setText,
    r_setUserProperty,
    r_setVisible,
    r_setWindowScrollRange,
    r_validId,
    r_wDebug

include machine.e
include dll.e
include msgbox.e
include file.e
include get.e
include wildcard.e
include image.e
include w32Keys.e         -- Definitions of Windows keycodes.
include w32msgs.e
include w32support.e
include w32dll.ew
include w32user.ew
include w32gdi.ew
include w32winmm.ew
include w32comdlg.ew
include w32comctl.ew
include w32Kernel.ew as KNL
include w32Shell.ew
include w32file.ew
include w32advapi.ew


include series.e as series
include rttext.e as rt


atom vPermMemSet
vPermMemSet = w32new_memset()

integer vWinMainState
integer vEndAction
constant kNotStarted = 0,
     kStarted = 1,
     kFinished = 2
vWinMainState = kNotStarted  -- If set to non-zero, then eventLoop does nothing.
vEndAction = -1

--/topic Constants
--/info These are constants that are used in a number of Win32Lib routines.
--They are often required to send information to the routines in the library.
--


--/topic Constants
--/const Win32LibVersion
--/desc Contains the current version of win32lib library.
-- This is a sequence containing three elements. /n
--/li Major version number
--/li Minor version number
--/li Patch or /i Revision number
--/li Date of the version in DD-mmm-YYYY format
--
--Example
--/code
--       setText(SB, sprintf("Win32Lib version %d.%d Patch#%d, %s",
--                            Win32LibVersion))
--/endcode
global constant
    Win32LibVersion = {0,60,6, "19-Sep-2004"}   -- {Major, Minor, Patch, Date}
sequence vAppName vAppName = "Win32Lib AppWindow"

-- Initialise the general UI message subsystem.
Init_UI_Msgs({
                  {"AppName", vAppName},
                  {"AppVersion", sprintf("Win32Lib v%d.%d.%d %s",
                        	        {Win32LibVersion[1],
                        	         Win32LibVersion[2],
                        	         Win32LibVersion[3],
                                     Win32LibVersion[4]})
                  }
                 })

-- Set the message handler for memory allocation errors.
VOID = w32llSetAbort(routine_id("abortErr"))
constant vkEvents = series:next_number(0)
global constant
    w32HBreak     = series:next_number(vkEvents),
    w32HPause     = series:next_number(vkEvents),
    w32HMouse     = series:next_number(vkEvents),
    w32HClick     = series:next_number(vkEvents),
    w32HKeyPress  = series:next_number(vkEvents),
    w32HKeyUp     = series:next_number(vkEvents),
    w32HKeyDown   = series:next_number(vkEvents),
    w32HResize    = series:next_number(vkEvents),
    w32HChange    = series:next_number(vkEvents),
    w32HGotFocus  = series:next_number(vkEvents),
    w32HLostFocus = series:next_number(vkEvents),
    w32HScroll    = series:next_number(vkEvents),
    w32HOpen      = series:next_number(vkEvents),
    w32HClose     = series:next_number(vkEvents),
    w32HDestroy   = series:next_number(vkEvents),
    w32HTimer     = series:next_number(vkEvents),
    w32HPaint     = series:next_number(vkEvents),
    w32HDragAndDrop = series:next_number(vkEvents),
    w32HEvent     = series:next_number(vkEvents),
    w32HActivate  = series:next_number(vkEvents),
    w32HAfterEvent = series:next_number(vkEvents), -- Not supported by onXXX
    w32HDropDown  = series:next_number(vkEvents), -- Not supported by onXXX
    w32HCloseUp   = series:next_number(vkEvents), -- Not supported by onXXX
    w32HIdle      = series:next_number(vkEvents),  -- Not supported by onXXX
    w32HMouseTrap    = series:next_number(vkEvents),  -- Not supported by onXXX
    w32HNotify    = series:next_number(vkEvents),  -- Not supported by onXXX
    w32HGetHandler = series:next_number(vkEvents),  -- Not supported by onXXX
    w32HDataChange = series:next_number(vkEvents) -- Not supported by onXXX

integer w32LastEventType w32LastEventType = series:current_number(vkEvents)

global constant
    -- used in alignControls()
    w32LeftEdge   = 'L',
    w32Leftmost   = 'l',
    w32TopEdge    = 'T',
    w32Topmost    = 't',
    w32RightEdge  = 'R',
    w32Rightmost  = 'r',
    w32BottomEdge = 'B',
    w32Bottommost = 'b',
    -- used in distributeControls()
    w32VertCentre = 'V',
    w32HorzCentre = 'H',
    w32VertGap    = 'v',
    w32HorzGap    = 'h',
    -- used in sizeControls()
    w32Widest     = 'W',
    w32Narrowest  = 'N',
    w32Tallest    = 'T',
    w32Shortest   = 'S',
    w32Width      = 'w',
    w32Height     = 'h',
    -- Request Codes
    w32Request_RtnId = 'r'

--/topic Constants
--/const kMainMsg
--/desc Used by the notify handlers. See /setNotifyHandler

--/topic Constants
--/const kSubclassedMsg
--/desc Used by the notify handlers. See /setNotifyHandler


--/topic Constants
--/const w32PB_ICON
--/desc Used when creating a /PictureButton and /ToggleButton.

--/topic Constants
--/const w32PB_BITMAP
--/desc Used when creating a /PictureButton and /ToggleButton.

--/topic Constants
--/const w32KH_SetFocus
--/desc Used as a return value by w32HKeyDown handlers to indicate that the focus needs to be changed.

--/topic Constants
--/const w32LV_StartSorting
--/desc Used by /ListView controls that have a custom sorting routine.

--/topic Constants
--/const w32LV_EndSorting
--/desc Used by /ListView controls that have a custom sorting routine.

-- Some magic numbers.
global constant
    kMainMsg = -2761,
    kSubclassedMsg = -9987,
    kReturnNow = kMainMsg,
    kWinDefProc = kSubclassedMsg,

    w32PB_ICON = {-1,"icon"},
    w32PB_BITMAP = {-1,"bitmap"},

    w32KH_SetFocus = {-1, "setfocus"},

    w32LV_StartSorting = 0,
    w32LV_EndSorting = 1


r_AppCallback = -1

sequence vWinMsg        vWinMsg = repeat(0, 16)
integer  vWMI           vWMI = 0
sequence vDuringPaint   vDuringPaint = {}
sequence vDragData      vDragData = {}

-- Handle to the cryptographic service provider
atom vCSP vCSP = 0
global atom w32Seed w32Seed = #30000000 + rand(#FFFFFFF)

-- Font Weights
global constant
    FW_DONTCARE = 0,
    FW_THIN    = 100,
    FW_EXTRALIGHT = 200,
    FW_ULTRALIGHT = 200,
    FW_LIGHT = 300,
    FW_NORMAL = 400,
    FW_REGULAR = 400,
    FW_MEDIUM = 500,
    FW_SEMIBOLD = 600,
    FW_DEMIBOLD = 600,
    FW_BOLD = 700,
    FW_EXTRABOLD = 800,
    FW_ULTRABOLD = 800,
    FW_HEAVY = 900,
    FW_BLACK = 900

-- Use Logical or Screen resolutions in Font Creation.
integer vFontResolution vFontResolution = 1 -- Use screen resolution
sequence vFontKeys      vFontKeys = {}
sequence vFontHandles   vFontHandles = {}
integer vFontWeight     vFontWeight = FW_BOLD

-----------------------------------------------------------------------------
-- current id and return value
sequence idStack, returnStack
integer SP
    SP = 0
    idStack = repeat(0, 10)
    returnStack = repeat(0, 10)

-----------------------------------------------------------------------------

--/topic System Attributes
--/func setEndAction(integer code)
--/desc Sets the exit code and behaviour at application closure.
--/ret INTEGER: Current value of the exit code
--This is used to signal what is to happen when the main window
--is closed. At that time, if the last use of setEndAction() uses
--a /i code less than zero, control returns to the application
--from the /WinMain() call. However, a /i code of zero or higher
--causes the library to call the standard Euphoria abort() routine
--using the value of /i code.
--
--Example
--/code
--      integer CurrentVal
--      -- Set the app to end when the main window is closed.
--      CurrentVal = setEndAction(0)
--
--/endcode
global function setEndAction(integer code)
    integer lCurVal

    lCurVal = vEndAction
    vEndAction = code
    return vEndAction
end function

--/topic Attributes
--/func getSelf()
--/desc Get the id number of the current active control.
--/ret (INTEGER) id of active control. /i Zero if no control is active.
--This is used by event handlers to find out which control was active when
--the event was invoked.
--
--Example
--/code
--      procedure Clicker()
--        integer lSelf
--
--        lSelf = getSelf()
--        if lSelf = btnOne then
--           ...
--        else
--           ...
--        end if
--      end procedure
--/endcode
global function getSelf()
    -- return id of current active control
    if SP > 0 then
      return idStack[SP]
    else
      return 0
    end if
end function



constant
   Err_GETHCHANGED = {"getHandle:The stored hWnd for id %d is now attached to id %d", 499},
--   Err_COMCTLFAIL = {"Common controls could not be initialized!", 498},
   Err_GETHOBJECTDESTROYED = {"getHandle: Object is destroyed.", 497},
   Err_GETHNULLHANDLE = {"getHandle returned Null handle.", 496},
   Err_GETHFAIL = {"getHandle failed.", 495},
   Err_GETDCFAIL = {"getDC:GetDC failed.", 494},
--   Err_SAVEDCFAIL = {"getDC:SaveDC failed.", 493},
   Err_RELEASEDCRESTORE = {"releaseDC:RestoreDC failed.", 492},
   Err_ECFSAVEDCFAIL = {"ezCreateFont:SaveDC failed.", 491},
--   Err_ECFSETVIEWPORT = {"ezCreateFont:SetViewportOrgEx failed.", 490},
--   Err_ECFSETWINDOW = {"ezCreateFont:SetWindowOrgEx failed.", 489},
--   Err_ECFDPTOLP = {"ezCreateFont:DPtoLP failed.", 488},
--   Err_ECFGETTEXTMETRICS = {"ezCreateFont:GetTextMetrics failed.", 487},
   Err_ECFRESTOREDC = {"ezCreateFont:RestoreDC failed.", 486},
--   Err_QFNOWINDOW = {"queryFont: no windows defined", 485},
   Err_GETTEXTEXTENT = {"getTextExtent:GetTextExtentPoint failed.", 484},
   Err_REGCLASS = {"RegisterClassEx failed.", 483},
   Err_CREATEWINDOW = {"CreateWindow in createWindow failed.", 482},
   Err_CREATETABITEM = {"Failed to create a TabItem in create:createTabItem.", 481},
--   Err_DESTROYWINDOW = {"destroy:Window failed", 480},
--   Err_DESTROYBUTTON = {"destroy:Button failed", 479},
--   Err_DESTROYCONTROL = {"destroy:Control failed", 478},
   Err_DESTROYMENU = {"destroy:Menu failed", 477},
--   Err_DESTROYMENUITEM = {"destroy:MenuItem failed", 476},
--   Err_DESTROYCLASS = {"destroy: Class cannot be destroyed yet.", 475},
--   Err_FPINVALIDATERECT = {"InvalidateRect in flushPaintEvent failed.", 474},
--   Err_RWINVALIDATERECT = {"InvalidateRect in repaintWindow failed.", 473},
   Err_GSGETWINDRECT = {"getRect:GetWindowRect failed.", 472},
   --Err_CREATEMDIWINDOW = {"CreateMDIWindow in createMDIWindow failed.", 471},
   --Err_CPCLIENTTOSCREEN = {"getClientPoint:ClientToScreen failed.", 470},
   Err_WNDPROCNOID = {"routine_id for WndProc failed!", 469},
   Err_SUBPROCNOID = {"routine_id for SubProc failed!", 468},
--   Err_BADID = {"Unknown control id supplied.", 467},
   Err_STACKERR = {"Internal ID or Return stack lengths incorrect.", 466},
   Err_CREATETABITEM2 = {"Cannot create a TabItem: Parent not a TabControl.", 462},
   Err_CREATECONTROL = {"Failed to acquire a hWnd when creating a control.", 461},
--   Err_CREATECONTROL2 = {"Failed to acquire a hWnd when subclassing a control.", 460},
   Err_OWNERINVALID = {"create():Invalid parent id.", 459},
   Err_RELEASEPRINTER = {"releasePrinter:DeleteDC failed.",458},
--   Err_GETDCBITMAP = {"getDC( bitmap ):CreateCompatibleDC failed.",457},
--   Err_GETDCSELECTBITMAP = {"getDC:SelectObject(bitmap) failed.",456},
--   Err_GETDCPIXMAP = {"getDC(pixmap):CreateCompatibleDC failed.",455},
--   Err_GETDCSELECTPIXMAP = {"getDC:SelectObject(pixmap) failed.",454},
--   Err_EMPTYDCSTACK = {"ReleaseDC without matching GetDC.",453},
   Err_RELEASESCREEN = {"releaseDC:ReleaseDC (screen) failed.",452},
   Err_RELEASEBITMAP = {"releaseDC:DeleteDC (bitmap) failed.",451},
   Err_RELEASEPIXMAP = {"releaseDC:DeleteDC (Pixmap) failed.",450},
   Err_RELEASEDC = {"releaseDC:ReleaseDC failed.",449},
   Err_SETTEXTCOLOR = {"SetTextColor in assignFont failed.",448},
   Err_SETBKMODE = {"SetBkMode in assignFont failed.",447},
   Err_GETFONTMETRIC = {"GetTextMetrics in getFontSize failed.",446},
   Err_GETFONTSIZE = {"GetTextMetrics in getFontSize failed.",445},
   Err_CREATEMENU = {"CreateMenu in createMenu failed.",444},
   Err_SETMENU = {"SetMenu in createMenu failed.",443},
   Err_CREATEPOPUP = {"CreatePopupMenu in CreateMenu failed.",442},
   Err_APPENDMENU = {"AppendMenu in createMenu failed.",441},
   Err_APPENDMENUITEM = {"AppendMenu in createMenuItem failed.",440},
   Err_CREATEPIXMAP = {"createPixmap:CreateCompatibleBitmap failed",439},
   Err_FLATTOOLBARBTN = {"createEx: failed to create button",438},
   Err_REPAINTRECT = {"InvalidateRect in repaintRect failed.",437},
   Err_GSGETBITMAP = {"getRect:GetObject for bitmap failed.",436},
   Err_GSGETPIXMAP = {"getRect:GetObject for pixmap failed.",435},
   Err_GCSGETCLIENTRECT = {"getClientSize:GetClientRect failed.",434},
   --Err_GCSCLIENTTOSCREEN = {"getClientSize:ClientToScreen failed.",433},
   Err_GCRGETCLIENTRECT = {"getClientRect:GetClientRect failed.",432},
--   Err_SETTEXT = {"SetWindowText in setText failed.",431},
   Err_SETENABLE = {"EnableMenuItem in enableMenuItem failed.",430},
   Err_SETCHECK = {"CheckMenuItem in checkMenuItem failed.",429},
   Err_SETBKCOLOR = {"SetBkColor in assignFont failed.",428},
   --Err_CLIENTTOSCREEN = {"ClientToScreen failed.", 427},
   Err_SCREENTOCLIENT = {"ScreenToClient failed.", 426},
   Err_WRONGOWNER = {"LOGIC ERROR: Held resource owner is not the actual owner.", 425}
----------------------------------------------------------------------------

--/topic System Attributes
--/func getSystemMetrics( object Code )
--/desc Allows you to get miscellaneous information about the Windows system your application is running on.
--/ret Depends on the input /i Code.
-- Note that /i Code can be an atom for single requests or a sequence of
-- atoms for multiple requests in one call. /n
--The codes and their return values are... /n
--/define
--/term  SM_CYMIN
--/term  SM_CXMIN
--/term  SM_ARRANGE
-- How the system arranges minimized windows. This consists of a starting
-- position and a direction. The starting position can be one of the
--following values. /n
-- ARW_BOTTOMLEFT Start at the lower-left corner of the screen (default position). /n
-- ARW_BOTTOMRIGHT Start at the lower-right corner of the screen. /n
-- ARW_HIDE Hide minimized windows by moving them off the visible area of the screen. /n
-- ARW_TOPLEFT Start at the upper-left corner of the screen. /n
-- ARW_TOPRIGHT Start at the upper-right corner of the screen. /n
-- The direction in which to arrange can be one of the following values. /n
-- ARW_DOWN Arrange vertically, top to bottom. /n
-- ARW_LEFT Arrange horizontally, left to right. /n
-- ARW_RIGHT Arrange horizontally, right to left. /n
-- ARW_UP Arrange vertically, bottom to top. /n
--/term  SM_CLEANBOOT
-- Value that specifies how the system was started: /n
-- 0 Normal boot /n
-- 1 Fail-safe boot /n
-- 2 Fail-safe with network boot /n
--/term  SM_CMOUSEBUTTONS
-- Number of buttons on mouse, or zero if no mouse is installed.
--/term  SM_CXBORDER
-- Width, in pixels, of a window border. This is equivalent to the SM_CXEDGE value for windows with the 3-D look.
--/term  SM_CYBORDER
-- Height, in pixels, of a window border. This is equivalent to the SM_CXEDGE value for windows with the 3-D look.
--/term  SM_CXCURSOR
-- Width, in pixels, of a cursor.
--/term  SM_CYCURSOR
-- Height, in pixels, of a cursor.
--/term  SM_CXDOUBLECLK
--/term  SM_CYDOUBLECLK
--/term  SM_CXDRAG
--/term  SM_CYDRAG
--/term  SM_CXEDGE
--/term  SM_CYEDGE
--/term  SM_CXFIXEDFRAME
--/term  SM_CYFIXEDFRAME
--/term  SM_CXFRAME
--/term  SM_CYFRAME
--/term  SM_CXFULLSCREEN
--/term  SM_CYFULLSCREEN
--/term  SM_CXHSCROLL
--/term  SM_CYHSCROLL
--/term  SM_CXHTHUMB
--/term  SM_CXICON
--/term  SM_CYICON
--/term  SM_CXICONSPACING
--/term  SM_CYICONSPACING
--/term  SM_CXMAXIMIZED
--/term  SM_CYMAXIMIZED
--/term  SM_CXMAXTRACK
--/term  SM_CYMAXTRACK
--/term  SM_CXMENUCHECK
--/term  SM_CYMENUCHECK
--/term  SM_CXMENUSIZE
--/term  SM_CYMENUSIZE
--/term  SM_CXMINIMIZED
--/term  SM_CYMINIMIZED
--/term  SM_CXMINSPACING
--/term  SM_CYMINSPACING
--/term  SM_CXMINTRACK
--/term  SM_CYMINTRACK
--/term  SM_CXSCREEN
--/term  SM_CYSCREEN
--/term  SM_CXSIZE
--/term  SM_CYSIZE
--/term  SM_CXSIZEFRAME
--/term  SM_CYSIZEFRAME
--/term  SM_CXSMICON
--/term  SM_CYSMICON
--/term  SM_CXSMSIZE
--/term  SM_CYSMSIZE
--/term  SM_CXVSCROLL
--/term  SM_CYVSCROLL
--/term  SM_CYVTHUMB
--/term  SM_CYCAPTION
--/term  SM_CYKANJIWINDOW
--/term  SM_CYMENU
--/term  SM_CYSMCAPTION
--/term  SM_DBCSENABLED
--/term  SM_DEBUG
--/term  SM_MENUDROPALIGNMENT
--/term  SM_MIDEASTENABLED
--/term  SM_MOUSEPRESENT
--/term  SM_MOUSEWHEELPRESENT
--/term  SM_NETWORK
--/term  SM_PENWINDOWS
--/term  SM_SECURE
--/term  SM_SHOWSOUNDS
--/term  SM_SLOWMACHINE
--/term  SM_SWAPBUTTON
--/enddefine

global function getSystemMetrics( object Code )
    sequence lResult
    if atom(Code) then
        return w32Func( xGetSystemMetrics, { Code } )
    end if

    lResult = repeat(0, length(Code))
    for i = 1 to length(Code) do
        lResult[i] = w32Func( xGetSystemMetrics, { Code[i] })
    end for
    return lResult
end function



-----------------------------------------------------------------------
--/topic Mouse
--/proc setPointerPos(sequence pos)
--/desc Moves the mouse pointer to a specified spot on the screen.
-- /i pos is a two-element sequence that specifies the /b X and /b Y position
-- that the mouse pointer is to be moved to.
--
-- Example:
--/code
--      -- Move the mouse pointer to 120,76
--      setPointerPos({120, 76})
--/endcode

global procedure setPointerPos(sequence pos)
    w32Proc(xSetCursorPos,{pos[1],pos[2]})
end procedure




-----------------------------------------------------------------------
--/topic Mouse
--/func getWheelScrollLines()
--/desc Retrieves the number of lines that a mouse wheel movement represents.
--/ret ATOM: The number of lines.
--
-- Example:
--/code
--  atom cnt
--  cnt = getWheelScrollLines()
--/endcode
atom gwsMem gwsMem = w32acquire_mem(vPermMemSet, 4)
global function getWheelScrollLines()
    atom lLines

    VOID = w32Func(xSystemParametersInfo,{SPI_GETWHEELSCROLLLINES,0,gwsMem,0})
    lLines =  peek4u(gwsMem)
    return lLines
end function


-----------------------------------------------------------------------
--/topic Mouse
--/func getPointerPos()
--/desc Find where the mouse pointer is on the screen.
--/ret SEQUENCE: {X,Y} The mouse position.
-- This returns a two-element sequence that specifies the /b X and /b Y position
-- of the mouse pointer.
--
-- Example:
--/code
-- sequence pos
--
--  pos = getPointerPos()
--  if pos[1] > 200 then
--      -- code goes here...
--  end if
--/endcode
atom gppMem gppMem = w32acquire_mem(vPermMemSet, 8)
global function getPointerPos()
    VOID = w32Func(xGetCursorPos,{gppMem})
    return peek4s({gppMem, 2})
end function

--/topic Mouse
--/proc clickPointerLeft()
--/desc Simulates the clicking of the left mouse button.
--
--Example
--/code
--  clickPointerLeft()
--/endcode
global procedure clickPointerLeft()
    w32Proc(xmouse_event,{6,0,0,0,0})
end procedure

--/topic Mouse
--/proc dragPointerTo(sequence pos)
--/desc Simulates the draging of the left mouse button to a specified position.
-- /i pos is a two-element sequence that contains the /b X and /b Y location to drag the pointer to.
--
--Example
--/code
--  dragPointerTo( {100, 200} )
--/endcode

global procedure dragPointerTo(sequence pos)
    w32Proc(xmouse_event,{#2,0,0,0,0})
    w32Proc(xSetCursorPos,{pos[1],pos[2]})
    w32Proc(xmouse_event,{#4,0,0,0,0})
end procedure


--/topic System Attributes
--/func getWinVersion()
--/desc Gets the version information of the windows platform you are running in.
--/ret SEQUENCE: {WinVer, VariantString, BuildNo}
--
-- /i WinVer return value can be one of ... /n
--<ul>
--/li WIN_3_1
--/li WIN_95
--/li WIN_95_OSR2
--/li WIN_98
--/li WIN_98SE
--/li WIN_ME
--/li WIN_NT_3_51
--/li WIN_NT_4
--/li WIN_2000
--/li WIN_XP
--/li WIN_UNKNOWN
--</ul>
-- /i VariantString is a service pack name. /n
--/i BuildNo is the operating system's build number.
--
--Example
--/code
--      sequence winver
--      winver = getWinVersion()
--/endcode
global constant
    WIN_3_1     = 1,
    WIN_95      = 2,
    WIN_95_OSR2 = 2.5,
    WIN_98      = 3,
    WIN_98SE    = 3.5,
    WIN_ME      = 4,
    WIN_NT_3_51 = 5,
    WIN_NT_4    = 6,
    WIN_2000    = 7,
    WIN_XP      = 8,
    WIN_UNKNOWN = 0

global function getWinVersion()
    sequence lResult
    atom lOV
    atom lResp

    lOV = w32acquire_mem(0, SIZEOF_OSVERSIONINFOEX)
    w32store(lOV, dwOSVersionInfoSize,  SIZEOF_OSVERSIONINFOEX)
    lResp = w32Func(xGetVersionEx, {lOV})
    lResult = repeat(0,9)
    if lResp = 0 then
        w32store(lOV, dwOSVersionInfoSize,  SIZEOF_OSVERSIONINFO)
        lResp = w32Func(xGetVersionEx, {lOV})
    end if
    lResult[1..4] = peek4s({lOV+4, 4})
    lResult[5] = w32peek_string(lOV + 20)
    lResult[6]  = w32fetch(lOV,wServicePackMajor)
    lResult[7]  = w32fetch(lOV,wServicePackMinor)
    lResult[8]  = w32fetch(lOV,wSuiteMask)
    lResult[9]  = w32fetch(lOV,wProductType)

    w32release_mem(lOV)
    if lResult[4] = 0 then
        lResult[1] = WIN_3_1
    elsif lResult[4] = 1 then
        if lResult[2] = 0 then
            if equal(lResult[5], " C") then
                lResult[1] = WIN_95_OSR2
            else
                lResult[1] = WIN_95
            end if

        elsif lResult[2] = 10 then
            if equal(lResult[5], " A") then
                lResult[1] = WIN_98SE
            else
                lResult[1] = WIN_98
            end if
        else
            lResult[1] = WIN_ME
        end if
        lResult[3] = and_bits(#FFFF, lResult[3])
    else
        if lResult[2] = 51 then
            lResult[1] = WIN_NT_3_51
        elsif lResult[2] = 0 then
            if lResult[1] = 4 then
                lResult[1] = WIN_NT_4
            else
                lResult[1] = WIN_2000
            end if
        elsif lResult[2] = 1 then
            lResult[1] = WIN_XP
        else
            lResult[1] = WIN_UNKNOWN
        end if
    end if
    lResult[2] = lResult[5]

    if lResult[6] = 0 then
        lResult = lResult[1..3]
    else
        lResult = lResult[1..3] & lResult[6..9]
    end if

    return lResult
end function

global constant WINDOWS_VERSION = getWinVersion()

-- Moved initialization of common controls to procedure.  Also had to
-- move location in order to use structures.
global constant
    ICC_LISTVIEW_CLASSES = #1, --// listview, hader
    ICC_TREEVIEW_CLASSES = #2, --// treeview, tooltips
    ICC_BAR_CLASSES      = #4, --// toolbar, statusbar, trackbar, tooltips
    ICC_TAB_CLASSES      = #8, --// tab, tooltips
    ICC_UPDOWN_CLASS     = #10, --// updown
    ICC_PROGRESS_CLASS   = #20, --// proress
    ICC_HOTKEY_CLASS     = #40, --// hotkey
    ICC_ANIMATE_CLASS    = #80, --// animate
    ICC_WIN95_CLASSES    = #FF,
    ICC_DATE_CLASSES     = #100, -- month picker, date picker, time picker, updown
    ICC_USEREX_CLASSES   = #200, -- comboex
    ICC_COOL_CLASSES     = #400, -- rebar (coolbar) control
    ICC_INTERNET_CLASSES = #800,
    ICC_PAGESCROLLER_CLASS = #1000,   -- page scroller
    ICC_NATIVEFNTCTL_CLASS = #2000,

    INITCOMMONCONTROLSEX_dwSize = w32allot( Long ),
    INITCOMMONCONTROLSEX_dwICC = w32allot( Long ),
    SIZEOF_INITCOMMONCONTROLSEX = w32allotted_size()


constant ccNames = {
    "LISTVIEW",
    "TREEVIEW",
    "BAR",
    "TAB",
    "UPDOWN",
    "PROGRESS",
    "HOTKEY",
    "ANIMATE",
    "DATE",
    "COMBOEX",
    "REBAR",
    "INTERNET",
    "PAGESCROLLER",
    "NATIVEFNTCTL"
    }
-----------------------------------------------------------------------------
procedure InitCommonControls()
    atom icc
    integer lClassFlag
    sequence lNames

    lNames = {}
    icc = w32acquire_mem( 0, SIZEOF_INITCOMMONCONTROLSEX )
    w32store( icc, INITCOMMONCONTROLSEX_dwSize, SIZEOF_INITCOMMONCONTROLSEX )
    lClassFlag = 1
    for i = 1 to length(ccNames) do
        w32store( icc, INITCOMMONCONTROLSEX_dwICC, lClassFlag)
        if w32Func( xInitCommonControlsEx, {icc} ) = 0 then
            lNames &= '\t' & ccNames[i] & '\n'
        end if
        lClassFlag *= 2
    end for
    if WINDOWS_VERSION[1] >= WIN_98 and length(lNames) > 0 then
        warnErr("The following Common Control Classes cannot be used...\n" &
                 lNames & "\nYou may need to install the latest 'comctl32.dll'")
    end if
    w32release_mem( icc )
end procedure

InitCommonControls()
-----------------------------------------------------------------------------
global constant
    -- Private Window Messages Start Here:
    WM_USER = #400,

    -- defining a window
    winExSize         = w32allot( UInt ),
    winExStyle        = w32allot( UInt ),
    winExProc         = w32allot( Long ),
    winExClsExtra     = w32allot( Long ),
    winExExtra        = w32allot( Long ),
    winExInstance     = w32allot( UInt ),
    winExIcon         = w32allot( UInt ),
    winExCursor       = w32allot( Long ),
    winExBackground   = w32allot( Long ),
    winExMenuName     = w32allot( Lpsz ),
    winExClassName    = w32allot( Lpsz ),
    winExIconSm       = w32allot( UInt ),
    SIZEOF_WNDCLASSEX = w32allotted_size(),


-----------------------------------------------------------------------------
-- Type RECT
    rectLeft            = w32allot( Long ),
    rectTop             = w32allot( Long ),
    rectRight           = w32allot( Long ),
    rectBottom          = w32allot( Long ),
    SIZEOF_RECT        = w32allotted_size(),


-----------------------------------------------------------------------------
-- Type ICONINFO
    iconinfo_fIcon      = w32allot(Long),
    iconinfo_xHotspot   = w32allot(DWord),
    iconinfo_yHotspot   = w32allot(DWord),
    iconinfo_hbmMask    = w32allot(Ptr),
    iconinfo_hbmColor   = w32allot(Ptr),
    SIZEOF_ICONINFO     = w32allotted_size(),


-----------------------------------------------------------------------------
-- Type DRAWTEXTPARAMS
    DTP_cbSize            = w32allot( UInt ),
    DTP_iTabLength        = w32allot( Long ),
    DTP_iLeftMargin       = w32allot( Long ),
    DTP_iRightMargin      = w32allot( Long ),
    DTP_uiLengthDrawn     = w32allot( UInt ),
    SIZEOF_DRAWTEXTPARAMS = w32allotted_size(),

    DT_TOP                  = #00000000,
    DT_LEFT                 = #00000000,
    DT_CENTER               = #00000001,
    DT_RIGHT                = #00000002,
    DT_VCENTER              = #00000004,
    DT_BOTTOM               = #00000008,
    DT_WORDBREAK            = #00000010,
    DT_SINGLELINE           = #00000020,
    DT_EXPANDTABS           = #00000040,
    DT_TABSTOP              = #00000080,
    DT_NOCLIP               = #00000100,
    DT_EXTERNALLEADING      = #00000200,
    DT_CALCRECT             = #00000400,
    DT_NOPREFIX             = #00000800,
    DT_INTERNAL             = #00001000,
    DT_EDITCONTROL          = #00002000,
    DT_PATH_ELLIPSIS        = #00004000,
    DT_END_ELLIPSIS         = #00008000,
    DT_MODIFYSTRING         = #00010000,
    DT_RTLREADING           = #00020000,
    DT_WORD_ELLIPSIS        = #00040000,
    DT_NOFULLWIDTHCHARBREAK = #00080000,
    DT_HIDEPREFIX           = #00100000,
    DT_PREFIXONLY           = #00200000,

-----------------------------------------------------------------------------
-- Type PAINTSTRUCT
    psHdc               = w32allot( UInt ),
    psErase             = w32allot( Long ),
    psPaintRect         = w32allot( {4, Long} ),
    psRestore           = w32allot( Long ),
    psIncUpdate         = w32allot( Long ),
    psRgbReserved       = w32allot( {32, Byte} ),
    SIZEOF_PAINTSTRUCT  = w32allotted_size(),


-----------------------------------------------------------------------------
-- defining a font
    lfHeight            = w32allot( Long ),
    lfWidth             = w32allot( Long ),
    lfEscapement        = w32allot( Long ),
    lfOrientation       = w32allot( Long ),
    lfWeight            = w32allot( Long ),
    lfItalic            = w32allot( Byte ),
    lfUnderline         = w32allot( Byte ),
    lfStrikeOut         = w32allot( Byte ),
    lfCharSet           = w32allot( Byte ),
    lfOutPrecision      = w32allot( Byte ),
    lfClipPrecision     = w32allot( Byte ),
    lfQuality           = w32allot( Byte ),
    lfPitchAndFamily    = w32allot( Byte ),
    lfFaceName          = w32allot( {32, Strz} ),
    SIZEOF_LOGFONT     = w32allotted_size(),

-----------------------------------------------------------------------------
-- Type TEXTMETRIC
    tmHeight            = w32allot( Long ),
    tmAscent            = w32allot( Long ),
    tmDescent           = w32allot( Long ),
    tmInternalLeading   = w32allot( Long ),
    tmExternalLeading   = w32allot( Long ),
    tmAveCharWidth      = w32allot( Long ),
    tmMaxCharWidth      = w32allot( Long ),
    tmWeight            = w32allot( Long ),
    tmOverhang          = w32allot( Long ),
    tmDigitizedAspectX  = w32allot( Long ),
    tmDigitizedAspectY  = w32allot( Long ),
    tmFirstChar         = w32allot( Byte ),
    tmLastChar          = w32allot( Byte ),
    tmDefaultChar       = w32allot( Byte ),
    tmBreakChar         = w32allot( Byte ),
    tmItalic            = w32allot( Byte ),
    tmUnderlined        = w32allot( Byte ),
    tmStruckOut         = w32allot( Byte ),
    tmPitchAndFamily    = w32allot( Byte ),
    tmCharSet           = w32allot( Byte ),
    ntmFlags            = w32allot( Long ),
    ntmSizeEM           = w32allot( Long ),
    ntmCellHeight       = w32allot( Long ),
    ntmAveWidth         = w32allot( Long ),
    SIZEOF_TEXTMETRIC  = w32allotted_size(),



-----------------------------------------------------------------------------
-- Type POINT
    ptX                 = w32allot( Long ),
    ptY                 = w32allot( Long ),
    SIZEOF_POINT       = w32allotted_size(),


-----------------------------------------------------------------------------
-- Type MSG
    msgHWnd             = w32allot( UInt ),
    msgMessage          = w32allot( UInt ),
    msgWParam           = w32allot( Long ),
    msgLParam           = w32allot( Long ),
    msgTime             = w32allot( DWord ),
    msgPtX              = w32allot( Long ),
    msgPtY              = w32allot( Long ),
    SIZEOF_MSG          = w32allotted_size(),

-----------------------------------------------------------------------------
-- Type SIZE
    sizX                = w32allot( Long ),
    sizY                = w32allot( Long ),
    SIZEOF_SIZE         = w32allotted_size(),

-----------------------------------------------------------------------------
-- Type BITMAP
    bmType          = w32allot( Long ),
    bmWidth         = w32allot( Long ),
    bmHeight        = w32allot( Long ),
    bmWidthBytes    = w32allot( Long ),
    bmPlanes        = w32allot( Word ),
    bmBitsPixel     = w32allot( Word ),
    bmBits          = w32allot( Long ),
    SIZEOF_BITMAP   = w32allotted_size(),

-----------------------------------------------------------------------------
-- Type BITMAPFILEHEADER
    bfType          = w32allot( {2, Byte} ),
    bfSize          = w32allot( DWord ),
    bfReserved1     = w32allot( Word ),
    bfReserved2     = w32allot( Word ),
    bfOffBits       = w32allot( DWord ),
    SIZEOF_BITMAPFILEHEADER = w32allotted_size(),

-----------------------------------------------------------------------------
-- Type BITMAPINFOHEADER
    biSize          = w32allot( DWord ),
    biWidth         = w32allot( Long ),
    biHeight        = w32allot( Long ),
    biPlanes        = w32allot( Word ),
    biBitCount      = w32allot( Word ),
    biCompression   = w32allot( DWord ),
    biSizeImage     = w32allot( DWord ),
    biXPelsPerMeter = w32allot( Long ),
    biYPelsPerMeter = w32allot( Long ),
    biClrUsed       = w32allot( DWord ),
    biClrImportant  = w32allot( DWord ),
    SIZEOF_BITMAPINFOHEADER = w32allotted_size(),

-----------------------------------------------------------------------------
-- Type BITMAPCOREHEADER
    bcSize                  = w32allot( Long ),
    bcWidth                 = w32allot( Word ),
    bcHeight                = w32allot( Word ),
    bcPlanes                = w32allot( Word ),
    bcBitCount              = w32allot( Word ),
    SIZEOF_BITMAPCOREHEADER = w32allotted_size(),

-----------------------------------------------------------------------------
-- Type RGBTRIPLE
    rgbtBlue        = w32allot( Byte ),
    rgbtGreen       = w32allot( Byte ),
    rgbtRed         = w32allot( Byte ),
    SIZEOF_RGBTRIPLE  = w32allotted_size(),

-----------------------------------------------------------------------------
-- Type RGBQUAD
    rgbBlue         = w32allot( Byte ),
    rgbGreen        = w32allot( Byte ),
    rgbRed          = w32allot( Byte ),
    rgbReserved     = w32allot( Byte ),
    SIZEOF_RGBQUAD  = w32allotted_size(),

-----------------------------------------------------------------------------
-- Type BITMAPINFO
    bmiHeader       = w32allot( SIZEOF_BITMAPINFOHEADER ),
    bmiColors       = w32allot( {2, SIZEOF_RGBQUAD} ),
    SIZEOF_BITMAPINFO = w32allotted_size(),

-----------------------------------------------------------------------------
-- Type PALLETTEENTRY
    peBlue          = w32allot( Byte ),
    peGreen         = w32allot( Byte ),
    peRed           = w32allot( Byte ),
    peFlags         = w32allot( Byte ),
    SIZEOF_PALETTEENTRY  = w32allotted_size(),

-----------------------------------------------------------------------------
-- Type LOGPALETTE
    palVersion      = w32allot( Word ),
    palNumEntries   = w32allot( Word ),
    palPalEntr      = w32allot( {2, SIZEOF_PALETTEENTRY} ),
    SIZEOF_LOGPALETTE = w32allotted_size(),

-----------------------------------------------------------------------------

-----------------------------------------------------------------------------
-- Type COLORDLG
  COLORDLG_lStructSize     = w32allot(DWord),
  COLORDLG_hwndOwner       = w32allot(Long),
  COLORDLG_hInstance       = w32allot(Long),
  COLORDLG_rgbResult       = w32allot(Long),
  COLORDLG_lpCustColors    = w32allot(Long),
  COLORDLG_Flags           = w32allot(DWord),
  COLORDLG_lCustData       = w32allot(Long),
  COLORDLG_lpfnHook        = w32allot(Long),
  COLORDLG_lpTemplateName  = w32allot(Lpsz),
  SIZEOF_COLORDLG          = w32allotted_size(),


-----------------------------------------------------------------------------
-- Type SCROLLINFO
    sifSize                 = w32allot( Long ),
    sifMask                 = w32allot( Long ),
    sifMin                  = w32allot( Long ),
    sifMax                  = w32allot( Long ),
    sifPage                 = w32allot( Long ),
    sifPos                  = w32allot( Long ),
    sifTrackPos             = w32allot( Long ),
    SIZEOF_SCROLLINFO       = w32allotted_size(),



-----------------------------------------------------------------------------
    --?? pRINTDLG_hDevNames              = w32allot( UInt ),
    --?? pRINTDLG_hPrintTemplate         = w32allot( UInt ),
    --?? pRINTDLG_hSetupTemplate         = w32allot( UInt ),

-- Type PRINTDLG
    PRINTDLG_lStructSize            = w32allot( DWord ),
    PRINTDLG_hwndOwner              = w32allot( UInt ),
    PRINTDLG_hDevMode               = w32allot( Hndl ),
    PRINTDLG_pDevMode               = w32allotted_handle(PRINTDLG_hDevMode),
    PRINTDLG_hDevNames              = w32allot( Hndl ),
    PRINTDLG_pDevNames              = w32allotted_handle(PRINTDLG_hDevNames),
    PRINTDLG_hdc                    = w32allot( UInt ),
    PRINTDLG_flags                  = w32allot( DWord ),
    PRINTDLG_nFromPage              = w32allot( Word ),
    PRINTDLG_nToPage                = w32allot( Word ),
    PRINTDLG_nMinPage               = w32allot( Word ),
    PRINTDLG_nMaxPage               = w32allot( Word ),
    PRINTDLG_nCopies                = w32allot( Word ),
    PRINTDLG_hInstance              = w32allot( UInt ),
    PRINTDLG_lCustData              = w32allot( Long ),
    PRINTDLG_lpfnPrintHook          = w32allot( UInt ),
    PRINTDLG_lpfnSetupHook          = w32allot( UInt ),
    PRINTDLG_lpPrintTemplateName    = w32allot( UInt ),
    PRINTDLG_lpSetupTemplateName    = w32allot( UInt ),
    PRINTDLG_hPrintTemplate         = w32allot( Hndl ),
    PRINTDLG_pPrintTemplate         = w32allotted_handle(PRINTDLG_hPrintTemplate),
    PRINTDLG_hSetupTemplate         = w32allot( Hndl ),
    PRINTDLG_pSetupTemplate         = w32allotted_handle(PRINTDLG_hSetupTemplate),
    SIZEOF_PRINTDLG                 = w32allotted_size(),

-- DEVMODE structure
    DEVMODE_dmDeviceName            = w32allot( {32,Byte} ),   -- bchar[32]
    DEVMODE_dmSpecVersion           = w32allot( Word ),        -- word
    DEVMODE_dmDriverVersion         = w32allot( Word ),        -- word
    DEVMODE_dmSize                  = w32allot( Word ),        -- word
    DEVMODE_dmDriverExtra           = w32allot( Word ),        -- word
    DEVMODE_dmFields                = w32allot( Long ),        -- dword
    DEVMODE_dmOrientation           = w32allot( Word ),        -- short
    DEVMODE_dmPaperSize             = w32allot( Word ),        -- short
    DEVMODE_dmPaperLength           = w32allot( Word ),        -- short
    DEVMODE_dmPaperWidth            = w32allot( Word ),        -- short
    DEVMODE_dmScale                 = w32allot( Word ),        -- short
    DEVMODE_dmCopies                = w32allot( Word ),        -- short
    DEVMODE_dmDefaultSource         = w32allot( Word ),        -- short
    DEVMODE_dmPrintQuality          = w32allot( Word ),        -- short
    DEVMODE_dmColor                 = w32allot( Word ),        -- short
    DEVMODE_dmDuplex                = w32allot( Word ),        -- short
    DEVMODE_dmYResolution           = w32allot( Word ),        -- short
    DEVMODE_dmTTOption              = w32allot( Word ),        -- short
    DEVMODE_dmCollate               = w32allot( Word ),        -- short
    DEVMODE_dmFormName              = w32allot( {32,Byte} ),   -- byte[32]
    DEVMODE_dmLogPixels             = w32allot( Word ),        -- word
    DEVMODE_dmBitsPerPel            = w32allot( Long ),        -- dword
    DEVMODE_dmPelsWidth             = w32allot( Long ),        -- dword
    DEVMODE_dmPelsHeight            = w32allot( Long ),        -- dword
    DEVMODE_dmDisplayFlags          = w32allot( Long ),        -- dword
    DEVMODE_dmDisplayFrequency      = w32allot( Long ),        -- dword
    SIZEOF_DEVMODE                  = w32allotted_size(),

--
-- Flags in dmFields determine what has/has not been initialised
    DM_ORIENTATION      = #00001,
    DM_PAPERSIZE        = #00002,
    DM_PAPERLENGTH      = #00004,
    DM_PAPERWIDTH       = #00008,
    DM_SCALE            = #00010,
    DM_COPIES           = #00100,
    DM_DEFAULTSOURCE    = #00200,
    DM_PRINTQUALITY     = #00400,
    DM_COLOR            = #00800,
    DM_DUPLEX           = #01000,
    DM_YRESOLUTION      = #02000,
    DM_TTOPTION         = #04000,
    DM_COLLATE          = #08000,
    DM_FORMNAME         = #10000,
    DM_SPECVERSION      = #00400,
--
---- paper orientation
--
    DMORIENT_PORTRAIT   = 1,
    DMORIENT_LANDSCAPE  = 2,


-----------------------------------------------------------------------------
-- Type DOCINFO
    DOCINFO_cbSize                  = w32allot( Long ),
    DOCINFO_lpszDocName             = w32allot( Lpsz ),
    DOCINFO_lpszOutput              = w32allot( Lpsz ),
    DOCINFO_lpszDatatype            = w32allot( Lpsz ),
    DOCINFO_fwType                  = w32allot( DWord ),
    SIZEOF_DOCINFO                  = w32allotted_size(),

-----------------------------------------------------------------------------
-- Type TC_ITEM
    TC_ITEM_mask                    = w32allot( UInt ),
    TC_ITEM_lpReserved1             = w32allot( UInt ),
    TC_ITEM_lpReserved2             = w32allot( UInt ),
    TC_ITEM_pszText                 = w32allot( Lpsz ),
    TC_ITEM_cchTextMax              = w32allot( UInt ),
    TC_ITEM_iImage                  = w32allot( UInt ),
    TC_ITEM_lParam                  = w32allot( Long ),
    SIZEOF_TC_ITEM                  = w32allotted_size(),


-----------------------------------------------------------------------------
-- type CHOOSEFONT
    CF_lStructSize      = w32allot( DWord ),
    CF_hwndOwner        = w32allot( Ptr ),
    CF_hDC              = w32allot( Ptr ),
    CF_hLogFont         = w32allot( Ptr ),
    CF_iPointSize       = w32allot( Long ),
    CF_Flags            = w32allot( DWord ),
    CF_rgbColors        = w32allot( DWord ),
    CF_lCustData        = w32allot( Long ),
    CF_lpfnHook         = w32allot( Ptr ),
    CF_lpTemplateName   = w32allot( Ptr ),
    CF_hInstance        = w32allot( Ptr ),
    CF_lpszStyle        = w32allot( Lpsz ),
    CF_nFontType        = w32allot( Word ),
    CF_FillerAlign      = w32allot( Word ),
    CF_nSizeMin         = w32allot( Long ),
    CF_nSizeMax         = w32allot( Long ),
    SIZEOF_CHOOSEFONT   = w32allotted_size(),

-----------------------------------------------------------------------------
-- type NMHDR
    NMHDR_hwndFrom                  = w32allot( UInt ),
    NMHDR_idFrom                    = w32allot( Long ),
    NMHDR_code                      = w32allot( Long ),
    SIZEOF_NMHDR                    = w32allotted_size(),


-----------------------------------------------------------------------------
-----------------------------------------------------------------------------
--  Device Parameters for xGetDeviceCaps()
    DRIVERVERSION = 0,      --  Device driver version
    TECHNOLOGY = 2,         --  Device classification
    HORZSIZE = 4,           --  Horizontal size in millimeters
    VERTSIZE = 6,           --  Vertical size in millimeters
    HORZRES = 8,            --  Horizontal width in pixels
    VERTRES = 10,           --  Vertical width in pixels
    BITSPIXEL = 12,         --  Number of bits per pixel
    PLANES = 14,            --  Number of planes
    NUMBRUSHES = 16,        --  Number of brushes the device has
    NUMPENS = 18,           --  Number of pens the device has
    NUMMARKERS = 20,        --  Number of markers the device has
    NUMFONTS = 22,          --  Number of fonts the device has
    NUMCOLORS = 24,         --  Number of colors the device supports
    PDEVICESIZE = 26,       --  Size required for device descriptor
    CURVECAPS = 28,         --  Curve capabilities
    LINECAPS = 30,          --  Line capabilities
    POLYGONALCAPS = 32,     --  Polygonal capabilities
    TEXTCAPS = 34,          --  Text capabilities
    CLIPCAPS = 36,          --  Clipping capabilities
    RASTERCAPS = 38,        --  Bitblt capabilities
    ASPECTX = 40,           --  Length of the X leg
    ASPECTY = 42,           --  Length of the Y leg
    ASPECTXY = 44,          --  Length of the hypotenuse

    LOGPIXELSX = 88,        --  Logical pixels/inch in X
    LOGPIXELSY = 90,        --  Logical pixels/inch in Y

    SIZEPALETTE = 104,      --  Number of entries in physical palette
    NUMRESERVED = 106,      --  Number of reserved entries in palette
    COLORRES = 108,         --  Actual color resolution

--  Printing related DeviceCaps. These replace the appropriate Escapes
    PHYSICALWIDTH = 110, --  Physical Width in device units
    PHYSICALHEIGHT = 111, --  Physical Height in device units
    PHYSICALOFFSETX = 112, --  Physical Printable Area x margin
    PHYSICALOFFSETY = 113, --  Physical Printable Area y margin
    SCALINGFACTORX = 114, --  Scaling factor x
    SCALINGFACTORY = 115  --  Scaling factor y

-----------------------------------------------------------------------------

global constant
    OUT_DEFAULT_PRECIS    =      0,
    OUT_STRING_PRECIS     =      1,
    OUT_CHARACTER_PRECIS  =      2,
    OUT_STROKE_PRECIS     =      3,
    OUT_TT_PRECIS         =      4,
    OUT_DEVICE_PRECIS     =      5,
    OUT_RASTER_PRECIS     =      6,
    OUT_TT_ONLY_PRECIS    =      7,
    OUT_OUTLINE_PRECIS    =      8,
    OUT_SCREEN_OUTLINE_PRECIS =  9,
    OUT_PS_ONLY_PRECIS      =    10,

    CLIP_DEFAULT_PRECIS   =  0,
    CLIP_CHARACTER_PRECIS =  1,
    CLIP_STROKE_PRECIS    =  2,
    CLIP_MASK             =  15,
    CLIP_LH_ANGLES        =  #10000,
    CLIP_TT_ALWAYS        =  #20000,
    CLIP_EMBEDDED         =  #80000,

    DEFAULT_QUALITY       =  0,
    DRAFT_QUALITY         =  1,
    PROOF_QUALITY         =  2,
    NONANTIALIASED_QUALITY = 3,
    ANTIALIASED_QUALITY    = 4,

    DEFAULT_PITCH          = 0,
    FIXED_PITCH            = 1,
    VARIABLE_PITCH         = 2,
    MONO_FONT              = 8,

    ANSI_CHARSET           = 0,
    DEFAULT_CHARSET        = 1,
    SYMBOL_CHARSET         = 2,
    SHIFTJIS_CHARSET       = 128,
    HANGEUL_CHARSET        = 129,
    HANGUL_CHARSET         = 129,
    GB2312_CHARSET         = 134,
    CHINESEBIG5_CHARSET    = 136,
    OEM_CHARSET            = 255,
    JOHAB_CHARSET          = 130,
    HEBREW_CHARSET         = 177,
    ARABIC_CHARSET         = 178,
    GREEK_CHARSET          = 161,
    TURKISH_CHARSET        = 162,
    VIETNAMESE_CHARSET     = 163,
    THAI_CHARSET           = 222,
    EASTEUROPE_CHARSET     = 238,
    RUSSIAN_CHARSET        = 204,

    MAC_CHARSET            = 77,
    BALTIC_CHARSET         = 186,

    FS_LATIN1              = #00000001,
    FS_LATIN2              = #00000002,
    FS_CYRILLIC            = #00000004,
    FS_GREEK               = #00000008,
    FS_TURKISH             = #00000010,
    FS_HEBREW              = #00000020,
    FS_ARABIC              = #00000040,
    FS_BALTIC              = #00000080,
    FS_VIETNAMESE          = #00000100,
    FS_THAI                = #00010000,
    FS_JISJAPAN            = #00020000,
    FS_CHINESESIMP         = #00040000,
    FS_WANSUNG             = #00080000,
    FS_CHINESETRAD         = #00100000,
    FS_JOHAB               = #00200000,
    FS_SYMBOL              = #80000000,

    -- Font Families
    FF_DONTCARE       =  #00000, --  /* Don't care or don't know. */
    FF_ROMAN          =  #10000, -- /* Variable stroke width, serifed. */
                                 --       /* Times Roman, Century Schoolbook, etc. */
    FF_SWISS          =  #20000, -- /* Variable stroke width, sans-serifed. */
                                 --       /* Helvetica, Swiss, etc. */
    FF_MODERN         =  #30000, -- /* Constant stroke width, serifed or sans-serifed. */
                                 --       /* Pica, Elite, Courier, etc. */
    FF_SCRIPT         =  #40000, -- /* Cursive, etc. */
    FF_DECORATIVE     =  #50000, -- /* Old English, etc. */

-- Class styles
    CS_VREDRAW = #1,
    CS_HREDRAW = #2,
    CS_KEYCVTWINDOW = #4,
    CS_DBLCLKS = #8,
    CS_OWNDC = #20,
    CS_CLASSDC = #40,
    CS_PARENTDC = #80,
    CS_NOKEYCVT = #100,
    CS_NOCLOSE = #200,
    CS_SAVEBITS = #800,
    CS_BYTEALIGNCLIENT = #1000,
    CS_BYTEALIGNWINDOW = #2000,
    CS_PUBLICCLASS = #4000,

-- ShowWindow() Commands
    SW_HIDE = 0,
    SW_SHOWNORMAL = 1,
    SW_NORMAL = 1,
    SW_SHOWMINIMIZED = 2,
    SW_SHOWMAXIMIZED = 3,
    SW_MAXIMIZE = 3,
    SW_SHOWNOACTIVATE = 4,
    SW_SHOW = 5,
    SW_MINIMIZE = 6,
    SW_SHOWMINNOACTIVE = 7,
    SW_SHOWNA = 8,
    SW_RESTORE = 9,
    SW_SHOWDEFAULT = 10,
    SW_MAX = 10,
    w32FullScreen = "fullscreen",

-- PeekMessage options
    PM_NOREMOVE =  0,
    PM_REMOVE   =  1,
    PM_NOYIELD  =  2,

-- Window Messages
    WM_NULL     = #0,
    WM_CREATE   = #1,
    WM_DESTROY  = #2,
    WM_MOVE     = #3,
    WM_SIZE     = #5,

    WM_ACTIVATE = #6,
--
--  WM_ACTIVATE state values

    WA_INACTIVE = 0,
    WA_ACTIVE = 1,
    WA_CLICKACTIVE = 2,

    WM_SETFOCUS         = #7,
    WM_KILLFOCUS        = #8,
    WM_ENABLE           = #A,
    WM_SETREDRAW        = #B,
    WM_SETTEXT          = #C,
    WM_GETTEXT          = #D,
    WM_GETTEXTLENGTH    = #E,
    WM_PAINT            = #F,
    WM_CLOSE            = #10,
    WM_QUERYENDSESSION  = #11,
    WM_QUIT             = #12,
    WM_QUERYOPEN        = #13,
    WM_ERASEBKGND       = #14,
    WM_SYSCOLORCHANGE   = #15,
    WM_ENDSESSION       = #16,
    WM_SHOWWINDOW       = #18,
    WM_WININICHANGE     = #1A,
    WM_DEVMODECHANGE    = #1B,
    WM_ACTIVATEAPP      = #1C,
    WM_FONTCHANGE       = #1D,
    WM_TIMECHANGE       = #1E,
    WM_CANCELMODE       = #1F,
    WM_SETCURSOR        = #20,
    WM_MOUSEACTIVATE    = #21,
    WM_CHILDACTIVATE    = #22,
    WM_QUEUESYNC        = #23,
    WM_GETMINMAXINFO    = #24,
    -- setting fonts in controls
    WM_SETFONT          = #30,
    WM_GETFONT          = #31,

    WM_NOTIFY           = #4E,
    WM_SETICON          = #80,
    -- non-client messages
    WM_NCCREATE         = #81,
    WM_NCDESTROY        = #82,
    WM_NCCALCSIZE       = #83,
    WM_NCHITTEST        = #84,
    WM_NCPAINT          = #85,
    WM_NCACTIVATE       = #86,
    WM_GETDLGCODE       = #87,
    WM_SYNCPAINT        = #88,
    WM_NCMOUSEMOVE      = #A0,
    WM_NCLBUTTONDOWN    = #A1,
    WM_NCLBUTTONUP      = #A2,
    WM_NCLBUTTONDBLCLK  = #A3,
    WM_NCRBUTTONDOWN    = #A4,
    WM_NCRBUTTONUP      = #A5,
    WM_NCRBUTTONDBLCLK  = #A6,
    WM_NCMBUTTONDOWN    = #A7,
    WM_NCMBUTTONUP      = #A8,
    WM_NCMBUTTONDBLCLK  = #A9,
    WM_NCXBUTTONDOWN    = #AB,
    WM_NCXBUTTONUP      = #AC,
    WM_NCXBUTTONDBLCLK  = #AD,

    WM_SYSTIMER         = #118,  -- 280

    WM_PARENTNOTIFY     = #210,
    WM_DROPFILES        = #233,

-- MDI messages

    WM_MDICREATE        = #220,
    WM_MDIDESTROY       = #221,
    WM_MDIACTIVATE      = #222,
    WM_MDIRESTORE       = #223,
    WM_MDINEXT          = #224,
    WM_MDIMAXIMIZE      = #225,
    WM_MDITILE          = #226,
    WM_MDICASCADE       = #227,
    WM_MDIICONARANGE    = #228,
    WM_MDIGETACTIVE     = #229,
    WM_MDISETMENU       = #230,
    WM_ENTERSIZEMOVE    = #231,
    WM_EXITSIZEMOVE     = #232,
    WM_MDIREFRSHMENU    = #234,
    -- mouse events
    WM_MOUSEMOVE        = #200, -- mouse moved
    WM_LBUTTONDOWN      = #201, -- (513) mouse button down
    WM_LBUTTONUP        = #202, -- left button released
    WM_LBUTTONDBLCLK    = #203, -- (515) mouse button double clicked
    WM_RBUTTONDOWN      = #204, -- right button down
    WM_RBUTTONUP        = #205, -- right button released
    WM_RBUTTONDBLCLK    = #206, -- mouse right button double clicked
    WM_MBUTTONDOWN      = #207, -- middle button down
    WM_MBUTTONUP        = #208, -- middle button released
    WM_MBUTTONDBLCLK    = #209, -- middle button double click
    WM_MOUSEWHEEL       = #20A, -- mouse wheel moved
    WM_XBUTTONDOWN      = #20B,
    WM_XBUTTONUP        = #20C,
    WM_XBUTTONDBLCLK    = #20D,

    NM_FIRST      = #0,
    NM_OUTOFMEMORY    =     (NM_FIRST-1),
    NM_CLICK          =     (NM_FIRST-2),    -- uses NMCLICK struct
    NM_DBLCLK         =     (NM_FIRST-3),
    NM_RETURN         =     (NM_FIRST-4),
    NM_RCLICK         =     (NM_FIRST-5),    -- uses NMCLICK struct
    NM_RDBLCLK        =     (NM_FIRST-6),
    NM_SETFOCUS       =     (NM_FIRST-7),
    NM_KILLFOCUS      =     (NM_FIRST-8),
    NM_CUSTOMDRAW     =     (NM_FIRST-12),
    NM_HOVER          =     (NM_FIRST-13),
    NM_NCHITTEST      =     (NM_FIRST-14),   -- uses NMMOUSE struct
    NM_KEYDOWN        =     (NM_FIRST-15),   -- uses NMKEY struct
    NM_RELEASEDCAPTURE=     (NM_FIRST-16),
    NM_SETCURSOR      =     (NM_FIRST-17),   -- uses NMMOUSE struct
    NM_CHAR           =     (NM_FIRST-18),   -- uses NMCHAR struct
    NM_TOOLTIPSCREATED=     (NM_FIRST-19),   -- notify of when the tooltips window is create
    NM_LDOWN          =     (NM_FIRST-20),
    NM_RDOWN          =     (NM_FIRST-21),



    SND_SYNC        = #00000000, -- play synchronously (default)
    SND_ASYNC       = #00000001,
    SND_NODEFAULT   = #00000002, -- silence (!default) if sound not found
    SND_MEMORY      = #00000004, -- pszSound points to a memory file
    SND_LOOP        = #00000008, -- loop the sound until next sndPlaySound
    SND_NOSTOP      = #00000010, -- don't start if anything is currently playing
    SND_PURGE       = #00000040,  -- purge non-static events for task
    SND_APPLICATION = #00000080,-- look for application specific association
    SND_NOWAIT      = #00002000,-- don't wait if the driver is busy
    SND_ALIAS       = #00010000,-- name is a registry alias
    SND_FILENAME    = #00020000,
    SND_RESOURCE    = #00040004,-- name is resource name or atom
    SND_ALIAS_ID    = #00110000,-- alias is a predefined ID

    SND_ALIAS_SYSTEMASTERISK        = 'S' + 256 * '*',
    SND_ALIAS_SYSTEMQUESTION        = 'S' + 256 * '?',
    SND_ALIAS_SYSTEMHAND            = 'S' + 256 * 'H',
    SND_ALIAS_SYSTEMEXIT            = 'S' + 256 * 'E',
    SND_ALIAS_SYSTEMSTART           = 'S' + 256 * 'S',
    SND_ALIAS_SYSTEMWELCOME         = 'S' + 256 * 'W',
    SND_ALIAS_SYSTEMEXCLAMATION     = 'S' + 256 * '!',
    SND_ALIAS_SYSTEMDEFAULT         = 'S' + 256 * 'D',


-- Window Styles
    WS_OVERLAPPED   = #0,
    WS_POPUP        = #80000000,
    WS_CHILD        = #40000000,
    WS_MINIMIZE     = #20000000,
    WS_VISIBLE      = #10000000,
    WS_DISABLED     = #08000000,
    WS_CLIPPINGCHILD= #44000000,
    WS_CLIPSIBLINGS = #04000000,
    WS_CLIPCHILDREN = #02000000,
    WS_MAXIMIZE     = #01000000,
    WS_CAPTION      = #00C00000,      --  WS_BORDER Or WS_DLGFRAME
    WS_BORDER       = #00800000,      -- creates border on window
    WS_DLGFRAME     = #00400000,
    WS_HSCROLL      = #00100000,    -- horizontal scroll bar
    WS_VSCROLL      = #00200000,    -- vertical scroll bar
    WS_SYSMENU      = #00080000,
    WS_THICKFRAME   = #00040000,
    WS_GROUP        = #00020000,
    WS_TABSTOP      = #00010000,   -- use tab stop
    WS_SCROLLBARS   = #00300000,    -- set both vertical and horizontal scrollbars
    WS_MINIMIZEBOX  = #00020000,
    WS_MAXIMIZEBOX  = #00010000,

    WS_NO_RESIZE = {WS_CAPTION,WS_SYSMENU}, --> Win32lib special.
    WS_TILED = WS_OVERLAPPED,
    WS_ICONIC = WS_MINIMIZE,
    WS_SIZEBOX = WS_THICKFRAME,
    WS_OVERLAPPEDWINDOW = w32or_all({  WS_BORDER,
	    	        WS_DLGFRAME,
	    	        WS_SYSMENU,
	    	        WS_THICKFRAME,
	    	        WS_MINIMIZEBOX,
	    	        WS_MAXIMIZEBOX}),


    WS_TILEDWINDOW = WS_OVERLAPPEDWINDOW,

--   Common Window Styles
    WS_POPUPWINDOW = w32or_all({WS_POPUP, WS_BORDER, WS_SYSMENU}),
    WS_CHILDWINDOW = WS_CHILD,

-- Extended styles
    WS_EX_ACCEPTFILES     = #00000010,
    WS_EX_APPWINDOW       = #00040000,
    WS_EX_CLIENTEDGE      = #00000200,
    WS_EX_CONTEXTHELP     = #00000400,
    WS_EX_CONTROLPARENT   = #00010000,
    WS_EX_DLGMODALFRAME   = #00000001,
    WS_EX_LEFT            = #00000000,
    WS_EX_LEFTSCROLLBAR   = #00004000,
    WS_EX_LTRREADING      = #00000000,
    WS_EX_MDICHILD        = #00000040, --64,
    WS_EX_NOPARENTNOTIFY  = #00000004,
    WS_EX_OVERLAPPEDWINDOW =#00000300,
    WS_EX_PALETTEWINDOW   = #00000188,
    WS_EX_RIGHT           = #00001000,
    WS_EX_RIGHTSCROLLBAR  = #00000000,
    WS_EX_RTLREADING      = #00002000,
    WS_EX_STATICEDGE      = #00020000,
    WS_EX_TOOLWINDOW      = #00000080, --128,
    WS_EX_TOPMOST         = #00000008,
    WS_EX_TRANSPARENT     = #00000020, --32,
    WS_EX_WINDOWEDGE      = #00000100,
    WS_EX_LAYERED         = #00080000,
    WS_EX_NOINHERITLAYOUT = #00100000, -- Disable inheritence of mirroring by children
    WS_EX_LAYOUTRTL       = #00400000, --Right to left mirroring
    WS_EX_NOACTIVATE      = #08000000,

    BS_3STATE           = #0005,       -- tri-state button
    w32AUTOCLOSE        = 0&"autoclose", -- generates code to close the main window.
    BS_AUTO3STATE       = #0006,       -- tri-state button, windows toggles
    BS_AUTOCHECKBOX     = #0003,       -- checkbox, windows toggles
    BS_AUTORADIOBUTTON  = #0009,       -- radio button, windows toggles
    BS_BITMAP           = #0080,
    BS_BOTTOM           = #0800,
    BS_CENTER           = #0300,
    BS_CHECKBOX         = #0002,       -- checkbox
    BS_DEFPUSHBUTTON    = #0001,       -- default pushbutton (heavy border)
    BS_GROUPBOX         = #0007,       -- group box
    BS_ICON             = #0040,
    BS_LEFT             = #0100,
    BS_LEFTTEXT         = #020,
    BS_MULTILINE        = #2000,
    BS_NOTIFY           = #4000,
    BS_OWNERDRAW        = #000B,       -- owner drawn
    BS_PUSHBUTTON       = #0000,       -- pushbutton
    BS_PUSHLIKE         = #1000,
    BS_RADIOBUTTON      = #0004,       -- radio button
    BS_RIGHT            = #0200,
    BS_RIGHTBUTTON      = #0020,
    BS_TEXT             = #0000,
    BS_TOP              = #0400,
    BS_USERBUTTON       = #0008,
    BS_VCENTER          = #0C00,

    ES_LEFT             = #00000000,        -- left justified text
    ES_CENTER           = #00000001,        -- centered text
    ES_RIGHT            = #00000002,        -- right justified text
    ES_MULTILINE        = #00000004,        -- multiline edit
    ES_UPPERCASE        = #00000008,
    ES_LOWERCASE        = #00000010,
    ES_PASSWORD         = #00000020,
    ES_AUTOVSCROLL      = #00000040,        -- automatic vertical scroll
    ES_AUTOHSCROLL      = #00000080,        -- automatic horizontal scroll
    ES_AUTOSCROLL       = #000000C0,        -- both vertical and horizontal auto scroll
    ES_NOHIDESEL        = #00000100,
    --ES_DISABLENOSCROLL  = #00000200,     -- disable, rather than hide, unwanted scrollbars
    ES_OEMCONVERT       = #00000400,
    ES_READONLY         = #00000800,
    ES_WANTRETURN       = #00001000,
    ES_NUMBER           = #00002000,
    ES_NUMERIC          = ES_NUMBER,
    ES_SAVESEL          = #00008000,
    ES_SUNKEN           = #00004000,
    ES_DISABLENOSCROLL  = #00002000,


    LBS_NOTIFY            = #0001,-- notify parent on click or double click
    LBS_SORT              = #0002,-- sort strings in box alphabetically
    LBS_NOREDRAW          = #0004,
    LBS_MULTIPLESEL       = #0008,
    LBS_OWNERDRAWFIXED    = #0010,
    LBS_OWNERDRAWVARIABLE = #0020,
    LBS_HASSTRINGS        = #0040,
    LBS_USETABSTOPS       = #0080,
    LBS_NOINTEGRALHEIGHT  = #0100,
    LBS_MULTICOLUMN       = #0200,
    LBS_WANTKEYBOARDINPUT = #0400,
    LBS_EXTENDEDSEL       = #0800,
    LBS_DISABLENOSCROLL   = #1000,
    LBS_NODATA            = #2000,
    LBS_NOSEL             = #4000,
    LBS_STANDARD    = w32or_all( { LBS_NOTIFY, LBS_SORT, WS_VSCROLL, WS_BORDER} ),

    LB_ADDSTRING        = #180,     -- list box: add string
    LB_INSERTSTRING     = #181,     -- list box: insert string
    LB_DELETESTRING     = #182,     -- list box: delete string
    LB_SELITEMRANGEEX   = #183,
    LB_RESETCONTENT     = #184,     -- list box: reset list
    LB_GETTEXT          = #189,     -- list box: get text
    LB_GETTEXTLEN       = #18A,     -- list box: get length of text
    LB_GETCOUNT         = #18B,     -- list box: get length of list
    LB_GETCURSEL        = #188,     -- list box: get index of selected item
    LB_SETSEL           = #185,     -- list box: set index of multiple selected item
    LB_SETCURSEL        = #186,     -- list box: set index of selected item
    LB_GETSELCOUNT      = #190,
    LB_GETSELITEMS      = #191,
    LB_SETTABSTOPS      = #192,
    LB_SELITEMRANGE     = #19B,
    LB_SETHORIZONTALEXTENT = 404,

    LB_OKAY             = 0,
    LB_ERR              = -1,
    LB_ERRSPACE         = -2,

    GW_HWNDFIRST        = 0,
    GW_HWNDLAST         = 1,
    GW_HWNDNEXT         = 2,
    GW_HWNDPREV         = 3,
    GW_OWNER            = 4,
    GW_CHILD            = 5,
    GW_ENABLEDPOPUP     = 6,

    CB_OKAY             = 0,
    CB_ERR              = -1,
    CB_ERRSPACE         = -2,
    CB_GETEDITSEL       = #140,
    CB_LIMITTEXT        = #141,
    CB_SETEDITSEL       = #142,
    CB_ADDSTRING        = #143,     -- combo box: add string
    CB_DELETESTRING     = #144,     -- combo box: delete string
    CB_DIR              = #145,
    CB_GETCOUNT         = #146,     -- combo box: get list count
    CB_GETCURSEL        = #147,     -- combo box: return index of current item
    CB_GETLBTEXT        = #148,     -- combo box: get text
    CB_GETLBTEXTLEN     = #149,     -- combo box: get text length
    CB_INSERTSTRING     = #14A,     -- combo box: insert string
    CB_RESETCONTENT     = #14B,     -- combo box: erase list
    CB_FINDSTRING       = #14C,
    CB_SELECTSTRING     = #14D,
    CB_SETCURSEL        = #14E,     -- combo box: set index
    CB_SHOWDROPDOWN     = #14F,     -- combo box: open/close the 'list' part
    CB_GETITEMDATA      = #150,
    CB_SETITEMDATA      = #151,
    CB_GETDROPPEDCONTROLRECT =  #152,
    CB_SETITEMHEIGHT    = #153,
    CB_GETITEMHEIGHT    = #154,
    CB_SETEXTENDEDUI    = #155,
    CB_GETEXTENDEDUI    = #156,
    CB_GETDROPPEDSTATE  = #157,
    CB_FINDSTRINGEXACT  = #158,
    CB_SETLOCALE        = #159,
    CB_GETLOCALE        = #15A,
    CB_GETTOPINDEX      = #15B,
    CB_SETTOPINDEX      = #15C,
    CB_GETHORIZONTALEXTENT = #15D,
    CB_SETHORIZONTALEXTENT = #15E,
    CB_GETDROPPEDWIDTH  = #15F,
    CB_SETDROPPEDWIDTH  = #160,
    CB_INITSTORAGE      = #161,
    CB_MULTIPLEADDSTRING = #163,


-- Button Control Messages
    BM_CLICK        = 245,
    BM_GETCHECK     = 240,
    BM_GETIMAGE     = 246,
    BM_GETSTATE     = 242,
    BM_SETCHECK     = 241,
    BM_SETIMAGE     = 247,
    BM_SETSTATE     = 243,
    BM_SETSTYLE     = 244,

    BST_UNCHECKED      = #0000,
    BST_CHECKED        = #0001,
    BST_INDETERMINATE  = #0002,
    BST_PUSHED         = #0004,
    BST_FOCUS          = #0008

global constant
    CF_BITMAP     =  2,
    CF_DIB =  8,
    CF_PALETTE    =  9,
    CF_ENHMETAFILE =  14,
    CF_METAFILEPICT = 3,
    CF_OEMTEXT      = 7,
    CF_TEXT = 1,
    CF_UNICODETEXT  = 13,
    CF_DIF  = 5,
    CF_DSPBITMAP    = 130,
    CF_DSPENHMETAFILE       = 142,
    CF_DSPMETAFILEPICT      = 131,
    CF_DSPTEXT      = 129,
    CF_GDIOBJFIRST  = 768,
    CF_GDIOBJLAST   = 1023,
    CF_HDROP        = 15,
    CF_LOCALE       = 16,
    CF_OWNERDISPLAY = 128,
    CF_PENDATA      = 10,
    CF_PRIVATEFIRST = 512,
    CF_PRIVATELAST  = 767,
    CF_RIFF = 11,
    CF_SYLK = 4,
    CF_WAVE = 12,
    CF_TIFF = 6

global constant
    -- Trackbar Styles
    TBS_HORZ            = 0,
    TBS_VERT            = 2,
    TBS_AUTOTICKS       = 1,
    TBS_NOTICKS         = 16,
    TBS_TOP             = 4,
    TBS_BOTTOM          = 0,
    TBS_LEFT            = 4,
    TBS_RIGHT           = 0,
    TBS_BOTH            = 8,
    TBS_ENABLESELRANGE  = 32,
    TBS_FIXEDLENGTH     = 64,
    TBS_NOTHUMB         = 128,
    TB_BOTTOM           = 7,
    TB_ENDTRACK         = 8,
    TB_LINEDOWN         = 1,
    TB_LINEUP           = 0,
    TB_PAGEDOWN         = 3,
    TB_PAGEUP           = 2,
    TB_THUMBPOSITION    = 4,
    TB_THUMBTRACK       = 5,
    TB_TOP              = 6,
-- Track bar control
    TBM_CLEARSEL        = 1043,
    TBM_CLEARTICS       = 1033,
    TBM_GETCHANNELRECT  = 1050,
    TBM_GETLINESIZE     = 1048,
    TBM_GETNUMTICS      = 1040,
    TBM_GETPAGESIZE     = 1046,
    TBM_GETPOS          = 1024,
    TBM_GETPTICS        = 1038,
    TBM_GETRANGEMAX     = 1026,
    TBM_GETRANGEMIN     = 1025,
    TBM_GETSELEND       = 1042,
    TBM_GETSELSTART     = 1041,
    TBM_GETTHUMBLENGTH  = 1052,
    TBM_GETTHUMBRECT    = 1049,
    TBM_GETTIC          = 1027,
    TBM_GETTICPOS       = 1039,
    TBM_SETLINESIZE     = 1047,
    TBM_SETPAGESIZE     = 1045,
    TBM_SETPOS          = 1029,
    TBM_SETRANGE        = 1030,
    TBM_SETRANGEMAX     = 1032,
    TBM_SETRANGEMIN     = 1031,
    TBM_SETSEL          = 1034,
    TBM_SETSELEND       = 1036,
    TBM_SETSELSTART     = 1035,
    TBM_SETTHUMBLENGTH  = 1051,
    TBM_SETTIC          = 1028,
    TBM_SETTICFREQ      = 1044,

-- Tab control
    TCM_ADJUSTRECT      = 4904,
    TCM_DELETEALLITEMS  = 4873,
    TCM_DELETEITEM      = 4872,
    TCM_GETCURFOCUS     = 4911,
    TCM_GETCURSEL       = 4875,
    TCM_GETIMAGELIST    = 4866,
    TCM_GETITEMW        = 4924,
    TCM_INSERTITEMW     = 4926,
    TCM_SETITEMW        = 4925,
    TCM_GETITEMA        = 4869,
    TCM_INSERTITEMA     = 4871,
    TCM_SETITEMA        = 4870,
    TCM_GETITEM         = TCM_GETITEMA,
    TCM_INSERTITEM      = TCM_INSERTITEMA,
    TCM_SETITEM         = TCM_SETITEMA,
    TCM_GETITEMCOUNT    = 4868,
    TCM_GETITEMRECT     = 4874,
    TCM_GETROWCOUNT     = 4908,
    TCM_GETTOOLTIPS     = 4909,
    TCM_HITTEST         = 4877,
    TCM_REMOVEIMAGE     = 4906,
    TCM_SETCURFOCUS     = 4912,
    TCM_SETCURSEL       = 4876,
    TCM_SETIMAGELIST    = 4867,
    TCM_SETITEMEXTRA    = 4878,
    TCM_SETITEMSIZE     = 4905,
    TCM_SETPADDING      = 4907,
    TCM_SETTOOLTIPS     = 4910,

    TCHITTESTINFO_ptX       = w32allot( Long ),
    TCHITTESTINFO_ptY       = w32allot( Long ),
    TCHITTESTINFO_flags     = w32allot( UInt ),
    SIZEOF_TCHITTESTINFO    = w32allotted_size(),

    -- Tab control notifications
    TCN_KEYDOWN         = -550,
    TCN_SELCHANGE       = -551,
    TCN_SELCHANGING     = -552,


    -- TC_ITEM structure
    TCIF_TEXT           = 1,            -- display text on tabs
    TCIF_IMAGE          = 2,            -- display images on tabs
    TCIF_PARAM          = 8,
    TCIF_RTLREADING     = 4,

    -- progress bar styles
    PBS_SMOOTH          = 1,
    PBS_VERTICAL        = 4,
    -- progress bar messages
    PBM_SETRANGE    = WM_USER + 1,      -- set min/max
    PBM_SETPOS      = WM_USER + 2,      -- set position
    PBM_DELTAPOS    = WM_USER + 3,      -- change by requested increment
    PBM_SETSTEP     = WM_USER + 4,      -- set step size
    PBM_STEPIT      = WM_USER + 5,      -- step ahead by 1 step
    PBM_SETRANGE32  = WM_USER + 6,      -- range is double length word
    PBM_GETRANGE    = WM_USER + 7,      -- get range
    PBM_GETPOS      = WM_USER + 8,      -- get position

    -- key commands
    WM_KEYDOWN      = #100,         -- key pressed
    WM_KEYUP        = #101,
    WM_CHAR         = #102,

    -- system key commands
    WM_SYSCHAR      = 262,
    WM_SYSDEADCHAR  = 263,
    WM_SYSKEYDOWN   = 260,
    WM_SYSKEYUP     = 261,



    GWL_WndProc     = -4,           -- GetWindowLong: ptr to function

-- Menu flags for Add/Check/EnableMenuItem()
    MF_INSERT = #0,
    MF_CHANGE = #80,
    MF_APPEND = #100,
    MF_DELETE = #200,
    MF_REMOVE = #1000,

    MF_BYCOMMAND = #0,              -- specifies parameter type
    MF_BYPOSITION = #400,           -- specifies parameter type

    MF_SEPARATOR = #800,            -- menu format: seperator

    MF_ENABLED = #0,                -- menu format: enabled
    MF_GRAYED = #1,                 -- menu format: grayed
    MF_DISABLED = #2,               -- menu format: disabled

    MF_UNCHECKED = #0,              -- menu format: unchecked
    MF_CHECKED = #8,                -- menu format: checked
    MF_USECHECKBITMAPS = #200,      -- menu format: use check bitmaps

    MF_STRING = #0,                 -- menu format: display string
    MF_BITMAP = #4,                 -- menu format: display bitmap
    MF_OWNERDRAW = #100,            -- menu format: owner drawn

    MF_POPUP = #10,                 -- menu format: popup style
    MF_MENUBARBREAK = #20,          -- menu format: menu bar break style
    MF_MENUBREAK = #40,             -- menu format: menu break style

    MF_UNHILITE = #0,
    MF_HILITE = #80,

    MF_SYSMENU = #2000,
    MF_HELP = #4000,
    MF_MOUSESELECT = #8000,
    MF_DEFAULT     =   #00001000,

    MF_RIGHTJUSTIFY =  #00004000,

    MFS_GRAYED      =   #00000003,
    MFS_DISABLED    =   MFS_GRAYED,
    MFS_CHECKED     =   MF_CHECKED,
    MFS_HILITE      =   MF_HILITE,
    MFS_ENABLED     =   MF_ENABLED,
    MFS_UNCHECKED   =   MF_UNCHECKED,
    MFS_UNHILITE    =   MF_UNHILITE,
    MFS_DEFAULT     =   MF_DEFAULT,

    MFT_STRING        = MF_STRING,
    MFT_BITMAP        = MF_BITMAP,
    MFT_MENUBARBREAK  = MF_MENUBARBREAK,
    MFT_MENUBREAK     = MF_MENUBREAK,
    MFT_OWNERDRAW     = MF_OWNERDRAW,
    MFT_RADIOCHECK    = #00000200,
    MFT_SEPARATOR     = MF_SEPARATOR,
    MFT_RIGHTORDER    = #00002000,
    MFT_RIGHTJUSTIFY  = MF_RIGHTJUSTIFY,

    -- NOTIFICATIONS (events)

    -- Button Control Notification Codes
    BN_CLICKED          = 0,
    BN_DBLCLK           = 5,
    BN_DISABLE          = 4,
    BN_DOUBLECLICKED    = 5,
    BN_HILITE           = 2,
    BN_KILLFOCUS        = 7,
    BN_PAINT            = 1,
    BN_PUSHED           = 2,
    BN_SETFOCUS         = 6,
    BN_UNHILITE         = 3,
    BN_UNPUSHED         = 3,

    -- Edit Control Notification Codes
    EN_SETFOCUS     = #100,         -- get focus
    EN_KILLFOCUS    = #200,         -- lose focus
    EN_CHANGE       = #300,         -- change
    EN_UPDATE       = #400,         -- update
    EN_ERRSPACE     = #500,         -- out of memory
    EN_MAXTEXT      = #501,         -- more than allotted text
    EN_HSCROLL      = #601,         -- horizontal scroll
    EN_VSCROLL      = #602,         -- vertical scroll

    -- List Box Control Notification Codes
    LBN_ERRSPACE    = -2,     -- out of space
    LBN_SELCHANGE   = 1,        -- change selection
    LBN_DBLCLK      = 2,        -- double click
    LBN_SELCANCEL   = 3,        -- cancel selection
    LBN_SETFOCUS    = 4,        -- focus
    LBN_KILLFOCUS   = 5,        -- lose focus

    -- Combo Box Control Notification Codes
    CBN_ERRSPACE        = -1, -- out of space
    CBN_SELCHANGE       = 1,    -- change selection
    CBN_DBLCLK          = 2,    -- double click
    CBN_SETFOCUS        = 3,    -- set focus
    CBN_KILLFOCUS       = 4,    -- lose focus
    CBN_EDITCHANGE      = 5,    -- change data
    CBN_EDITUPDATE      = 6,    -- update data
    CBN_DROPDOWN        = 7,    -- dropdown
    CBN_CLOSEUP         = 8,    -- close dropdown
    CBN_SELENDOK        = 9,
    CBN_SELENDCANCEL    = 10,

    CBS_AUTOHSCROLL         = 64,
    CBS_DISABLENOSCROLL     = #800,
    CBS_DROPDOWN            = 2,
    CBS_DROPDOWNLIST        = 3,
    CBS_HASSTRINGS          = 512,
    CBS_LOWERCASE           = #4000,
    CBS_NOINTEGRALHEIGHT    = #400,
    CBS_OEMCONVERT          = 128,
    CBS_OWNERDRAWFIXED      = 16,
    CBS_OWNERDRAWVARIABLE   = 32,
    CBS_SIMPLE              = 1,
    CBS_SORT                = 256,
    CBS_UPPERCASE           = #2000,



    WM_COMMAND      = #0111,        -- window message command
    WM_MENUSELECT   = #011F,        -- menu item selected


    -- edit commands
    WM_CUT = #300,
    WM_COPY = #301,
    WM_PASTE = #302,
    WM_CLEAR = #303,
    WM_UNDO = #304,

    -- Edit Control Messages
    EM_GETSEL = #B0,        -- 2 long pointers
    EM_SETSEL = #B1,        -- pass start and end
--    EM_GETRECT = #B2,
--    EM_SETRECT = #B3,
--    EM_SETRECTNP = #B4,
    EM_SCROLL = #B5,
    EM_LINESCROLL = #B6,
    EM_SCROLLCARET = #B7,
    EM_GETMODIFY = #B8,
    EM_SETMODIFY = #B9,
    EM_GETLINECOUNT = #BA,
    EM_LINEINDEX = #BB,
    EM_SETHANDLE = #BC,
    EM_GETHANDLE = #BD,
    EM_GETTHUMB = #BE,
    EM_LINELENGTH = #C1,
    EM_REPLACESEL = #C2,
    EM_GETLINE = #C4,
    EM_LIMITTEXT = #C5,
    EM_CANUNDO = #C6,
    EM_UNDO = #C7,
    EM_FMTLINES = #C8,
    EM_LINEFROMCHAR = #C9,
    EM_SETTABSTOPS = #CB,
    EM_SETPASSWORDCHAR = #CC,
    EM_EMPTYUNDOBUFFER = #CD,
    EM_GETFIRSTVISIBLELINE = #CE,
    EM_SETREADONLY = #CF,
    EM_SETWORDBREAKPROC = #D0,
    EM_GETWORDBREAKPROC = #D1,
    EM_GETPASSWORDCHAR = #D2,

    EM_GETSELTEXT = 1086,
    EM_SETCHARFORMAT = 1092,
    EM_GETCHARFORMAT = 1082,
    EM_SETTEXTMODE = 1113,
    EM_GETTEXTMODE = 1114,
    EM_GETTEXTEX  = WM_USER + 94,
    EM_GETTEXTLENGTHEX =        WM_USER + 95,

    TM_PLAINTEXT                        = 1,
    TM_RICHTEXT                                = 2,
    TM_SINGLELEVELUNDO                = 4,
    TM_MULTILEVELUNDO                = 8,
    TM_SINGLECODEPAGE                = 16,
    TM_MULTICODEPAGE                = 32,

    SCF_WORD = 2,
    SCF_SELECTION = 1,
    SCF_ALL = 4,



-- Status Window
    SBT_OWNERDRAW           = #1000,
    SBT_NOBORDERS           = #0100,
    SBT_POPOUT              = #0200,
    SBT_RTLREADING          = #0400,
    SBT_TOOLTIPS            = #0800,

    SB_GETBORDERS           = 1031,
    SB_GETPARTS             = 1030,
    SB_GETRECT              = 1034,
    SB_GETTEXTW             = 1037,
    SB_GETTEXTLENGTHW       = 1036,
    SB_SETTEXTW             = 1035,
    SB_GETTEXTA             = 1026,
    SB_GETTEXTLENGTHA       = 1027,
    SB_SETTEXTA             = 1025,
    SB_GETTEXT              = SB_GETTEXTA,
    SB_GETTEXTLENGTH        = SB_GETTEXTLENGTHA,
    SB_SETTEXT              = SB_SETTEXTA,
    SB_SETMINHEIGHT         = 1032,
    SB_SETPARTS             = 1028,
    SB_SIMPLE               = 1033,
    SB_SETTIPTEXT           = WM_USER + 16,


    --  Graphics Modes (used by EZ_FONT)
    GM_ADVANCED = 2,

    -- Background Modes
    TRANSPARENT     = 1,        -- background is not touched
    OPAQUE          = 2,        -- background filled before drawing

    --  xform stuff
    MWT_IDENTITY    = 1,
    CW_USEDEFAULT   = #80000000,

    -- icons and pointers
    ICON_SMALL      = 0,
    ICON_BIG        = 1,

    IDC_ARROW       = 32512,
    IDC_IBEAM       = 32513,
    IDC_WAIT        = 32514,
    IDC_CROSS       = 32515,
    IDC_UPARROW     = 32516,
    IDC_ICON        = 32641,
    IDC_SIZENWSE    = 32642,
    IDC_SIZENESW    = 32643,
    IDC_SIZEWE      = 32644,
    IDC_SIZENS      = 32645,
    IDC_SIZEALL     = 32646,
    IDC_SIZE        = IDC_SIZEALL, -- 32640 is obsolete
    IDC_NO          = 32648,
    IDC_APPSTARTING = 32650,
    IDC_HELP        = 32651,
    IDI_APPLICATION = 32512,
    IDI_ERROR       = 32513,
    IDI_HAND        = IDI_ERROR,
    IDI_QUESTION    = 32514,
    IDI_EXCLAMATION = 32515,
    IDI_WARNING     = IDI_EXCLAMATION,
    IDI_ASTERISK    = 32516,
    IDI_INFORMATION = IDI_ASTERISK,
    IDI_WINLOGO     = 32517,
    WinIcons        = {IDI_APPLICATION, IDI_ERROR, IDI_QUESTION,
                       IDI_WARNING, IDI_ASTERISK, IDI_WINLOGO},

    -- Win32Lib's versions
    ArrowPointer        = IDC_ARROW,
    IBeamPointer        = IDC_IBEAM,
    WaitPointer         = IDC_WAIT,
    CrossPointer        = IDC_CROSS,
    UpArrowPointer      = IDC_UPARROW,
    SizeNWSEPointer     = IDC_SIZENWSE,
    SizeNESWPointer     = IDC_SIZENESW,
    SizeWEPointer       = IDC_SIZEWE,
    SizeNSPointer       = IDC_SIZENS,
    SizeAllPointer      = IDC_SIZEALL,
    NoPointer           = IDC_NO,
    AppStartingPointer  = IDC_APPSTARTING,
    HelpPointer         = IDC_HELP,
    ApplicationIcon     = IDI_APPLICATION,
    HandIcon            = IDI_HAND,
    QuestionIcon        = IDI_QUESTION,
    ExclamationIcon     = IDI_EXCLAMATION,
    AsteriskIcon        = IDI_ASTERISK,
    WinLogoIcon         = IDI_WINLOGO,
    SizePointer         = IDC_SIZEALL,
    IconPointer         = IDC_ICON

sequence vDragPointer vDragPointer = repeat(CrossPointer, 4)

global constant
-- GetSystemMetrics
    SM_CYMIN            = 29,
    SM_CXMIN            = 28,
    SM_ARRANGE          = 56,
    SM_CLEANBOOT        = 67,
    -- The right value for SM_CEMETRICS for NT 3.5 is 75.  For Windows 95
   -- and NT 4.0, it is 76.  The meaning is undocumented, anyhow.
    SM_CMETRICS         = 76,
    SM_CMOUSEBUTTONS    = 43,
    SM_CXBORDER         = 5,
    SM_CYBORDER         = 6,
    SM_CXCURSOR         = 13,
    SM_CYCURSOR         = 14,
    SM_CXDLGFRAME       = 7,
    SM_CYDLGFRAME       = 8,
    SM_CXDOUBLECLK      = 36,
    SM_CYDOUBLECLK      = 37,
    SM_CXDRAG           = 68,
    SM_CYDRAG           = 69,
    SM_CXEDGE           = 45,
    SM_CYEDGE           = 46,
    SM_CXFIXEDFRAME     = 7,
    SM_CYFIXEDFRAME     = 8,
    SM_CXFRAME          = 32,
    SM_CYFRAME          = 33,
    SM_CXFULLSCREEN     = 16,
    SM_CYFULLSCREEN     = 17,
    SM_CXHSCROLL        = 21,
    SM_CYHSCROLL        = 3,
    SM_CXHTHUMB         = 10,
    SM_CXICON           = 11,
    SM_CYICON           = 12,
    SM_CXICONSPACING    = 38,
    SM_CYICONSPACING    = 39,
    SM_CXMAXIMIZED      = 61,
    SM_CYMAXIMIZED      = 62,
    SM_CXMAXTRACK       = 59,
    SM_CYMAXTRACK       = 60,
    SM_CXMENUCHECK      = 71,
    SM_CYMENUCHECK      = 72,
    SM_CXMENUSIZE       = 54,
    SM_CYMENUSIZE       = 55,
    SM_CXMINIMIZED      = 57,
    SM_CYMINIMIZED      = 58,
    SM_CXMINSPACING     = 47,
    SM_CYMINSPACING     = 48,
    SM_CXMINTRACK       = 34,
    SM_CYMINTRACK       = 35,
    SM_CXSCREEN         = 0,
    SM_CYSCREEN         = 1,
    SM_CXSIZE           = 30,
    SM_CYSIZE           = 31,
    SM_CXSIZEFRAME      = 32,
    SM_CYSIZEFRAME      = 33,
    SM_CXSMICON         = 49,
    SM_CYSMICON         = 50,
    SM_CXSMSIZE         = 52,
    SM_CYSMSIZE         = 53,
    SM_CXVSCROLL        = 2,
    SM_CYVSCROLL        = 20,
    SM_CYVTHUMB         = 9,
    SM_CYCAPTION        = 4,
    SM_CYKANJIWINDOW    = 18,
    SM_CYMENU           = 15,
    SM_CYSMCAPTION      = 51,
    SM_DBCSENABLED      = 42,
    SM_DEBUG            = 22,
    SM_MENUDROPALIGNMENT= 40,
    SM_MIDEASTENABLED   = 74,
    SM_MOUSEPRESENT     = 19,
    SM_MOUSEWHEELPRESENT= 75,
    SM_NETWORK          = 63,
    SM_PENWINDOWS       = 41,
    SM_RESERVED1        = 24,
    SM_RESERVED2        = 25,
    SM_RESERVED3        = 26,
    SM_RESERVED4        = 27,
    SM_SECURE           = 44,
    SM_SHOWSOUNDS       = 70,
    SM_SLOWMACHINE      = 73,
    SM_SWAPBUTTON       = 23,
    ARW_BOTTOMLEFT      = 0,
    ARW_BOTTOMRIGHT     = #1,
    ARW_HIDE            = #8,
    ARW_TOPLEFT         = #2,
    ARW_TOPRIGHT        = #3,
    ARW_DOWN            = #4,
    ARW_LEFT            = 0,
    ARW_RIGHT           = 0,
    ARW_UP              = #4,

-- Stock Logical Objects
    WHITE_BRUSH = 0,
    LTGRAY_BRUSH = 1,
    GRAY_BRUSH = 2,
    DKGRAY_BRUSH = 3,
    BLACK_BRUSH = 4,
    NULL_BRUSH = 5,
    HOLLOW_BRUSH = NULL_BRUSH,
    WHITE_PEN = 6,
    BLACK_PEN = 7,
    NULL_PEN = 8,
    OEM_FIXED_FONT = 10,
    ANSI_FIXED_FONT = 11,
    ANSI_VAR_FONT = 12,
    SYSTEM_FONT = 13,
    DEVICE_DEFAULT_FONT = 14,
    DEFAULT_PALETTE = 15,
    SYSTEM_FIXED_FONT = 16,
    STOCK_LAST = 16,

    brush_white = w32Func( xGetStockObject, {WHITE_BRUSH}),
    brush_ltgray = w32Func( xGetStockObject, {LTGRAY_BRUSH}),
    brush_gray = w32Func( xGetStockObject, {GRAY_BRUSH}),
    brush_dkgray = w32Func( xGetStockObject, {DKGRAY_BRUSH}),
    brush_black = w32Func( xGetStockObject, {BLACK_BRUSH}),
    brush_null = w32Func( xGetStockObject, {NULL_BRUSH}),
    pen_white = w32Func( xGetStockObject, {WHITE_PEN}),
    pen_black = w32Func( xGetStockObject, {BLACK_PEN}),
    pen_null = w32Func( xGetStockObject, {NULL_PEN}),
    font_oem_fixed = w32Func( xGetStockObject, {OEM_FIXED_FONT}),
    font_ansi_fixed = w32Func( xGetStockObject, {ANSI_FIXED_FONT}),
    font_ansi_var = w32Func( xGetStockObject, {ANSI_VAR_FONT}),
    font_system = w32Func( xGetStockObject, {SYSTEM_FONT}),
    font_device_default = w32Func( xGetStockObject, {DEVICE_DEFAULT_FONT}),
    palette_default = w32Func( xGetStockObject, {DEFAULT_PALETTE}),
    font_system_fixed = w32Func( xGetStockObject, {SYSTEM_FIXED_FONT}),

--  Scroll bar messages
    SBM_SETPOS = #E0, -- not in win3.1
    SBM_GETPOS = #E1, -- not in win3.1
    SBM_SETRANGE = #E2, -- not in win3.1
    SBM_SETRANGEREDRAW = #E6, -- not in win3.1
    SBM_GETRANGE = #E3, -- not in win3.1
    SBM_ENABLE_ARROWS = #E4, -- not in win3.1

-- Scroll Bar Styles
    SBS_HORZ = #0,
    SBS_VERT = #1,
    SBS_TOPALIGN = #2,
    SBS_LEFTALIGN = #2,
    SBS_BOTTOMALIGN = #4,
    SBS_RIGHTALIGN = #4,
    SBS_SIZEBOXTOPLEFTALIGN = #2,
    SBS_SIZEBOXBOTTOMRIGHTALIGN = #4,
    SBS_SIZEBOX = #8,

    -- scroll bar events
    WM_HSCROLL = #114,
    WM_VSCROLL = #115,

-- Scroll Bar Constants
    SB_HORZ = 0,
    SB_VERT = 1,
    SB_CTL = 2,
    SB_BOTH = 3,

-- Scroll Bar Commands
    SB_UserDefined = -1,
    SB_LINEUP = 0,
    SB_LINELEFT = 0,
    SB_LINEDOWN = 1,
    SB_LINERIGHT = 1,
    SB_PAGEUP = 2,
    SB_PAGELEFT = 2,
    SB_PAGEDOWN = 3,
    SB_PAGERIGHT = 3,
    SB_THUMBPOSITION = 4,
    SB_THUMBTRACK = 5,
    SB_TOP = 6,
    SB_LEFT = 6,
    SB_BOTTOM = 7,
    SB_RIGHT = 7,
    SB_ENDSCROLL = 8,

-- scroll bar information flags
    SIF_DISABLENOSCROLL = #8,
    SIF_PAGE = #2,
    SIF_POS = #4,
    SIF_RANGE = #1,
    SIF_TRACKPOS = #10,
    SIF_ALL = w32or_all({SIF_RANGE,SIF_PAGE,SIF_POS,SIF_TRACKPOS}),

-- Color hooks - control about to be drawn
    WM_CTLCOLORMSGBOX = #132,
    WM_CTLCOLOREDIT = #133,
    WM_CTLCOLORLISTBOX = #134,
    WM_CTLCOLORBTN = #135,
    WM_CTLCOLORDLG = #136,
    WM_CTLCOLORSCROLLBAR = #137,
    WM_CTLCOLORSTATIC = #138,


-- MessageBox() Flags
--  these are found in Euphoria's MESSAGE.E file
--    MB_OK = #0,
--    MB_OKCANCEL = #1,
--    MB_ABORTRETRYIGNORE = #2,
--    MB_YESNOCANCEL = #3,
--    MB_YESNO = #4,
--    MB_RETRYCANCEL = #5,
--    MB_ICONHAND = #10,
--    MB_ICONQUESTION = #20,
--    MB_ICONEXCLAMATION = #30,
--    MB_ICONASTERISK = #40,
--    MB_ICONINFORMATION = MB_ICONASTERISK,
--    MB_ICONSTOP = MB_ICONHAND,
--    MB_DEFBUTTON1 = #0,
--    MB_DEFBUTTON2 = #100,
--    MB_DEFBUTTON3 = #200,
--    MB_APPLMODAL = #0,
--    MB_SYSTEMMODAL = #1000,
--    MB_TASKMODAL = #2000,

-- timer
    WM_TIMER = #113,

--  Ternary raster operations
    SRCCOPY = #CC0020, -- (DWORD) dest = source
    SRCPAINT = #EE0086,        -- (DWORD) dest = source OR dest
    SRCAND = #8800C6,  -- (DWORD) dest = source AND dest
    SRCINVERT = #660046,       -- (DWORD) dest = source XOR dest
    SRCERASE = #440328,        -- (DWORD) dest = source AND (NOT dest )
    NOTSRCCOPY = #330008,      -- (DWORD) dest = (NOT source)
    NOTSRCERASE = #1100A6,     -- (DWORD) dest = (NOT src) AND (NOT dest)
    MERGECOPY = #C000CA,       -- (DWORD) dest = (source AND pattern)
    MERGEPAINT = #BB0226,      -- (DWORD) dest = (NOT source) OR dest
    PATCOPY = #F00021, -- (DWORD) dest = pattern
    PATPAINT = #FB0A09,        -- (DWORD) dest = DPSnoo
    PATINVERT = #5A0049,       -- (DWORD) dest = pattern XOR dest
    DSTINVERT = #550009,       -- (DWORD) dest = (NOT dest)
    BLACKNESS = #42, -- (DWORD) dest = BLACK
    WHITENESS = #FF0062,       -- (DWORD) dest = WHITE

--  Ternary raster operations
    SrcCopy     = SRCCOPY,
    SrcPaint    = SRCPAINT,
    SrcAnd      = SRCAND,
    SrcInvert   = SRCINVERT,
    SrcErase    = SRCERASE,
    NotSrcCopy  = NOTSRCCOPY,
    NotSrcErase = NOTSRCERASE,
    MergeCopy   = MERGECOPY,
    MergePaint  = MERGEPAINT,
    PatCopy     = PATCOPY,
    PatPaint    = PATPAINT,
    PatInvert   = PATINVERT,
    DstInvert   = DSTINVERT,
    Blackness   = BLACKNESS,
    Whiteness   = WHITENESS,

-- Binary raster ops
    R2_BLACK = 1,           -- Pixel is always 0.
    R2_NOTMERGEPEN = 2,     -- Pixel is the inverse of the R2_MERGEPEN color.
    R2_MASKNOTPEN = 3,      -- combination common screen and inverse of pen.
    R2_NOTCOPYPEN = 4,      -- Pixel is the inverse of the pen color.
    R2_MASKPENNOT = 5,      -- combination common to pen and inverse of screen.
    R2_NOT = 6,             -- Pixel is the inverse of the screen color.
    R2_XORPEN = 7,          -- Pixel is the inverse of the R2_XORPEN color.
    R2_NOTMASKPEN = 8,      -- Pixel is the inverse of the R2_MASKPEN color.
    R2_MASKPEN = 9,         -- combination common to pen and the screen.
    R2_NOTXORPEN = 10,      -- combination of colors in pen and screen, but not in both.
    R2_NOP = 11,            -- Pixel remains unchanged.
    R2_MERGENOTPEN = 12,    -- combination of screen and inverse of pen.
    R2_COPYPEN = 13,        -- Pixel is the pen color.
    R2_MERGEPENNOT = 14,    -- combination of pen color and inverse of screen color.
    R2_MERGEPEN = 15,       -- combination of pen color and the screen color.
    R2_WHITE = 16,          -- Pixel is always 1.
    R2_LAST = 16,


    GDI_ERROR = #FFFF,
    HGDI_ERROR = #FFFF,

-- error with color
    CLR_INVALID = #FF000000,
    CLR_DEFAULT = #FF000000,
    CLR_NONE    = #FFFFFFFF,


-- Global Memory Flags
    GMEM_FIXED = #0,
    GMEM_MOVEABLE = #2,
    GMEM_NOCOMPACT = #10,
    GMEM_NODISCARD = #20,
    GMEM_ZEROINIT = #40,
    GMEM_MODIFY = #80,
    GMEM_DISCARDABLE = #100,
    GMEM_NOT_BANKED = #1000,
    GMEM_SHARE = #2000,
    GMEM_DDESHARE = #2000,
    GMEM_NOTIFY = #4000,
    GMEM_LOWER = GMEM_NOT_BANKED,
    GMEM_VALID_FLAGS = #7F72,
    GMEM_INVALID_HANDLE = #8000,
    GMEM_CLIPBOARD = w32or_all({GMEM_MOVEABLE,GMEM_DDESHARE}),

    GHND = w32or_all({GMEM_MOVEABLE, GMEM_ZEROINIT}),
    GPTR = w32or_all({GMEM_FIXED, GMEM_ZEROINIT}),


-- PRINTDLG structure
    PD_ALLPAGES                     = 0,
    PD_COLLATE                      = 16,
    PD_DISABLEPRINTTOFILE           = 524288,
    PD_ENABLEPRINTHOOK              = 4096,
    PD_ENABLEPRINTTEMPLATE          = 16384,
    PD_ENABLEPRINTTEMPLATEHANDLE    = 65536,
    PD_ENABLESETUPHOOK              = 8192,
    PD_ENABLESETUPTEMPLATE          = 32768,
    PD_ENABLESETUPTEMPLATEHANDLE    = 131072,
    PD_HIDEPRINTTOFILE              = 1048576,
    PD_NOPAGENUMS                   = 8,
    PD_NOSELECTION                  = 4,
    PD_NOWARNING                    = 128,
    PD_PAGENUMS                     = 2,
    PD_PRINTSETUP                   = 64,
    PD_PRINTTOFILE                  = 32,
    PD_RETURNDC                     = 256,
    PD_RETURNDEFAULT                = 1024,
    PD_RETURNIC                     = 512,
    PD_SELECTION                    = 1,
    PD_SHOWHELP                     = 2048,
    PD_USEDEVMODECOPIES             = 262144,
    PD_USEDEVMODECOPIESANDCOLLATE   = 262144,


-- DIB color table identifiers
    DIB_RGB_COLORS = 0,         --  color table in RGBs
    DIB_PAL_COLORS = 1,         --  color table in palette indices
    DIB_PAL_INDICES = 2,        --  No color table indices into surf palette
    DIB_PAL_PHYSINDICES = 2,    --  No color table indices into surf palette
    DIB_PAL_LOGINDICES = 4,     --  No color table indices into DC palette


-- Loading Bitmaps
    LR_LOADFROMFILE = 16,
    IMAGE_BITMAP = 0,
    IMAGE_ICON = 1,

    LR_COPYDELETEORG = 8,
    LR_COPYRETURNORG = 4,
    LR_MONOCHROME = 1,
    LR_CREATEDIBSECTION = 8192,
    LR_DEFAULTSIZE = 64,

    SS_LEFT             = #00000000,
    SS_CENTER           = #00000001,
    SS_RIGHT            = #00000002,
    SS_ICON             = #00000003,
    SS_BLACKRECT        = #00000004,
    SS_GRAYRECT         = #00000005,
    SS_WHITERECT        = #00000006,
    SS_BLACKFRAME       = #00000007,
    SS_GRAYFRAME        = #00000008,
    SS_WHITEFRAME       = #00000009,
    SS_USERITEM         = #0000000A,
    SS_SIMPLE           = #0000000B,
    SS_LEFTNOWORDWRAP   = #0000000C,
    SS_OWNERDRAW        = #0000000D,
    SS_BITMAP           = #0000000E,
    SS_ENHMETAFILE      = #0000000F,
    SS_ETCHEDHORZ       = #00000010,
    SS_ETCHEDVERT       = #00000011,
    SS_ETCHEDFRAME      = #00000012,
    SS_TYPEMASK         = #0000001F,
    SS_NOPREFIX         = #00000080,
    SS_NOTIFY           = #00000100,
    SS_CENTERIMAGE      = #00000200,
    SS_RIGHTJUST        = #00000400,
    SS_REALSIZEIMAGE    = #00000800,
    SS_SUNKEN           = #00001000,
    SS_ENDELLIPSIS      = #00004000,
    SS_PATHELLIPSIS     = #00008000,
    SS_WORDELLIPSIS     = #0000C000,
    SS_ELLIPSISMASK     = #0000C000,



    STM_SETICON         = #0170,
    STM_GETICON         = #0171,
    STM_SETIMAGE        = #0172,
    STM_GETIMAGE        = #0173,

    STN_CLICKED         = 0,
    STN_DBLCLK          = 1,
    STN_ENABLE          = 2,
    STN_DISABLE         = 3,


-- Class field offsets for GetClassLong() and GetClassWord()
    GCL_MENUNAME = (-8),
    GCL_HBRBACKGROUND = (-10),      -- background brush
    GCL_HCURSOR = (-12),
    GCL_HICON = (-14),
    GCL_HMODULE = (-16),
    GCL_CBWNDEXTRA = (-18),
    GCL_CBCLSEXTRA = (-20),
    GCL_WNDPROC = (-24),
    GCL_STYLE = (-26),
    GCW_ATOM = (-32),

-- System Colors
    COLOR_SCROLLBAR             = 0,
    COLOR_BACKGROUND            = 1,
    COLOR_DESKTOP               = COLOR_BACKGROUND,
    COLOR_ACTIVECAPTION         = 2,
    COLOR_INACTIVECAPTION       = 3,
    COLOR_MENU                  = 4,
    COLOR_WINDOW                = 5,
    COLOR_WINDOWFRAME           = 6,
    COLOR_MENUTEXT              = 7,
    COLOR_WINDOWTEXT            = 8,
    COLOR_CAPTIONTEXT           = 9,
    COLOR_ACTIVEBORDER          = 10,
    COLOR_INACTIVEBORDER        = 11,
    COLOR_APPWORKSPACE          = 12,
    COLOR_HIGHLIGHT             = 13,
    COLOR_HIGHLIGHTTEXT         = 14,
    COLOR_BTNFACE               = 15,
    COLOR_3DFACE                = COLOR_BTNFACE,
    COLOR_BTNSHADOW             = 16,
    COLOR_3DSHADOW              = COLOR_BTNSHADOW,
    COLOR_GRAYTEXT              = 17,
    COLOR_BTNTEXT               = 18,
    COLOR_INACTIVECAPTIONTEXT   = 19,
    COLOR_BTNHIGHLIGHT          = 20,
    COLOR_3DHILIGHT             = COLOR_BTNHIGHLIGHT,
    COLOR_3DDKSHADOW            = 21,
    COLOR_3DLIGHT               = 22,
    COLOR_INFOTEXT              = 23,
    COLOR_TOOLTIPTEXT           = COLOR_INFOTEXT,
    COLOR_INFOBK                = 24,
    COLOR_TOOLTIPBK             = COLOR_INFOBK,
    -- not used                 = 25,
    COLOR_HOTLIGHT              = 26,
    COLOR_GRADIENTACTIVECAPTION = 27,
    COLOR_GRADIENTINACTIVECAPTION = 28,
    COLOR_MENUHILIGHT           = 29,
    COLOR_MENUBAR               = 30


constant
    w32Color_SCROLLBAR             = -1,
    w32Color_BACKGROUND            = -2,
    w32Color_DESKTOP               = w32Color_BACKGROUND,
    w32Color_ACTIVECAPTION         = -3,
    w32Color_INACTIVECAPTION       = -4,
    w32Color_MENU                  = -5,
    w32Color_WINDOW                = -6,
    w32Color_WINDOWFRAME           = -7,
    w32Color_MENUTEXT              = -8,
    w32Color_WINDOWTEXT            = -9,
    w32Color_CAPTIONTEXT           = -10,
    w32Color_ACTIVEBORDER          = -11,
    w32Color_INACTIVEBORDER        = -12,
    w32Color_APPWORKSPACE          = -13,
    w32Color_HIGHLIGHT             = -14,
    w32Color_HIGHLIGHTTEXT         = -15,
    w32Color_BTNFACE               = -16,
    w32Color_3DFACE                = w32Color_BTNFACE,
    w32Color_BTNSHADOW             = -17,
    w32Color_3DSHADOW              = w32Color_BTNSHADOW,
    w32Color_GRAYTEXT              = -18,
    w32Color_BTNTEXT               = -19,
    w32Color_INACTIVECAPTIONTEXT   = -20,
    w32Color_BTNHIGHLIGHT          = -21,
    w32Color_3DHILIGHT             = w32Color_BTNHIGHLIGHT,
    w32Color_3DDKSHADOW            = -22,
    w32Color_3DLIGHT               = -23,
    w32Color_INFOTEXT              = -24,
    w32Color_TOOLTIPTEXT           = w32Color_INFOTEXT,
    w32Color_INFOBK                = -25,
    w32Color_TOOLTIPBK             = w32Color_INFOBK,
    w32Color_HOTLIGHT              = -27,
    w32Color_GRADIENTACTIVECAPTION = -28,
    w32Color_GRADIENTINACTIVECAPTION = -29,
    w32Color_MENUHILIGHT           = -30,
    w32Color_MENUBAR               = -31


global constant
-- Key State Masks for Mouse Messages
    MK_LBUTTON = #01,   -- left button is pressed
    MK_RBUTTON = #02,   -- right button is pressed
    MK_SHIFT   = #04,   -- shift key is held down
    MK_CONTROL = #08,   -- control key is held down
    MK_MBUTTON = #10,   -- middle button is pressed

-- constants for CreateDIBitmap
    CBM_CREATEDIB = #2, -- create DIB bitmap
    CBM_INIT = #4,      --  initialize bitmap

    CC_ENABLEHOOK = 16,
    CC_ENABLETEMPLATE = 32,
    CC_ENABLETEMPLATEHANDLE = 64,
    CC_FULLOPEN = 2,
    CC_PREVENTFULLOPEN = 4,
    CC_RGBINIT = 1,
    CC_SHOWHELP = 8,
    CC_SOLIDCOLOR = 128,

    CF_SCREENFONTS  = 1,            -- get screen fonts
    CF_PRINTERFONTS = 2,            -- get printer fonts
    CF_BOTH         = CF_SCREENFONTS + CF_PRINTERFONTS,
    CF_SHOWHELP     = 4,
    CF_ENABLEHOOK   = 8,
    CF_ENABLETEMPLATE = #10,
    CF_ENABLETEMPLATEHANDLE = #20,
    CF_INITTOLOGFONTSTRUCT = #40,
    CF_USESTYLE     = #80,
    CF_EFFECTS      = #100,
    CF_APPLY        = #200,
    CF_ANSIONLY     = #400,
    CF_SCRIPTSONLY  = CF_ANSIONLY,
    CF_NOVECTORFONTS = #800,
    CF_NOOEMFONTS   = CF_NOVECTORFONTS,
    CF_NOSIMULATIONS = #1000,
    CF_LIMITSIZE     = #2000,
    CF_FIXEDPITCHONLY = #4000,
    CF_WYSIWYG        = #8000, -- must also have CF_SCREENFONTS & CF_PRINTERFONTS
    CF_FORCEFONTEXIST = #10000,
    CF_SCALABLEONLY   = #20000,
    CF_TTONLY       = #40000,
    CF_NOFACESEL    = #80000,
    CF_NOSTYLESEL   = #100000,
    CF_NOSIZESEL    = #200000,
    CF_SELECTSCRIPT = #400000,
    CF_NOSCRIPTSEL  = #800000,
    CF_NOVERTFONTS  = #1000000,


-- constants for onResize
    -- WM_SIZE message wParam values
    SIZE_RESTORED   = 0,
    SIZE_MINIMIZED  = 1,
    SIZE_MAXIMIZED  = 2,
    SIZE_MAXSHOW    = 3,
    SIZE_MAXHIDE    = 4,

    -- Obsolete constant names
    SIZENORMAL      = SIZE_RESTORED,
    SIZEICONIC      = SIZE_MINIMIZED,
    SIZEFULLSCREEN  = SIZE_MAXIMIZED,
    SIZEZOOMSHOW    = SIZE_MAXSHOW,
    SIZEZOOMHIDE    = SIZE_MAXHIDE


-----------------------------------------------------------------------------
-- Win32 Wrappers for mouse flags

global constant
-- Visual Basics Names for the buttons:
    LEFT_BUTTON     = MK_LBUTTON,
    RIGHT_BUTTON    = MK_RBUTTON,
    MIDDLE_BUTTON   = MK_MBUTTON,
    SHIFT_MASK      = MK_SHIFT,
    CTRL_MASK       = MK_CONTROL,

-- Win32Lib names for mouse events
    MOUSE_MOVE          = WM_MOUSEMOVE,
    LEFT_DOWN           = WM_LBUTTONDOWN,
    RIGHT_DOWN          = WM_RBUTTONDOWN,
    LEFT_UP             = WM_LBUTTONUP,
    RIGHT_UP            = WM_RBUTTONUP,
    LEFT_DOUBLECLICK    = WM_LBUTTONDBLCLK,
    RIGHT_DOUBLECLICK   = WM_RBUTTONDBLCLK,
    WHEEL_MOVE          = WM_MOUSEWHEEL,

    MouseMove           = MOUSE_MOVE,
    LeftDown            = LEFT_DOWN,
    RightDown           = RIGHT_DOWN,
    LeftUp              = LEFT_UP,
    RightUp             = RIGHT_UP,
    LeftDoubleClick     = LEFT_DOUBLECLICK,
    RightDoubleClick    = RIGHT_DOUBLECLICK,
    WheelMove           = WM_MOUSEWHEEL,


-----------------------------------------------------------------------------
-- Window field offsets for GetWindowLong() and GetWindowWord()
    GWL_WNDPROC         = -4,
    GWL_HINSTANCE       = -6,
    GWL_HWNDPARENT      = -8,
    GWL_STYLE           = -16,
    GWL_EXSTYLE         = -20,
    GWL_USERDATA        = -21,
    GWL_ID              = -12,

-----------------------------------------------------------------------------
    TA_TOP          = 0,
    TA_LEFT         = 0,
    TA_NOUPDATECP   = 0,
    TA_UPDATECP     = 1,
    TA_RIGHT        = 2,
    TA_CENTER       = 6,
    VTA_CENTER      = 6,
    TA_BOTTOM       = 8,
    TA_BASELINE     = 24,
    VTA_BASELINE    = 24,
    TA_RTLREADING   = 256,

    AlignTop        = TA_TOP,
    AlignBottom     = TA_BOTTOM,
    AlignBaseline   = TA_BASELINE,
    AlignCenter     = TA_CENTER,
    AlignLeft       = TA_LEFT,
    AlignRight      = TA_RIGHT,


    CCM_FIRST               = #2000,
    CCM_SETCOLORSCHEME      = (CCM_FIRST + 2),
    CCM_GETCOLORSCHEME      = (CCM_FIRST + 3),
    CCM_GETDROPTARGET       = (CCM_FIRST + 4),
    CCM_SETUNICODEFORMAT    = (CCM_FIRST + 5),
    CCM_GETUNICODEFORMAT    = (CCM_FIRST + 6),
    CCM_SETBKCOLOR          = (CCM_FIRST + 1),

    LVS_ICON                =  #0,
    LVS_REPORT              =  #1,
    LVS_SMALLICON           =  #2,
    LVS_LIST                =  #3,
    LVS_TYPEMASK            =  #3,
    LVS_SINGLESEL           =  #4,
    LVS_SHOWSELALWAYS       =  #8,
    LVS_SORTASCENDING       =  #10,
    LVS_SORTDESCENDING      =  #20,
    LVS_SHAREIMAGELISTS     =  #40,
    LVS_NOLABELWRAP         =  #80,
    LVS_AUTOARRANGE         =  #100,
    LVS_EDITLABELS          =  #200,
    LVS_OWNERDATA           =  #1000,
    LVS_NOSCROLL            =  #2000,
    LVS_TYPESTYLEMASK       =  #FC00,
    LVS_ALIGNTOP            =  #0,
    LVS_ALIGNLEFT           =  #800,
    LVS_ALIGNMASK           =  #C00,
    LVS_OWNERDRAWFIXED      =  #400,
    LVS_NOCOLUMNHEADER      =  #4000,
    LVS_NOSORTHEADER        =  #8000,

    LVA_DEFAULT             = 0,
    LVA_ALIGNLEFT           = 1,
    LVA_ALIGNTOP            = 2,
    LVA_SNAPTOGRID          = 5,

    LVS_EX_GRIDLINES        = 1,
    LVS_EX_SUBITEMIMAGES    = 2,
    LVS_EX_CHECKBOXES       = 4,
    LVS_EX_TRACKSELECT      = 8,
    LVS_EX_HEADERDRAGDROP   = #10,
    LVS_EX_FULLROWSELECT    = #20,
    LVS_EX_ONECLICKACTIVATE = #40,
    LVS_EX_TWOCLICKACTIVATE = #80,
    LVS_EX_FLATSB           = #100,
    LVS_EX_REGIONAL         = #200,
    LVS_EX_NFOTIP           = #400,
    LVS_EX_UNDERLINEHOT     = #800,
    LVS_EX_UNDERLINECOLD    = #1000,
    LVS_EX_MULTIWORKAREAS   = #2000,

    LVM_FIRST               =  #1000,
    LVM_GETBKCOLOR          =  (LVM_FIRST + 0),
    LVM_SETBKCOLOR          =  (LVM_FIRST + 1),
    LVM_GETIMAGELIST        =  (LVM_FIRST + 2),
    LVM_SETIMAGELIST        =  (LVM_FIRST + 3),
    LVM_GETITEMCOUNT        =  (LVM_FIRST + 4),
    LVM_GETITEMA            =  (LVM_FIRST + 5),
    LVM_GETITEM             =  LVM_GETITEMA,
    LVM_SETITEMA            =  (LVM_FIRST + 6),
    LVM_SETITEM             =  LVM_SETITEMA,
    LVM_INSERTITEMA         =  (LVM_FIRST + 7),
    LVM_INSERTITEM          =  LVM_INSERTITEMA,
    LVM_DELETEITEM          =  (LVM_FIRST + 8),
    LVM_DELETEALLITEMS      =  (LVM_FIRST + 9),
    LVM_GETCALLBACKMASK     =  (LVM_FIRST + 10),
    LVM_SETCALLBACKMASK     =  (LVM_FIRST + 11),
    LVM_GETNEXTITEM         =  (LVM_FIRST + 12),
    LVM_FINDITEM            =  (LVM_FIRST + 13),
    LVM_GETITEMRECT         =  (LVM_FIRST + 14),
    LVM_SETITEMPOSITION     =  (LVM_FIRST + 15),
    LVM_GETITEMPOSITION     =  (LVM_FIRST + 16),
    LVM_GETSTRINGWIDTH      =  (LVM_FIRST + 17),
    LVM_HITTEST             =  (LVM_FIRST + 18),
    LVM_ENSUREVISIBLE       =  (LVM_FIRST + 19),
    LVM_SCROLL              =  (LVM_FIRST + 20),
    LVM_REDRAWITEMS         =  (LVM_FIRST + 21),
    LVM_ARRANGE             =  (LVM_FIRST + 22),
    LVM_EDITLABEL           =  (LVM_FIRST + 23),
    LVM_GETEDITCONTROL      =  (LVM_FIRST + 24),
    LVM_GETCOLUMN           =  (LVM_FIRST + 25),
    LVM_INSERTCOLUMNA       =  (LVM_FIRST + 27),
    LVM_INSERTCOLUMN        =  LVM_INSERTCOLUMNA,
    LVM_DELETECOLUMN        =  (LVM_FIRST + 28),
    LVM_SETCOLUMN           =  4122,
    LVM_GETCOLUMNWIDTH      =  (LVM_FIRST + 29),
    LVM_SETCOLUMNWIDTH      =  (LVM_FIRST + 30),
    LVM_GETHEADER           =  (LVM_FIRST + 31),
    LVM_CREATEDRAGIMAGE     =  (LVM_FIRST + 33),
    LVM_GETVIEWRECT         =  (LVM_FIRST + 34),
    LVM_GETTEXTCOLOR        =  (LVM_FIRST + 35),
    LVM_SETTEXTCOLOR        =  (LVM_FIRST + 36),
    LVM_GETTEXTBKCOLOR      =  (LVM_FIRST + 37),
    LVM_SETTEXTBKCOLOR      =  (LVM_FIRST + 38),
    LVM_GETTOPINDEX         =  (LVM_FIRST + 39),
    LVM_GETCOUNTPERPAGE     =  (LVM_FIRST + 40),
    LVM_GETORIGIN           =  (LVM_FIRST + 41),
    LVM_UPDATE              =  (LVM_FIRST + 42),
    LVM_SETITEMSTATE        =  (LVM_FIRST + 43),
    LVM_GETITEMSTATE        =  (LVM_FIRST + 44),
    LVM_GETITEMTEXTA        =  (LVM_FIRST + 45),
    LVM_GETITEMTEXT         =  LVM_GETITEMTEXTA,
    LVM_SETITEMTEXTA        =  (LVM_FIRST + 46),
    LVM_SETITEMTEXT         =  LVM_SETITEMTEXTA,
    LVM_SETITEMCOUNT        =  (LVM_FIRST + 47),
    LVM_SORTITEMS           =  (LVM_FIRST + 48),
    LVM_SETITEMPOSITION32   =  (LVM_FIRST + 49),
    LVM_GETSELECTEDCOUNT    =  (LVM_FIRST + 50),
    LVM_GETITEMSPACING      =  (LVM_FIRST + 51),
    LVM_GETISEARCHSTRINGA   =  (LVM_FIRST + 52),
    LVM_GETISEARCHSTRING    =  LVM_GETISEARCHSTRINGA,
    LVM_SETICONSPACING      =  (LVM_FIRST + 53),
    LVM_SETEXTENDEDLISTVIEWSTYLE =  (LVM_FIRST + 54),
    LVM_GETEXTENDEDLISTVIEWSTYLE =  (LVM_FIRST + 55),
    LVM_GETSUBITEMRECT      =  (LVM_FIRST + 56),
    LVM_SUBITEMHITTEST      =  (LVM_FIRST + 57),
    LVM_SETCOLUMNORDERARRAY =  (LVM_FIRST + 58),
    LVM_GETCOLUMNORDERARRAY =  (LVM_FIRST + 59),
    LVM_SETHOTITEM          =  (LVM_FIRST + 60),
    LVM_GETHOTITEM          =  (LVM_FIRST + 61),
    LVM_SETHOTCURSOR        =  (LVM_FIRST + 62),
    LVM_GETHOTCURSOR        =  (LVM_FIRST + 63),
    LVM_APPROXIMATEVIEWRECT =  (LVM_FIRST + 64),
    LV_MAX_WORKAREAS        =  16,
    LVM_SETWORKAREAS        =  (LVM_FIRST + 65),
    LVM_GETSELECTIONMARK    =  (LVM_FIRST + 66),
    LVM_SETSELECTIONMARK    =  (LVM_FIRST + 67),
    LVM_GETWORKAREAS        =  (LVM_FIRST + 70),
    LVM_SETHOVERTIME        =  (LVM_FIRST + 71),
    LVM_GETHOVERTIME        =  (LVM_FIRST + 72),
    LVM_GETNUMBEROFWORKAREAS=  (LVM_FIRST + 73),
    LVM_SETTOOLTIPS         =  (LVM_FIRST + 74),
    LVM_GETTOOLTIPS         =  (LVM_FIRST + 78),

    LVSCW_AUTOSIZE              = -1,
    LVSCW_AUTOSIZE_USEHEADER    = -2,

    LVFINDINFO_flags        = w32allot( Long ),
    LVFINDINFO_psz          = w32allot( Lpsz ),
    LVFINDINFO_lParam       = w32allot( Long ),
    LVFINDINFO_ptX          = w32allot( Long ),
    LVFINDINFO_ptY          = w32allot( Long ),
    LVFINDINFO_vkDirection  = w32allot( Long ),
    SIZEOF_LVFINDINFO       = w32allotted_size(),

    LVFI_PARAM              =  #1,
    LVFI_STRING             =  #2,
    LVFI_PARTIAL            =  #8,
    LVFI_WRAP               =  #20,
    LVFI_NEARESTXY          =  #40,

    LVNI_ALL                = 0,
    LVNI_FOCUSED            = 1,
    LVNI_SELECTED           = 2,
    LVNI_CUT                = 4,
    LVNI_DROPHILITED        = 8,

    LVNI_ABOVE              = #100,
    LVNI_BELOW              = #200,
    LVNI_TOLEFT             = #400,
    LVNI_TORIGHT            = #800,

    LVIF_TEXT               = 1,
    LVIF_IMAGE              = 2,
    LVIF_PARAM              = 4,
    LVIF_STATE              = 8,
    LVIF_INDENT             = #10,
    LVIF_NORECOMPUTE        = #800,
    LVIF_DI_SETITEM         = #1000,

    LVCFMT_LEFT              = 0,
    LVCFMT_RIGHT             = 1,
    LVCFMT_CENTER            = 2,
    LVCFMT_JUSTIFYMASK       = 3,

    LVCF_FMT                 = #1,
    LVCF_WIDTH               = #2,
    LVCF_TEXT                = #4,
    LVCF_SUBITEM             = #8,
    LVCF_IMAGE               = #10,
    LVCF_ORDER               = #20,

-- states
    LVIS_FOCUSED            = #0001,
    LVIS_SELECTED           = #0002,
    LVIS_CUT                = #0004,
    LVIS_DROPHILITED        = #0008,
    LVIS_ACTIVATING         = #0020,
    LVIS_OVERLAYMASK        = #0F00,
    LVIS_STATEIMAGEMASK     = #F000,
    LV_IS_CHECKED           = #2000,

    LVIR_BOUNDS             = 0,
    LVIR_ICON               = 1,
    LVIR_LABEL              = 2,
    LVIR_SELECTBOUNDS       = 3,

    LVHT_NOWHERE            = 1,
    LVHT_ONITEMICON         = 2,
    LVHT_ONITEMLABEL        = 4,
    LVHT_ONITEMSTATEICON    = 8,
    LVHT_ONITEM             = w32or_all({LVHT_ONITEMICON, LVHT_ONITEMLABEL,
	    	          LVHT_ONITEMSTATEICON}),

    LVHT_ABOVE              = 8,
    LVHT_BELOW              = #10,
    LVHT_TORIGHT            = #20,
    LVHT_TOLEFT             = #40,

    LVCOLUMN_mask           = w32allot( Long ),
    LVCOLUMN_fmt            = w32allot( Long ),
    LVCOLUMN_cx             = w32allot( Long ),
    LVCOLUMN_pszText        = w32allot( Lpsz ),
    LVCOLUMN_cchTextMax     = w32allot( Long ),
    LVCOLUMN_iSubItem       = w32allot( Long ),
    LVCOLUMN_iImage         = w32allot( Long ),
    LVCOLUMN_iOrder         = w32allot( Long ),
    SIZEOF_LVCOLUMN         = w32allotted_size(),

    LVITEM_mask             = w32allot( Long ),
    LVITEM_iItem            = w32allot( Long ),
    LVITEM_iSubItem         = w32allot( Long ),
    LVITEM_state            = w32allot( UInt ),
    LVITEM_stateMask        = w32allot( UInt ),
    LVITEM_pszText          = w32allot( Lpsz ),
    LVITEM_cchTextMax       = w32allot( Long ),
    LVITEM_iImage           = w32allot( Long ),
    LVITEM_lParam           = w32allot( Long ),
    LVITEM_iIndent          = w32allot( Long ),
    LVITEM_iGroupId         = w32allot( Long ),
    LVITEM_cColumns         = w32allot( Long ),
    LVITEM_puColumns        = w32allot( Long ),
    SIZEOF_LVITEM           = w32allotted_size(),

    LVSIL_NORMAL            = 0,
    LVSIL_SMALL             = 1,
    LVSIL_STATE             = 2,

    LVN_BEGINDRAG = -109,
    LVN_BEGINRDRAG = -111,
    LVN_COLUMNCLICK = -108,
    LVN_DELETEALLITEMS = -104,
    LVN_DELETEITEM = -103,
    LVN_BEGINLABELEDITW = -175,
    LVN_ENDLABELEDITW = -176,
    LVN_GETDISPINFOW = -177,
    LVN_SETDISPINFOW = -178,
    LVN_BEGINLABELEDITA = -105,
    LVN_ENDLABELEDITA = -106,
    LVN_GETDISPINFOA = -150,
    LVN_SETDISPINFOA = -151,
    LVN_INSERTITEM = -102,
    LVN_ITEMCHANGED = -101,
    LVN_ITEMCHANGING = -100,
    LVN_KEYDOWN = -155,
    LVN_GETDISPINFO = -150,
    LVN_SETDISPINFO = -151,
    LVN_ITEMACTIVATE = -114,

    LVN_FIRST               = -100,
    LVN_LAST                = (LVN_FIRST + 99),

    LVDISPINFO_NMHDRhwndFrom        = w32allot( UInt ),
    LVDISPINFO_NMHDRidFrom          = w32allot( Long ),
    LVDISPINFO_NMHDRcode            = w32allot( Long ),
    LVDISPINFO_LVITEMmask           = w32allot( Long ),
    LVDISPINFO_LVITEMiItem          = w32allot( Long ),
    LVDISPINFO_LVITEMiSubItem       = w32allot( Long ),
    LVDISPINFO_LVITEMstate          = w32allot( UInt ),
    LVDISPINFO_LVITEMstateMask      = w32allot( UInt ),
    LVDISPINFO_LVITEMpszText        = w32allot( Lpsz ),
    LVDISPINFO_LVITEMcchTextMax     = w32allot( Long ),
    LVDISPINFO_LVITEMiImage         = w32allot( Long ),
    LVDISPINFO_LVITEMlParam         = w32allot( Long ),
    LVDISPINFO_LVITEMiIndent        = w32allot( Long ),
    LVDISPINFO_LVITEMiGroupId       = w32allot( Long ),
    LVDISPINFO_LVITEMcColumns       = w32allot( Long ),
    LVDISPINFO_LVITEMpuColumns      = w32allot( Long ),
    SIZEOF_LVDISPINFO               = w32allotted_size(),

    -- List View HITTESTINFO
    LVHITTESTINFO_ptX           = w32allot(Long),
    LVHITTESTINFO_ptY           = w32allot(Long),
    LVHITTESTINFO_flags         = w32allot(UInt),
    LVHITTESTINFO_iItem         = w32allot(Long),
    LVHITTESTINFO_iSubItem      = w32allot(Long),
    SIZEOF_LVHITTESTINFO        = w32allotted_size(),


    NMLISTVIEW_HDRhWndFrom      = w32allot( Long ),
    NMLISTVIEW_HDRidFrom        = w32allot( Long ),
    NMLISTVIEW_HDRcode          = w32allot( Long ),
    NMLISTVIEW_iItem            = w32allot( Long ),
    NMLISTVIEW_iSubItem         = w32allot( Long ),
    NMLISTVIEW_uNewState        = w32allot( UInt ),
    NMLISTVIEW_uOldState        = w32allot( UInt ),
    NMLISTVIEW_uChanged         = w32allot( UInt ),
    NMLISTVIEW_ptActionX        = w32allot( Long ),
    NMLISTVIEW_ptActionY        = w32allot( Long ),
    NMLISTVIEW_lParam           = w32allot( Long ),
    SIZEOF_NMLISTVIEW           = w32allotted_size(),


-- ImageLists
    ILC_MASK                =1,
    ILC_COLOR               =0,
    ILC_COLORDDB            =#FE,
    ILC_COLOR4              =0,
    ILC_COLOR8              =8,
    ILC_COLOR16             =#10,
    ILC_COLOR24             =#18,
    ILC_COLOR32             =#20,

    LPSTR_TEXTCALLBACKA = (-1),
    LPSTR_TEXTCALLBACK  = (-1),

-- Treeview:
    TVS_HASBUTTONS           = 1,
    TVS_HASLINES            = 2,
    TVS_LINESATROOT         = 4,
    TVS_EDITLABELS          = 8,
    TVS_DISABLEDRAGDROP     = #10,
    TVS_SHOWSELALWAYS       = #20,
    TVS_RTLREADING          = #40,
    TVS_NOTOOLTIPS          = #80,
    TVS_CHECKBOXES          = #100,
    TVS_TRACKSELECT         = #200,
    TVS_SINGLEEXPAND        = #400,
    TVS_INFOTIP             = #800,
    TVS_FULLROWSELECT       = #1000,
    TVS_NOSCROLL            = #2000,
    TVS_NONEVENHEIGHT       = #4000,

    TVSIL_NORMAL            = 0,
    TVSIL_STATE             = 2,

    TVIF_TEXT               = 1,
    TVIF_IMAGE              = 2,
    TVIF_PARAM              = 4,
    TVIF_STATE              = 8,
    TVIF_HANDLE             = #10,
    TVIF_SELECTEDIMAGE      = #20,
    TVIF_CHILDREN           = #40,
    TVIF_INTEGRAL           = #80,

    TVIS_DESELECTED_MASK    = #1000,
    TVIS_SELECTED           = #0002,
    TVIS_SELECTED_MASK      = #2000,
    TVIS_CUT                = #0004,
    TVIS_CUT_MASK           = #4000,
    TVIS_DROPHILITED        = #0008,
    TVIS_DROPHILITED_MASK   = #8000,
    TVIS_BOLD               = #0010,
    TVIS_EXPANDED           = #0020,
    TVIS_EXPANDEDONCE       = #0040,
    TVIS_EXPANDPARTIAL      = #0080,
    TVIS_OVERLAYMASK        = #0F00,
    TVIS_STATEIMAGEMASK     = #F000,
    TVIS_USERMASK           = #F000,

    TVITEM_mask             = w32allot( UInt ),
    TVITEM_hItem            = w32allot( Long ),
    TVITEM_state            = w32allot( UInt ),
    TVITEM_stateMask        = w32allot( UInt ),
    TVITEM_pszText          = w32allot( Lpsz ),
    TVITEM_cchTextMax       = w32allot( Long ),
    TVITEM_iImage           = w32allot( Long ),
    TVITEM_iSelectedImage   = w32allot( Long ),
    TVITEM_cChildren        = w32allot( Long ),
    TVITEM_lParam           = w32allot( Long ),
    SIZEOF_TVITEM           = w32allotted_size(),

    TVITEMEX_mask           = w32allot( Long ),
    TVITEMEX_hItem          = w32allot( Long ),
    TVITEMEX_state          = w32allot( Long ),
    TVITEMEX_stateMask      = w32allot( Long ),
    TVITEMEX_pszText        = w32allot( Lpsz ),
    TVITEMEX_cchTextMax     = w32allot( Long ),
    TVITEMEX_iImage         = w32allot( Long ),
    TVITEMEX_iSelectedImage = w32allot( Long ),
    TVITEMEX_cChildren      = w32allot( Long ),
    TVITEMEX_lParam         = w32allot( Long ),
    TVITEMEX_iIntegral      = w32allot( Long ),
    SIZEOFEX_TVITEM         = w32allotted_size(),

    TVI_ROOT                = #FFFF0000,
    TVI_FIRST               = #FFFF0001,
    TVI_LAST                = #FFFF0002,
    TVI_SORT                = #FFFF0003,

    TVINSERTSTRUCT_hParent              = w32allot( Long ),
    TVINSERTSTRUCT_hInsertAfter         = w32allot( Long ),
    TVINSERTSTRUCTITEM_mask             = w32allot( UInt ),
    TVINSERTSTRUCTITEM_hItem            = w32allot( Long ),
    TVINSERTSTRUCTITEM_state            = w32allot( UInt ),
    TVINSERTSTRUCTITEM_stateMask        = w32allot( UInt ),
    TVINSERTSTRUCTITEM_pszText          = w32allot( Lpsz ),
    TVINSERTSTRUCTITEM_cchTextMax       = w32allot( Long ),
    TVINSERTSTRUCTITEM_iImage           = w32allot( Long ),
    TVINSERTSTRUCTITEM_iSelectedImage   = w32allot( Long ),
    TVINSERTSTRUCTITEM_cChildren        = w32allot( Long ),
    TVINSERTSTRUCTITEM_lParam           = w32allot( Long ),
    SIZEOF_TVINSERTSTRUCT               = w32allotted_size(),

    TVDISPINFO_NMHDRhwndFrom        = w32allot( UInt ),
    TVDISPINFO_NMHDRidFrom          = w32allot( Long ),
    TVDISPINFO_NMHDRcode            = w32allot( Long ),
    TVDISPINFO_TVITEMmask             = w32allot( UInt ),
    TVDISPINFO_TVITEMhItem            = w32allot( Long ),
    TVDISPINFO_TVITEMstate            = w32allot( UInt ),
    TVDISPINFO_TVITEMstateMask        = w32allot( UInt ),
    TVDISPINFO_TVITEMpszText          = w32allot( Lpsz ),
    TVDISPINFO_TVITEMcchTextMax       = w32allot( Long ),
    TVDISPINFO_TVITEMiImage           = w32allot( Long ),
    TVDISPINFO_TVITEMiSelectedImage   = w32allot( Long ),
    TVDISPINFO_TVITEMcChildren        = w32allot( Long ),
    TVDISPINFO_TVITEMlParam           = w32allot( Long ),
    SIZEOF_TVDISPINFO                 = w32allotted_size(),

    TV_FIRST                = #1100,
    TVM_INSERTITEMA         = (TV_FIRST + 0),
    TVM_INSERTITEM          = TVM_INSERTITEMA,
    TVM_DELETEITEM          = (TV_FIRST + 1),
    TVM_EXPAND              = (TV_FIRST + 2),
    TVM_GETITEMRECT         = (TV_FIRST + 4),
    TVM_GETCOUNT            = (TV_FIRST + 5),
    TVM_GETINDENT           = (TV_FIRST + 6),
    TVM_SETINDENT           = (TV_FIRST + 7),
    TVM_GETIMAGELIST        = (TV_FIRST + 8),
    TVM_SETIMAGELIST        = (TV_FIRST + 9),
    TVM_GETNEXTITEM         = (TV_FIRST + 10),
    TVM_SELECTITEM          = (TV_FIRST + 11),
    TVM_GETITEMA            = (TV_FIRST + 12),
    TVM_GETITEM             = TVM_GETITEMA,
    TVM_SETITEMA            = (TV_FIRST + 13),
    TVM_SETITEM             = TVM_SETITEMA,
    TVM_EDITLABELA          = (TV_FIRST + 14),
    TVM_EDITLABEL           = TVM_EDITLABELA,
    TVM_GETEDITCONTROL      = (TV_FIRST + 15),
    TVM_GETVISIBECOUNT      = (TV_FIRST + 16),
    TVM_HITTEST             = (TV_FIRST + 17),
    TVM_CREATEDRAGIMAGE     = (TV_FIRST + 18),
    TVM_SORTCHILDREN        = (TV_FIRST + 19),
    TVM_ENSUREVISIBLE       = (TV_FIRST + 20),
    TVM_SORTCHILDRENCB      = (TV_FIRST + 21),
    TVM_ENDEDITLABELNOW     = (TV_FIRST + 22),
    TVM_GETISEARCHSTRINGA   = (TV_FIRST + 23),
    TVM_GETISEARCHSTRING    = TVM_GETISEARCHSTRINGA,
    TVM_SETTOOLTIPS         = (TV_FIRST + 24),
    TVM_GETTOOLTIPS         = (TV_FIRST + 25),
    TVM_SETINSERTMARK       = (TV_FIRST + 26),
    TVM_SETITEMHEIGHT       = (TV_FIRST + 27),
    TVM_GETITEMHEIGHT       = (TV_FIRST + 28),
    TVM_SETBKCOLOR          = (TV_FIRST + 29),
    TVM_SETTEXTCOLOR        = (TV_FIRST + 30),
    TVM_GETBKCOLOR          = (TV_FIRST + 31),
    TVM_GETTEXTCOLOR        = (TV_FIRST + 32),
    TVM_SETSCROLLTIME       = (TV_FIRST + 33),
    TVM_GETSCROLLTIME       = (TV_FIRST + 34),
    TVM_SETINSERTMARKCOLOR  = (TV_FIRST + 37),
    TVM_GETINSERTMARKCOLOR  = (TV_FIRST + 38),


    TVGN_ROOT               = 0,
    TVGN_NEXT               = 1,
    TVGN_PREVIOUS           = 2,
    TVGN_PARENT             = 3,
    TVGN_CHILD              = 4,
    TVGN_FIRSTVISIBLE       = 5,
    TVGN_NEXTVISIBLE        = 6,
    TVGN_PREVIOUSVISIBLE    = 7,
    TVGN_DROPHILITE         = 8,
    TVGN_CARET              = 9,
    TVGN_LASTVISIBLE        = #A,

    TVE_COLLAPSE            = 1,
    TVE_EXPAND              = 2,
    TVE_TOGGLE              = 3,
    TVE_EXPANDPARTIAL       = #4000,
    TVE_COLLAPSERESET       = #8000,

    TVHITTESTINFO_ptX       = w32allot( Long ),
    TVHITTESTINFO_ptY       = w32allot( Long ),
    TVHITTESTINFO_flags     = w32allot( UInt ),
    TVHITTESTINFO_hItem     = w32allot( Long ),
    SIZEOF_TVHITTESTINFO    = w32allotted_size(),

    TVHT_NOWHERE            = 1,
    TVHT_ONITEMICON         = 2,
    TVHT_ONITEMLABEL        = 4,
    TVHT_ONITEMINDENT       = #8,
    TVHT_ONITEMBUTTON       = #10,
    TVHT_ONITEMRIGHT        = #20,
    TVHT_ONITEMSTATEICON    = #40,
    TVHT_ONITEM             = w32or_all( {TVHT_ONITEMICON, TVHT_ONITEMLABEL,
	    	        TVHT_ONITEMSTATEICON}),

    TVHT_ABOVE              = #100,
    TVHT_BELOW              = #200,
    TVHT_TORIGHT            = #400,
    TVHT_TOLEFT             = #800,

    TVN_KEYDOWN = -412,
    TVN_BEGINDRAGW = -456,
    TVN_BEGINLABELEDITW = -459,
    TVN_BEGINRDRAGW = -457,
    TVN_DELETEITEMW = -458,
    TVN_ENDLABELEDITW = -460,
    TVN_GETDISPINFOW = -452,
    TVN_ITEMEXPANDEDW = -455,
    TVN_ITEMEXPANDINGW = -454,
    TVN_SELCHANGEDW = -451,
    TVN_SELCHANGINGW = -450,
    TVN_SETDISPINFOW = -453,
    TVN_BEGINDRAG = -407,
    TVN_BEGINLABELEDIT = -410,
    TVN_BEGINRDRAG = -408,
    TVN_DELETEITEM = -409,
    TVN_ENDLABELEDIT = -411,
    TVN_GETDISPINFO = -403,
    TVN_ITEMEXPANDED = -406,
    TVN_ITEMEXPANDING = -405,
    TVN_SELCHANGED = -402,
    TVN_SELCHANGING = -401,
    TVN_SETDISPINFO = -404,
    onTVSelect  = TVN_SELCHANGEDW,

    NMTREEVIEW_NMHDRhwndFrom        = w32allot( UInt ),
    NMTREEVIEW_NMHDRidFrom          = w32allot( Long ),
    NMTREEVIEW_NMHDRcode            = w32allot( Long ),
    NMTREEVIEW_action               = w32allot( UInt ),
    NMTREEVIEW_itemOldmask             = w32allot( UInt ),
    NMTREEVIEW_itemOldhItem            = w32allot( Long ),
    NMTREEVIEW_itemOldstate            = w32allot( UInt ),
    NMTREEVIEW_itemOldstateMask        = w32allot( UInt ),
    NMTREEVIEW_itemOldpszText          = w32allot( Lpsz ),
    NMTREEVIEW_itemOldcchTextMax       = w32allot( Long ),
    NMTREEVIEW_itemOldiImage           = w32allot( Long ),
    NMTREEVIEW_itemOldiSelectedImage   = w32allot( Long ),
    NMTREEVIEW_itemOldcChildren        = w32allot( Long ),
    NMTREEVIEW_itemOldlParam           = w32allot( Long ),
    NMTREEVIEW_itemNewmask             = w32allot( UInt ),
    NMTREEVIEW_itemNewhItem            = w32allot( Long ),
    NMTREEVIEW_itemNewstate            = w32allot( UInt ),
    NMTREEVIEW_itemNewstateMask        = w32allot( UInt ),
    NMTREEVIEW_itemNewpszText          = w32allot( Lpsz ),
    NMTREEVIEW_itemNewcchTextMax       = w32allot( Long ),
    NMTREEVIEW_itemNewiImage           = w32allot( Long ),
    NMTREEVIEW_itemNewiSelectedImage   = w32allot( Long ),
    NMTREEVIEW_itemNewcChildren        = w32allot( Long ),
    NMTREEVIEW_itemNewlParam           = w32allot( Long ),
    NMTREEVIEW_ptX                  = w32allot( Long ),
    NMTREEVIEW_ptY                  = w32allot( Long ),
    SIZEOF_NMTREEVIEW           = w32allotted_size(),



    MCM_FIRST           = #1000,
    MCM_GETCURSEL       = (MCM_FIRST + 1),
    MCM_SETCURSEL       = (MCM_FIRST + 2),
    MCM_GETMAXSELCOUNT  = (MCM_FIRST + 3),
    MCM_SETMAXSELCOUNT  = (MCM_FIRST + 4),
    MCM_GETSELRANGE     = (MCM_FIRST + 5),
    MCM_SETSELRANGE     = (MCM_FIRST + 6),
    MCM_GETMONTHRANGE   = (MCM_FIRST + 7),
    MCM_SETDAYSTATE     = (MCM_FIRST + 8),
    MCM_GETMINREQRECT   = (MCM_FIRST + 9),
    MCM_SETCOLOR        = (MCM_FIRST +10),
    MCM_GETCOLOR        = (MCM_FIRST + 11),
    MCM_SETTODAY        = (MCM_FIRST + 12),
    MCM_GETTODAY        = (MCM_FIRST + 13),
    MCM_HITTEST         = (MCM_FIRST + 14),
    MCM_SETFIRSTDAYOFWEEK = (MCM_FIRST + 15),
    MCM_GETFIRSTDAYOFWEEK = (MCM_FIRST + 16),
    MCM_GETRANGE        = (MCM_FIRST + 17),
    MCM_SETRANGE        = (MCM_FIRST+ 18),
    MCM_GETMONTHDELTA   = (MCM_FIRST + 19),
    MCM_SETMONTHDELTA   = (MCM_FIRST + 20),
    MCM_GETMAXTODAYWIDTH = (MCM_FIRST + 21),

    MCN_FIRST           = -750,
    MCN_LAST            = -759,
    MCN_SELCHANGE       = (MCN_FIRST + 1),
    MCN_GETDAYSTATE     = (MCN_FIRST + 3),
    MCN_SELECT          = (MCN_FIRST + 4),

    MCS_DAYSTATE        = #1,
    MCS_MULTISELECT     = #2,
    MCS_WEEKNUMBERS     = #4,
    MCS_NOTODAYCIRCLE   = #8,
    MCS_NOTODAY         = #10,

    GMR_VISIBLE     = 0,
    GMR_DAYSTATE    = 1,

    MCHT_TITLE                      = #10000,
    MCHT_CALENDAR                   = #20000,
    MCHT_TODAYLINK                  = #30000,
    MCHT_NEXT                       = #1000000,
    MCHT_PREV                       = #2000000,
    MCHT_NOWHERE                    = #0,
    MCHT_TITLEBK                    = (MCHT_TITLE),
    MCHT_TITLEMONTH                 = or_bits( MCHT_TITLE , 1),
    MCHT_TITLEYEAR                  = or_bits( MCHT_TITLE, 2),
    MCHT_TITLEBTNNEXT               = w32or_all({ MCHT_TITLE, MCHT_NEXT, 3}),
    MCHT_TITLEBTNPREV               = w32or_all({ MCHT_TITLE, MCHT_PREV,  0}),
    MCHT_CALENDARBK                 = (MCHT_CALENDAR),
    MCHT_CALENDARDATE                = or_bits( MCHT_CALENDAR , 1),
    MCHT_CALENDARDATENEXT           = or_bits( MCHT_CALENDARDATE, MCHT_NEXT ),
    MCHT_CALENDARDATEPREV           = or_bits( MCHT_CALENDARDATE ,MCHT_PREV ),
    MCHT_CALENDARDAY                = or_bits( MCHT_CALENDAR , 2 ),
    MCHT_CALENDARWEEKNuM            = or_bits( MCHT_CALENDAR , 3),

    MCSC_BACKGROUND   = 0,
    MCSC_TEXT         = 1,
    MCSC_TITLEBK      = 2,
    MCSC_TITLETEXT    = 3,
    MCSC_MONTHBK      = 4,
    MCSC_TRAILINGTEXT = 5,

    NMDAYSTATE_NMHDRhwndFrom        = w32allot( UInt ),
    NMDAYSTATE_NMHDRidFrom          = w32allot( Long ),
    NMDAYSTATE_NMHDRcode            = w32allot( Long ),
    NMDAYSTATE_wYear                = w32allot( Word ),
    NMDAYSTATE_wMonth               = w32allot( Word ),
    NMDAYSTATE_wDayOfWeek           = w32allot( Word ),
    NMDAYSTATE_wDay                 = w32allot( Word ),
    NMDAYSTATE_wHour                = w32allot( Word ),
    NMDAYSTATE_wMinute              = w32allot( Word ),
    NMDAYSTATE_wSecond              = w32allot( Word ),
    NMDAYSTATE_wMilliseconds        = w32allot( Word ),
    NMDAYSTATE_cDayState            = w32allot( Long ),
    NMDAYSTATE_prgDayState          = w32allot( Long ),
    SIZEOF_NMDAYSTATE               = w32allotted_size(),

    CFM_BOLD = 1,
    CFM_COLOR = 1073741824,
    CFM_FACE = 536870912,
    CFM_ITALIC = 2,
    CFM_OFFSET = 268435456,
    CFM_PROTECTED = 16,
    CFM_SIZE =  #80000000,
    CFM_STRIKEOUT = 8,
    CFM_UNDERLINE = 4,

    CFM_ALL = w32or_all( {
    CFM_BOLD,
    CFM_COLOR,
    CFM_FACE,
    CFM_ITALIC,
    CFM_OFFSET,
    CFM_PROTECTED,
    CFM_SIZE,
    CFM_STRIKEOUT,
    CFM_UNDERLINE }),

    CFE_AUTOCOLOR = 1073741824,
    CFE_BOLD = 1,
    CFE_ITALIC = 2,
    CFE_STRIKEOUT = 8,
    CFE_UNDERLINE = 4,
    CFE_PROTECTED = 16,

    CHARFORMAT_cbSize               = w32allot( UInt ),
    CHARFORMAT_dwMask               = w32allot( DWord ),
    CHARFORMAT_dwEffects            = w32allot( DWord ),
    CHARFORMAT_yHeight              = w32allot( Long ),
    CHARFORMAT_yOffset              = w32allot( Long ),
    CHARFORMAT_crTextColor          = w32allot( Long ),
    CHARFORMAT_bCharSet             = w32allot( Byte ),
    CHARFORMAT_bPitchAndFamily      = w32allot( Byte ),
    CHARFORMAT_szFaceName           = w32allot( {32, Strz} ),
    CHARFORMAT_Reserved             = w32allot(2),
    SIZEOF_CHARFORMAT               = w32allotted_size(),

    PARAFORMAT_cbSize               = w32allot( UInt ),
    PARAFORMAT_dwMask               = w32allot( Long ),
    PARAFORMAT_wNumbering           = w32allot( Word ),
    PARAFORMAT_wReserved            = w32allot( Word ),
    PARAFORMAT_dxStartIndent        = w32allot( Long ),
    PARAFORMAT_dxRightIndent        = w32allot( Long ),
    PARAFORMAT_dxOffset             = w32allot( Long ),
    PARAFORMAT_wAlignment           = w32allot( Word ),
    PARAFORMAT_cTabCount            = w32allot( Word ),
    PARAFORMAT_rgxTabs              = w32allot( {32, Long} ), -- Array of Long's
    SIZEOF_PARAFORMAT               = w32allotted_size(),

    EM_DISPLAYBAND  = 1075,
    EM_EXGETSEL = 1076,
    EM_EXLIMITTEXT = 1077,
    EM_EXLINEFROMCHAR = 1078,
    EM_EXSETSEL = 1079,
    EM_FINDTEXT = 1080,
    EM_FORMATRANGE = 1081,
    EM_GETPARAFORMAT = 1085,
    EM_SETPARAFORMAT = 1095,
    EM_STREAMIN = 1097,
    EM_STREAMOUT = 1098,
    EM_GETTEXTRANGE = 1099,
    EM_FINDTEXTEX = 1103,

    FR_DIALOGTERM             =    #40,
    FR_DOWN                   =    #01,
    FR_ENABLEHOOK             =   #100,
    FR_ENABLETEMPLATE         =   #200,
    FR_ENABLETEMPLATEHANDLE   =  #2000,
    FR_FINDNEXT               =    #08,
    FR_HIDEUPDOWN             =  #4000,
    FR_HIDEMATCHCASE          =  #8000,
    FR_HIDEWHOLEWORD          = #10000,
    FR_MATCHCASE              =    #04,
    FR_NOMATCHCASE            =   #800,
    FR_NOUPDOWN               =   #400,
    FR_NOWHOLEWORD            =  #1000,
    FR_REPLACE                =    #10,
    FR_REPLACEALL             =    #20,
    FR_SHOWHELP               =    #80,
    FR_WHOLEWORD              =    #02,

    CHARRANGE_cpMin             = w32allot( Long ),
    CHARRANGE_cpMax             = w32allot( Long ),
    SIZEOF_CHARRANGE            = w32allotted_size(),

    FINDTEXTEX_chrgcpMin        = w32allot( Long ),
    FINDTEXTEX_chrgcpMax        = w32allot( Long ),
    FINDTEXTEX_lpstrText        = w32allot( Lpsz ),
    FINDTEXTEX_chrgTextcpMin    = w32allot( Long ),
    FINDTEXTEX_chrgTextcpMax    = w32allot( Long ),
    SIZEOF_FINDTEXTEX           = w32allotted_size(),

    TEXTRANGE_chrgcpMin         = w32allot( Long ),
    TEXTRANGE_chrgcpMax         = w32allot( Long ),
    TEXTRANGE_lpstrText         = w32allot( Lpsz ),
    SIZEOF_TEXTRANGE            = w32allotted_size(),

    SF_TEXT = 1,
    SF_RTF = 2,
    SF_RTFNOOBJS = 3,
    SF_TEXTIZED = 4,
    SFF_SELECTION = #8000,
    SFF_PLAINRTF = #4000,
    StreamText = SF_TEXT,
    StreamRTF = SF_RTF,
    StreamRich = SF_RTF,
    StreamSelection = SFF_SELECTION,
    StreamMask = #C007, -- Used force other bits off.

    EDITSTREAM_dwCookie         = w32allot( Long ),
    EDITSTREAM_dwError          = w32allot( Long ),
    EDITSTREAM_pfnCallback      = w32allot( Long ),
    SIZEOF_EDITSTREAM           = w32allotted_size(),

    PFM_ALIGNMENT = 8,
    PFM_NUMBERING = 32,
    PFM_OFFSET = 4,
    PFM_OFFSETINDENT =  #80000000,
    PFM_RIGHTINDENT = 2,
    PFM_STARTINDENT = 1,
    PFM_TABSTOPS = 16,
    PFN_BULLET = 1,

    PFA_LEFT = 1,
    PFA_RIGHT = 2,
    PFA_CENTER = 3,

    FINDREPLACE_lStructSize         = w32allot( Long ),
    FINDREPLACE_hwndOwner           = w32allot( Long ),
    FINDREPLACE_hInstance           = w32allot( Long ),
    FINDREPLACE_Flags               = w32allot( Long ),
    FINDREPLACE_lpstrFindWhat       = w32allot( Lpsz ),
    FINDREPLACE_lpstrReplaceWith    = w32allot( Lpsz ),
    FINDREPLACE_wFindWhatLen        = w32allot( Word ),
    FINDREPLACE_wReplaceWithLen     = w32allot( Word ),
    FINDREPLACE_lCustData           = w32allot( Long ),
    FINDREPLACE_lpfnHook            = w32allot( Long ),
    FINDREPLACE_lpTemplateName      = w32allot( Long ),
    SIZEOF_FINDREPLACE              = w32allotted_size(),

    SYSTEMTIME_wYear                = w32allot( Word ),
    SYSTEMTIME_wMonth               = w32allot( Word ),
    SYSTEMTIME_wDayOfWeek           = w32allot( Word ),
    SYSTEMTIME_wDay                 = w32allot( Word ),
    SYSTEMTIME_wHour                = w32allot( Word ),
    SYSTEMTIME_wMinute              = w32allot( Word ),
    SYSTEMTIME_wSecond              = w32allot( Word ),
    SYSTEMTIME_wMilliseconds        = w32allot( Word ),
    SIZEOF_SYSTEMTIME               = w32allotted_size(),

    ShortMonths                     = 1,
    LongMonths                      = 2,
    Months                          = {
	    	        {
	    	    	"Jan",
	    	    	"Feb",
	    	    	"Mar",
	    	    	"Apr",
	    	    	"May",
	    	    	"Jun",
	    	    	"Jul",
	    	    	"Aug",
	    	    	"Sep",
	    	    	"Oct",
	    	    	"Nov",
	    	    	"Dec"
	    	        },
	    	          {
	    	    	"January",
	    	    	"February",
	    	    	"March",
	    	    	"April",
	    	    	"May",
	    	    	"June",
	    	    	"July",
	    	    	"August",
	    	    	"September",
	    	    	"October",
	    	    	"November",
	    	    	"December"
	    	        }},
    Days        = { "Sunday",
	    	    	"Monday",
	    	    	"Tuesday",
	    	    	"Wednesday",
	    	    	"Thursday",
	    	    	"Friday",
	    	    	"Saturday" },

    UDS_ALIGNLEFT = 8,
    UDS_ALIGNRIGHT = 4,
    UDS_ARROWKEYS = 32,
    UDS_AUTOBUDDY = 16,
    UDS_HORZ = 64,
    UDS_NOTHOUSANDS = 128,
    UDS_SETBUDDYINT = 2,
    UDS_WRAP = 1,

    UD_MAXVAL = 32767,
    UD_MINVAL = -32767,

    UDM_GETACCEL = 1132,
    UDM_GETBASE = 1134,
    UDM_GETBUDDY = 1130,
    UDM_GETPOS = 1128,
    UDM_GETRANGE = 1126,
    UDM_SETACCEL = 1131,
    UDM_SETBASE = 1133,
    UDM_SETBUDDY = 1129,
    UDM_SETPOS = 1127,
    UDM_SETRANGE = 1125,
    UDM_SETRANGE32 = 1135,
    UDM_GETRANGE32 = 1136,

    UDN_DELTAPOS = -722,

    REBARBANDINFO_cbSize            = w32allot( UInt ),
    REBARBANDINFO_fMask             = w32allot( UInt ),
    REBARBANDINFO_fStyle            = w32allot( UInt ),
    REBARBANDINFO_clrFore           = w32allot( Long ),
    REBARBANDINFO_clrBack           = w32allot( Long ),
    REBARBANDINFO_lpText            = w32allot( Lpsz ),
    REBARBANDINFO_cch               = w32allot( UInt ),
    REBARBANDINFO_iImage            = w32allot( Long ),
    REBARBANDINFO_hwndChild         = w32allot( Long ),
    REBARBANDINFO_cxMinChild        = w32allot( Long ),
    REBARBANDINFO_cyMinChild        = w32allot( Long ),
    REBARBANDINFO_cx                = w32allot( Long ),
    REBARBANDINFO_hbmBack           = w32allot( Long ),
    REBARBANDINFO_wID               = w32allot( UInt ),
    REBARBANDINFO_cyChild           = w32allot( UInt ),
    REBARBANDINFO_cyMaxChild        = w32allot( UInt ),
    REBARBANDINFO_cyIntegral        = w32allot( UInt ),
    REBARBANDINFO_cxIdeal           = w32allot( UInt ),
    REBARBANDINFO_lParam            = w32allot( Long ),
    REBARBANDINFO_cxHeader          = w32allot( UInt ),
    SIZEOF_REBARBANDINFO            = w32allotted_size(),

    REBARINFO_cbSize                = w32allot( UInt ),
    REBARINFO_fMask                 = w32allot( UInt ),
    REBARINFO_himl                  = w32allot( Long ),
    SIZEOF_REBARINFO                = w32allotted_size(),

    RB_INSERTBANDA  =(WM_USER +  1),
    RB_DELETEBAND   =(WM_USER +  2),
    RB_GETBARINFO   =(WM_USER +  3),
    RB_SETBARINFO   =(WM_USER +  4),
    RB_SETBANDINFOA = (WM_USER +  6),
    RB_SETPARENT    =(WM_USER +  7),
    RB_HITTEST      =(WM_USER +  8),
    RB_GETRECT      =(WM_USER +  9),
    RB_INSERTBANDW  =(WM_USER +  10),
    RB_SETBANDINFOW =(WM_USER +  11),
    RB_GETBANDCOUNT =(WM_USER +  12),
    RB_GETROWCOUNT  =(WM_USER +  13),
    RB_GETROWHEIGHT =(WM_USER +  14),
    RB_IDTOINDEX    =(WM_USER +  16),
    RB_GETTOOLTIPS  =(WM_USER +  17),
    RB_SETTOOLTIPS  =(WM_USER +  18),
    RB_SETBKCOLOR   =(WM_USER +  19),
    RB_GETBKCOLOR   =(WM_USER +  20),
    RB_SETTEXTCOLOR =(WM_USER +  21),
    RB_GETTEXTCOLOR =(WM_USER +  22),
    RB_SIZETORECT   =(WM_USER +  23),
    RB_SETCOLORSCHEME=   CCM_SETCOLORSCHEME,
    RB_GETCOLORSCHEME=   CCM_GETCOLORSCHEME,
    RB_INSERTBAND   = RB_INSERTBANDA,
    RB_SETBANDINFO  = RB_SETBANDINFOA,
    RB_BEGINDRAG    =(WM_USER + 24),
    RB_ENDDRAG      =(WM_USER + 25),
    RB_DRAGMOVE     =(WM_USER + 26),
    RB_GETBARHEIGHT =(WM_USER + 27),
    RB_GETBANDINFOW =(WM_USER + 28),
    RB_GETBANDINFOA =(WM_USER + 29),
    RB_GETBANDINFO  = RB_GETBANDINFOA,
    RB_MINIMIZEBAND =(WM_USER + 30),
    RB_MAXIMIZEBAND =(WM_USER + 31),
    RB_GETDROPTARGET= (CCM_GETDROPTARGET),
    RB_GETBANDBORDERS= (WM_USER + 34),
    RB_SHOWBAND     =(WM_USER + 35),
    RB_SETPALETTE   =(WM_USER + 37),
    RB_GETPALETTE   =(WM_USER + 38),
    RB_MOVEBAND     =(WM_USER + 39),


    RBS_TOOLTIPS        = #0100,
    RBS_VARHEIGHT       = #0200,
    RBS_BANDBORDERS     = #0400,
    RBS_FIXEDORDER      = #0800,
    RBS_REGISTERDROP    = #1000,
    RBS_AUTOSIZE        = #2000,
    RBS_VERTICALGRIPPER = #4000,
    RBS_DBLCLKTOGGLE    = #8000,


    RBBS_BREAK          = #00000001,
    RBBS_FIXEDSIZE      = #00000002,
    RBBS_CHILDEDGE      = #00000004,
    RBBS_HIDDEN         = #00000008,
    RBBS_NOVERT         = #00000010,
    RBBS_FIXEDBMP       = #00000020,
    RBBS_VARIABLEHEIGHT = #00000040,
    RBBS_GRIPPERALWAYS  = #00000080,
    RBBS_NOGRIPPER      = #00000100,

    RBBIM_STYLE         = #00000001,
    RBBIM_COLORS        = #00000002,
    RBBIM_TEXT          = #00000004,
    RBBIM_IMAGE         = #00000008,
    RBBIM_CHILD         = #00000010,
    RBBIM_CHILDSIZE     = #00000020,
    RBBIM_SIZE          = #00000040,
    RBBIM_BACKGROUND    = #00000080,
    RBBIM_ID            = #00000100,
    RBBIM_IDEALSIZE     = #00000200,
    RBBIM_LPARAM        = #00000400,
    RBBIM_HEADERSIZE    = #00000800,

    RBN_HEIGHTCHANGE    = -831,

    TOOLINFO_cbSize     = w32allot( UInt ),
    TOOLINFO_uFlags     = w32allot( UInt ),
    TOOLINFO_hwnd       = w32allot( Long ),
    TOOLINFO_uId        = w32allot( UInt ),
    TOOLINFO_rectLeft   = w32allot( Long ),
    TOOLINFO_rectTop    = w32allot( Long ),
    TOOLINFO_rectRight  = w32allot( Long ),
    TOOLINFO_rectBottom = w32allot( Long ),
    TOOLINFO_hinst      = w32allot( Long ),
    TOOLINFO_lpszText   = w32allot( Lpsz ),
    TOOLINFO_lParam     = w32allot( Long ),
    SIZEOF_TOOLINFO     = w32allotted_size(),

    NMTTDISPINFO_hdrHwindFrom        = w32allot( Long ),
    NMTTDISPINFO_hdrIdFrom           = w32allot( UInt ),
    NMTTDISPINFO_hdrCode             = w32allot( UInt ),
    NMTTDISPINFO_lpszText            = w32allot( Lpsz ),
    NMTTDISPINFO_szText              = w32allot( {80, Strz} ),
    NMTTDISPINFO_hinst               = w32allot( Long ),
    NMTTDISPINFO_uFlags              = w32allot( UInt ),
    SIZEOF_NMTTDISPINFO              = w32allotted_size(),




    TTHITTESTINFO_hwnd              = w32allot( Long ),
    TTHITTESTINFO_ptX               = w32allot( Long ),
    TTHITTESTINFO_ptY               = w32allot( Long ),
    TTHITTESTINFO_ti                = w32allot( SIZEOF_TOOLINFO ),
    SIZEOF_TTHITTESTINFO            = w32allotted_size(),

    TTS_ALWAYSTIP           = #01,
    TTS_NOPREFIX            = #02,
    TTS_NOANIMATE           = #10,
    TTS_NOFADE              = #20,
    TTS_BALLOON             = #40,

    TTF_IDISHWND            = #0001,
    TTF_CENTERTIP           = #0002,
    TTF_RTLREADING          = #0004,
    TTF_SUBCLASS            = #0010,
    TTF_TRACK               = #0020,
    TTF_ABSOLUTE            = #0080,
    TTF_TRANSPARENT         = #0100,
    TTF_DI_SETITEM          = #8000,

    TTDT_AUTOMATIC          = 0,
    TTDT_RESHOW             = 1,
    TTDT_AUTOPOP            = 2,
    TTDT_INITIAL            = 3,

    TTM_ACTIVATE            = (WM_USER + 1),
    TTM_SETDELAYTIME        = (WM_USER + 3),
    TTM_ADDTOOL             = (WM_USER + 4),
    TTM_ADDTOOLW            = (WM_USER + 50),
    TTM_DELTOOL             = (WM_USER + 5),
    TTM_DELTOOLW            = (WM_USER + 51),
    TTM_NEWTOOLRECT         = (WM_USER + 6),
    TTM_NEWTOOLRECTW        = (WM_USER + 52),
    TTM_RELAYEVENT          = (WM_USER + 7),
    TTM_GETTOOLINFO         = (WM_USER + 8),
    TTM_SETTOOLINFO         = (WM_USER + 9),
    TTM_HITTEST             = (WM_USER +10),
    TTM_GETTEXT             = (WM_USER +11),
    TTM_UPDATETIPTEXT       = (WM_USER +12),
    TTM_GETTOOLCOUNT        = (WM_USER +13),
    TTM_ENUMTOOLS           = (WM_USER +14),
    TTM_GETCURRENTTOOL      = (WM_USER + 15),
    TTM_WINDOWFROMPOINT     = (WM_USER + 16),
    TTM_TRACKACTIVATE       = (WM_USER + 17),
    TTM_TRACKPOSITION       = (WM_USER + 18),
    TTM_SETTIPBKCOLOR       = (WM_USER + 19),
    TTM_SETTIPTEXTCOLOR     = (WM_USER + 20),
    TTM_GETDELAYTIME        = (WM_USER + 21),
    TTM_GETTIPBKCOLOR       = (WM_USER + 22),
    TTM_GETTIPTEXTCOLOR     = (WM_USER + 23),
    TTM_SETMAXTIPWIDTH      = (WM_USER + 24),
    TTM_GETMAXTIPWIDTH      = (WM_USER + 25),
    TTM_SETMARGIN           = (WM_USER + 26),
    TTM_GETMARGIN           = (WM_USER + 27),
    TTM_POP                 = (WM_USER + 28),
    TTM_UPDATE              = (WM_USER + 29),

    TTN_FIRST               = -520,
    TTN_GETDISPINFO         = (TTN_FIRST - 0),
    TTN_GETDISPINFOW        = (TTN_FIRST - 10),
    TTN_SHOW                = (TTN_FIRST - 1),
    TTN_POP                 = (TTN_FIRST - 2),
    TTN_NEEDTEXT            = TTN_GETDISPINFO,

    WH_CALLWNDPROC = 4,
    WH_CALLWNDPROCRET = 12,
    WH_CBT = 5,
    WH_DEBUG = 9,
    WH_GETMESSAGE = 3,
    WH_JOURNALPLAYBACK = 1,
    WH_JOURNALRECORD = 0,
    WH_KEYBOARD = 2,
    WH_MOUSE = 7,
    WH_MSGFILTER = -1,
    WH_SHELL = 10,
    WH_SYSMSGFILTER = 6,
    WH_MIN = -1,
    WH_FOREGROUNDIDLE = 11,

    PAGESETUPDLG_lStructSize        = w32allot( Long ),
    PAGESETUPDLG_hwndOwner          = w32allot( Long ),
    PAGESETUPDLG_hDevMode           = w32allot( Hndl ),
    PAGESETUPDLG_pDevMode           = w32allotted_handle(PAGESETUPDLG_hDevMode),
    PAGESETUPDLG_hDevNames          = w32allot( Hndl ),
    PAGESETUPDLG_pDevNames          = w32allotted_handle(PAGESETUPDLG_hDevNames),
    PAGESETUPDLG_Flags              = w32allot( Long ),
    PAGESETUPDLG_ptPaperSize        = w32allot( SIZEOF_POINT ),
    PAGESETUPDLG_rtMinMargin        = w32allot( SIZEOF_RECT ),
    PAGESETUPDLG_rtMargin           = w32allot( SIZEOF_RECT ),
    PAGESETUPDLG_hInstance          = w32allot( Long ),
    PAGESETUPDLG_lCustData          = w32allot( Long ),
    PAGESETUPDLG_lpfnPageSetupHook  = w32allot( Long ),
    PAGESETUPDLG_lpfnPagePaintHood  = w32allot( Long ),
    PAGESETUPDLG_lpPageSetupTemplateName    = w32allot( Long ),
    PAGESETUPDLG_hPageSetupTemplate = w32allot( Hndl ),
    PAGESETUPDLG_pPageSetupTemplate = w32allotted_handle(PAGESETUPDLG_hPageSetupTemplate),
    SIZEOF_PAGESETUPDLG             = w32allotted_size(),

    DEVNAMES_wDriverOffset          = w32allot( Word ),
    DEVNAMES_wDeviceOffset          = w32allot( Word ),
    DEVNAMES_wOutputOffset          = w32allot( Word ),
    SIZEOF_DEVNAMES                 = w32allotted_size(),

    WM_PSD_ENVSTAMPRECT = 1029,
    WM_PSD_FULLPAGERECT = 1025,
    WM_PSD_GREEKTEXTRECT = 1028,
    WM_PSD_MARGINRECT = 1027,
    WM_PSD_MINMARGINRECT = 1026,
    WM_PSD_PAGESETUPDLG = 1024,
    WM_PSD_YAFULLPAGERECT = 1030,

    PSD_DEFAULTMINMARGINS = 0,
    PSD_DISABLEMARGINS = 16,
    PSD_DISABLEORIENTATION = 256,
    PSD_DISABLEPAGEPAINTING = 524288,
    PSD_DISABLEPAPER = 512,
    PSD_DISABLEPRINTER = 32,
    PSD_ENABLEPAGEPAINTHOOK = 262144,
    PSD_ENABLEPAGESETUPHOOK = 8192,
    PSD_ENABLEPAGESETUPTEMPLATE = 32768,
    PSD_ENABLEPAGESETUPTEMPLATEHANDLE = 131072,
    PSD_INHUNDREDTHSOFMILLIMETERS = 8,
    PSD_INTHOUSANDTHSOFINCHES = 4,
    PSD_INWININIINTLMEASURE = 0,
    PSD_MARGINS = 2,
    PSD_MINMARGINS = 1,
    PSD_NOWARNING = 128,
    PSD_RETURNDEFAULT = 1024,
    PSD_SHOWHELP = 2048,

    TBSTATE_CHECKED         = #01,
    TBSTATE_PRESSED         = #02,
    TBSTATE_ENABLED         = #04,
    TBSTATE_HIDDEN          = #08,
    TBSTATE_INDETERMINATE   = #10,
    TBSTATE_WRAP            = #20,
    TBSTATE_ELLIPSES        = #40,
    TBSTATE_MARKED          = #80,

    TBSTYLE_BUTTON          = #0000,
    TBSTYLE_SEP             = #0001,
    TBSTYLE_CHECK           = #0002,
    TBSTYLE_GROUP           = #0004,
    TBSTYLE_CHECKGROUP      = w32or_all({TBSTYLE_GROUP ,TBSTYLE_CHECK}),
    TBSTYLE_DROPDOWN        = #0008,
    TBSTYLE_AUTOSIZE        = #0010,
    TBSTYLE_NOPREFIX        = #0020,

    TBSTYLE_TOOLTIPS        = #0100,
    TBSTYLE_WRAPABLE        = #0200,
    TBSTYLE_ALTDRAG         = #0400,
    TBSTYLE_FLAT            = #0800,
    TBSTYLE_LIST            = #1000,
    TBSTYLE_CUSTOMERASE     = #2000,
    TBSTYLE_REGISTERDROP    = #4000,
    TBSTYLE_TRANSPARENT     = #8000,
    TBSTYLE_EX_DRAWDDARROWS = #0001,

    TBADDBITMAP_hInst           = w32allot( Long ),
    TBADDBITMAP_nID             = w32allot( UInt ),
    SIZEOF_TBADDBITMAP          = w32allotted_size(),

    TBSAVEPARAMS_hkr            = w32allot( Long ),
    TBSAVEPARAMS_pszSubKey      = w32allot( Lpsz ),
    TBSAVEPARAMS_pszValueName   = w32allot( Lpsz ),
    SIZEOF_TBSAVEPARAMS         = w32allotted_size(),

    TBINSERTMARK_iButton        = w32allot( Long ),
    TBINSERTMARK_dwFlags        = w32allot( Long ),
    SIZEOF_TBINSERTMARK         = w32allotted_size(),

    TBIMHT_AFTER                = 1,
    TBIMHT_BACKGROUND           = 2,

    TBBUTTON_iBitmap            = w32allot( Long ),
    TBBUTTON_idCommand          = w32allot( Long ),
    TBBUTTON_fsState            = w32allot( Byte ),
    TBBUTTON_fsStyle            = w32allot( Byte ),
    TBBUTTON_bReserved          = w32allot( {2, Byte} ),
    TBBUTTON_dwData             = w32allot( Long ),
    TBBUTTON_iString            = w32allot( Long ),
    SIZEOF_TBBUTTON             = w32allotted_size(),

    TBBUTTONINFO_cbSize         = w32allot( UInt ),
    TBBUTTONINFO_dwMask         = w32allot( Long ),
    TBBUTTONINFO_idCommand      = w32allot( Long ),
    TBBUTTONINFO_iImage         = w32allot( Long ),
    TBBUTTONINFO_fsState        = w32allot( Byte ),
    TBBUTTONINFO_fsStyle        = w32allot( Byte ),
    TBBUTTONINFO_cx             = w32allot( Word ),
    TBBUTTONINFO_lParam         = w32allot( Long ),
    TBBUTTONINFO_pszText        = w32allot( Lpsz ),
    TBBUTTONINFO_cchText        = w32allot( Long ),
    SIZEOF_TBBUTTONINFO         = w32allotted_size(),

    TBIF_IMAGE              = #00000001,
    TBIF_TEXT               = #00000002,
    TBIF_STATE              = #00000004,
    TBIF_STYLE              = #00000008,
    TBIF_LPARAM             = #00000010,
    TBIF_COMMAND            = #00000020,
    TBIF_SIZE               = #00000040,

    NMTOOLBAR_hdr           = w32allot( SIZEOF_NMHDR ),
    NMTOOLBAR_iItem         = w32allot( Long ),
    NMTOOLBAR_tbButton      = w32allot( SIZEOF_TBBUTTON ),
    NMTOOLBAR_cchText       = w32allot( Long ),
    NMTOOLBAR_pszText       = w32allot( Lpsz ),
    SIZEOF_NMTOOLBAR        = w32allotted_size(),

    TBDDRET_DEFAULT         = 0,
    TBDDRET_NODEFAULT       = 1,
    TBDDRET_TREATPRESSED    = 2,


    TB_ENABLEBUTTON         = (WM_USER + 1),
    TB_CHECKBUTTON          = (WM_USER + 2),
    TB_PRESSBUTTON          = (WM_USER + 3),
    TB_HIDEBUTTON           = (WM_USER + 4),
    TB_INDETERMINATE        = (WM_USER + 5),
    TB_MARKBUTTON           = (WM_USER + 6),
    TB_ISBUTTONENABLED      = (WM_USER + 9),
    TB_ISBUTTONCHECKED      = (WM_USER + 10),
    TB_ISBUTTONPRESSED      = (WM_USER + 11),
    TB_ISBUTTONHIDDEN       = (WM_USER + 12),
    TB_ISBUTTONINDETERMINATE= (WM_USER + 13),
    TB_ISBUTTONHIGHLIGHTED  = (WM_USER + 14),
    TB_SETSTATE             = (WM_USER + 17),
    TB_GETSTATE             = (WM_USER + 18),
    TB_ADDBITMAP            = (WM_USER + 19),
    TB_ADDBUTTONS           = (WM_USER + 20),
    TB_INSERTBUTTON         = (WM_USER + 21),
    TB_DELETEBUTTON         = (WM_USER + 22),
    TB_GETBUTTON            = (WM_USER + 23),
    TB_BUTTONCOUNT          = (WM_USER + 24),
    TB_COMMANDTOINDEX       = (WM_USER + 25),
    TB_SAVERESTORE          = (WM_USER + 26),
    TB_CUSTOMIZE            = (WM_USER + 27),
    TB_ADDSTRING            = (WM_USER + 28),
    TB_GETITEMRECT          = (WM_USER + 29),
    TB_BUTTONSTRUCTSIZE     = (WM_USER + 30),
    TB_SETBUTTONSIZE        = (WM_USER + 31),
    TB_SETBITMAPSIZE        = (WM_USER + 32),
    TB_AUTOSIZE             = (WM_USER + 33),
    TB_GETTOOLTIPS          = (WM_USER + 35),
    TB_SETTOOLTIPS          = (WM_USER + 36),
    TB_SETPARENT            = (WM_USER + 37),
    TB_SETROWS              = (WM_USER + 39),
    TB_GETROWS              = (WM_USER + 40),
    TB_SETCMDID             = (WM_USER + 42),
    TB_CHANGEBITMAP         = (WM_USER + 43),
    TB_GETBITMAP            = (WM_USER + 44),
    TB_GETBUTTONTEXT        = (WM_USER + 45),
    TB_REPLACEBITMAP        = (WM_USER + 46),
    TB_SETINDENT            = (WM_USER + 47),
    TB_SETIMAGELIST         = (WM_USER + 48),
    TB_GETIMAGELIST         = (WM_USER + 49),
    TB_LOADIMAGES           = (WM_USER + 50),
    TB_GETRECT              = (WM_USER + 51),
    TB_SETHOTIMAGELIST      = (WM_USER + 52),
    TB_GETHOTIMAGELIST      = (WM_USER + 53),
    TB_SETDISABLEDIMAGELIST = (WM_USER + 54),
    TB_GETDISABLEDIMAGELIST = (WM_USER + 55),
    TB_SETSTYLE             = (WM_USER + 56),
    TB_GETSTYLE             = (WM_USER + 57),
    TB_GETBUTTONSIZE        = (WM_USER + 58),
    TB_SETBUTTONWIDTH       = (WM_USER + 59),
    TB_SETMAXTEXTROWS       = (WM_USER + 60),
    TB_GETTEXTROWS          = (WM_USER + 61),
    TB_GETOBJECT            = (WM_USER + 62),
    TB_GETBUTTONINFO        = (WM_USER + 65),
    TB_SETBUTTONINFO        = (WM_USER + 66),
    TB_GETHOTITEM           = (WM_USER + 71),
    TB_SETHOTITEM           = (WM_USER + 72),
    TB_SETANCHORHIGHLIGHT   = (WM_USER + 73),
    TB_GETANCHORHIGHLIGHT   = (WM_USER + 74),
    TB_MAPACCELERATOR       = (WM_USER + 78),

    TBN_FIRST = -700,
    TBN_BEGINADJUST = -703,
    TBN_BEGINDRAG = -701,
    TBN_CUSTHELP = -709,
    TBN_ENDADJUST = -704,
    TBN_ENDDRAG = -702,
    TBN_GETBUTTONINFOW = -720,
    TBN_GETBUTTONINFO = -700,
    TBN_QUERYDELETE = -707,
    TBN_QUERYINSERT = -706,
    TBN_RESET = -705,
    TBN_TOOLBARCHANGE = -708,
    TBN_LAST = -720,


    CBEIF_TEXT              = #00000001,
    CBEIF_IMAGE             = #00000002,
    CBEIF_SELECTEDIMAGE     = #00000004,
    CBEIF_OVERLAY           = #00000008,
    CBEIF_INDENT            = #00000010,
    CBEIF_LPARAM            = #00000020,
    CBEIF_DI_SETITEM        = #10000000,

    COMBOBOXEXITEM_mask             = w32allot( UInt ),
    COMBOBOXEXITEM_iItem            = w32allot( Long ),
    COMBOBOXEXITEM_pszText          = w32allot( Lpsz ),
    COMBOBOXEXITEM_cchTextMax       = w32allot( Long ),
    COMBOBOXEXITEM_iImage           = w32allot( Long ),
    COMBOBOXEXITEM_iSelectedImage   = w32allot( Long ),
    COMBOBOXEXITEM_iOverlay         = w32allot( Long ),
    COMBOBOXEXITEM_iIndent          = w32allot( Long ),
    COMBOBOXEXITEM_lParam           = w32allot( Long ),
    SIZEOF_COMBOBOXEXITEM           = w32allotted_size(),

    CBEM_INSERTITEM         = (WM_USER + 1),
    CBEM_SETIMAGELIST       = (WM_USER + 2),
    CBEM_GETIMAGELIST       = (WM_USER + 3),
    CBEM_GETITEM            = (WM_USER + 4),
    CBEM_SETITEM            = (WM_USER + 5),
    CBEM_DELETEITEM         = CB_DELETESTRING,
    CBEM_GETCOMBOCONTROL    = (WM_USER + 6),
    CBEM_GETEDITCONTROL     = (WM_USER + 7),
    CBEM_SETEXSTYLE         = (WM_USER + 8),
    CBEM_SETEXTENDEDSTYLE   = (WM_USER + 14),
    CBEM_GETEXSTYLE         = (WM_USER + 9),
    CBEM_GETEXTENDEDSTYLE   = (WM_USER + 9),
    CBEM_HASEDITCHANGED     = (WM_USER + 10),
    CBEM_INSERTITEMW        = (WM_USER + 11),
    CBEM_SETITEMW           = (WM_USER + 12),
    CBEM_GETITEMW           = (WM_USER + 13),
    CBES_EX_NOEDITIMAGE          = #00000001,
    CBES_EX_NOEDITIMAGEINDENT    = #00000002,
    CBES_EX_PATHWORDBREAKPROC    = #00000004,
    CBES_EX_NOSIZELIMIT          = #00000008,
    CBES_EX_CASESENSITIVE        = #00000010,


-------------------------------------------------
    GETTEXTLENGTHEX_flags        = w32allot( DWord ),
    GETTEXTLENGTHEX_codepage     = w32allot( UInt ),
    SIZEOF_GETTEXTLENGTHEX       = w32allotted_size(),

    GTL_DEFAULT           = 0,
    GTL_USECRLF           = 1,
    GTL_PRECISE           = 2,
    GTL_CLOSE             = 4,
    GTL_NUMCHARS          = 8,
    GTL_NUMBYTES          = 16,

-------------------------------------------------
    GETTEXTEX_cb           = w32allot( DWord ),
    GETTEXTEX_flags        = w32allot( DWord ),
    GETTEXTEX_codepage     = w32allot( UInt ),
    GETTEXTEX_lpDefaultChar = w32allot( Ptr ),
    GETTEXTEX_lpUsedDefChar = w32allot( Ptr ),
    SIZEOF_GETTEXTEX       = w32allotted_size(),

-------------------------------------------------
    WINDOWINFO_cbSize           = w32allot( DWord ),
    WINDOWINFO_WLeft            = w32allot( Long ),
    WINDOWINFO_WTop             = w32allot( Long ),
    WINDOWINFO_WRight           = w32allot( Long ),
    WINDOWINFO_WBottom          = w32allot( Long ),
    WINDOWINFO_CLeft            = w32allot( Long ),
    WINDOWINFO_CTop             = w32allot( Long ),
    WINDOWINFO_CRight           = w32allot( Long ),
    WINDOWINFO_CBottom          = w32allot( Long ),
    WINDOWINFO_Style            = w32allot( UInt ),
    WINDOWINFO_ExStyle          = w32allot( UInt ),
    WINDOWINFO_WindowStatus     = w32allot( UInt ),
    WINDOWINFO_xWindowBorders   = w32allot( UInt ),
    WINDOWINFO_yWindowBorders   = w32allot( UInt ),
    WINDOWINFO_WindowType       = w32allot( Word ),
    WINDOWINFO_CreatorVersion   = w32allot( Word),
    SIZEOF_WINDOWINFO           = w32allotted_size(),

    -- MenuItem Info
    MENUITEMINFO_cbSize     = w32allot(UInt),
    MENUITEMINFO_fMask      = w32allot(UInt),
    MENUITEMINFO_fType      = w32allot(UInt),
    MENUITEMINFO_fState     = w32allot(UInt),
    MENUITEMINFO_wID        = w32allot(UInt),
    MENUITEMINFO_hSubMenu   = w32allot(UInt),
    MENUITEMINFO_hbmpChecked = w32allot(UInt),
    MENUITEMINFO_hbmpUnchecked = w32allot(UInt),
    MENUITEMINFO_dwItemData = w32allot(UInt),
    MENUITEMINFO_dwTypeData = w32allot(Lpsz),
    MENUITEMINFO_cch        = w32allot(UInt),
    MENUITEMINFO_hbmpItem   = w32allot(UInt),
    SIZEOF_MENUITEMINFO     = w32allotted_size(),

    MIIM_STATE       = #00000001,
    MIIM_ID          = #00000002,
    MIIM_SUBMENU     = #00000004,
    MIIM_CHECKMARKS  = #00000008,
    MIIM_TYPE        = #00000010,
    MIIM_DATA        = #00000020,
    MIIM_STRING      = #00000040,
    MIIM_BITMAP      = #00000080,
    MIIM_FTYPE       = #00000100,

    GT_DEFAULT           = 0,
    GT_USECRLF           = 1,
    GT_SELECTION         = 2,

    CP_ACP               = 0, -- Use ANSI codepage
    CP_UNICODE           = 1200, -- Use Unicode codepage

    SWP_NOSIZE          = #0001,
    SWP_NOMOVE          = #0002,
    SWP_NOZORDER        = #0004,
    SWP_NOREDRAW        = #0008,
    SWP_NOACTIVATE      = #0010,
    SWP_FRAMECHANGED    = #0020,
    SWP_SHOWWINDOW      = #0040,
    SWP_HIDEWINDOW      = #0080,
    SWP_NOCOPYBITS      = #0100,
    SWP_NOOWNERZORDER   = #0200,
    SWP_NOSENDCHANGING  = #0400,
    SWP_DRAWFRAME       = SWP_FRAMECHANGED,
    SWP_NOREPOSITION    = SWP_NOOWNERZORDER,
    SWP_DEFERERASE      = #2000,
    SWP_ASYNCWINDOWPOS  = #4000,
    SWP_UPDATECACHE     = SWP_NOSIZE+SWP_NOMOVE+SWP_NOZORDER+SWP_FRAMECHANGED,
    HWND_TOP            = 0,
    HWND_BOTTOM         = 1,
    HWND_TOPMOST        = -1,
    HWND_NOTOPMOST      = -2,

-----------------------------------------------------------------------------
-- common control styles
    CCS_ADJUSTABLE      = #20,
    CCS_BOTTOM          = #3,
    CCS_NODIVIDER       = #40,
    CCS_NOMOVEY         = #2,
    CCS_NOPARENTALIGN   = #8,
    CCS_NORESIZE        = #4,
    CCS_TOP             = #1,
    ANIMATE_CLASSA      = "SysAnimate32",
    HOTKEY_CLASSA       = "msctls_hotkey32",
    PROGRESS_CLASSA     = "msctls_progress32",
    STATUSCLASSNAMEA    = "msctls_statusbar32",
    TOOLBARCLASSNAMEA   = "ToolbarWindow32",
    TOOLTIPS_CLASSA     = "tooltips_class32",
    TRACKBAR_CLASSA     = "msctls_trackbar32",
    UPDOWN_CLASSA       = "msctls_updown32",
    WC_HEADERA          = "SysHeader32",
    WC_LISTVIEWA        = "SysListView32",
    WC_LISTVIEW         = WC_LISTVIEWA,
    WC_TABCONTROLA      = "SysTabControl32",
    WC_TREEVIEWA        = "SysTreeView32",
    MONTHCAL_CLASS      = "SysMonthCal32",
    REBARCLASSNAME      = "ReBarWindow32",
    ANIMATE_CLASS       = "SysAnimate32",
    DATETIMEPICK_CLASS  = "SysDateTimePick32",
    WC_PAGESCROLLER     = "SysPager",
    WC_NATIVEFONTCTL    = "NativeFontCtl",
    WC_COMBOBOXEX       = "ComboBoxEx32",

-----------------------------------------------------------------------------
-- attributes for EZ_FONTS
    Normal          = 0,
    Bold            = 1,
    Italic          = 2,
    Underline       = 4,
    Strikeout       = 8,

-----------------------------------------------------------------------------
-- attributes for showWindow
--  Normal          = 0,
    Modal           = -1

constant
    Dialog          = -2

global constant
    Minimize        = SW_SHOWMINIMIZED,
    Maximize        = SW_SHOWMAXIMIZED,
    Minimized       = SW_SHOWMINIMIZED,
    Maximized       = SW_SHOWMAXIMIZED,

-----------------------------------------------------------------------------
-- attributes for shift keys
    NoShift         = #00,
    ShiftMask       = #01,           -- shift key is held down
    ControlMask     = #02,           -- control key is held down
    AltMask         = #04,           -- alt key is held down
    KeyMask         = #0F,
    LeftBtnMask     = #10,           -- Left Button down
    RightBtnMask    = #20,           -- Right Button Down
    MiddleBtnMask   = #40,           -- Middle Button down
    BtnMask         = #F0

-----------------------------------------------------------------------------
constant
    WindowColor                 = w32Color_BTNFACE

-----------------------------------------------------------------------------
--/topic System Attributes
--/func getSysColor( window, color )
--/ret ATOM:Returns the RGB value of the specified system color.
--/desc Return atom with value of a system color.
-- The system colors in Windows are:
--
-- /li /b COLOR_SCROLLBAR
-- /li /b COLOR_BACKGROUND
-- /li /b COLOR_DESKTOP
-- /li /b COLOR_ACTIVECAPTION
-- /li /b COLOR_INACTIVECAPTION
-- /li /b COLOR_MENU
-- /li /b COLOR_WINDOW
-- /li /b COLOR_WINDOWFRAME
-- /li /b COLOR_MENUTEXT
-- /li /b COLOR_WINDOWTEXT
-- /li /b COLOR_CAPTIONTEXT
-- /li /b COLOR_ACTIVEBORDER
-- /li /b COLOR_INACTIVEBORDER
-- /li /b COLOR_APPWORKSPACE
-- /li /b COLOR_HIGHLIGHT
-- /li /b COLOR_HIGHLIGHTTEXT
-- /li /b COLOR_BTNFACE
-- /li /b COLOR_BTNSHADOW
-- /li /b COLOR_GRAYTEXT
-- /li /b COLOR_BTNTEXT
-- /li /b COLOR_INACTIVECAPTIONTEXT
-- /li /b COLOR_BTNHIGHLIGHT
-- /li /b COLOR_3DDKSHADOW
-- /li /b COLOR_3DLIGHT
-- /li /b COLOR_INFOTEXT
-- /li /b COLOR_INFOBK
-- /li /b COLOR_HOTLIGHT
-- /li /b COLOR_GRADIENTACTIVECAPTION
-- /li /b COLOR_GRADIENTINACTIVECAPTION
-- /li /b COLOR_MENUHILIGHT
-- /li /b COLOR_MENUBAR
--
-- Example:
--
--/code
--          -- Set the window to the button color
--          /setWindowBackColor( MyWindow, /getSysColor( COLOR_BTNFACE ) )
--/endcode
global function getSysColor( atom winPart )

    -- returns the color associated with a graphical element
    -- use the COLOR_xxxx constants
    if winPart < 0 then
        winPart = -winPart-1
    end if
    return w32Func( xGetSysColor, {winPart} )

end function

function UseColor(atom x)
    x = floor(x)
    if x < 0 then
        return w32Func( xGetSysColor, {-x-1} )
    else
        return and_bits(#FFFFFF, x)
    end if
end function

-----------------------------------------------------------------------------
--/topic Graphics
--/func rgb( integer red, integer green, integer blue )
--/desc Convert a {red, green, blue} tuple into a 24-bit color value.
--/ret Atom: representing the color tuple.
-- Converts the /i red, /i green and /i blue values (ranging from 0-255)
-- into an atom representing that color tuple. Each value represents the
-- relative brightness of each primary color element.
--
-- Example:
-- /code
--      -- set the pen color to a random blue
--      /setPenColor( MyControl, /rgb( 0, 0, rand( 255 )
-- /endcode

global function rgb( integer r, integer g, integer b )
    return r + g * 256 + b * 65536
end function


-----------------------------------------------------------------------------
-- Classes of Windows: Base Classes
-----------------------------------------------------------------------------
global constant
    WINDOW          = 0,    -- window
    BUTTON          = 1,    -- button
    COMBO           = 2,    -- combo box
    EDIT            = 3,    -- edit
    LISTBOX         = 4,    -- list box
    SCROLLBAR       = 5,    -- scroll bar
    STATIC          = 6,    -- static
    MENU            = 7,    -- menu
    POPUP           = 8,    -- popup menu
    MENUITEM        = 9,    -- menu item
    PIXMAP          = 10,   -- pixmap,
    COMMON_CONTROL  = 11   -- common controls,


-----------------------------------------------------------------------------
-- Classes of Windows: Used for internal identification of window type
-----------------------------------------------------------------------------

constant Classes = series:next_number(0)
global constant
    Window          = series:next_number(Classes),

    PushButton      = series:next_number(Classes),
    CommandButton   = PushButton,
    Button          = PushButton,

    DefPushButton   = series:next_number(Classes),
    DefButton       = DefPushButton,

    CancelButton    = series:next_number(Classes),

    CheckBox        = series:next_number(Classes),

    TriCheckBox     = series:next_number(Classes),

    Radio           = series:next_number(Classes),
    RadioButton     = Radio,

    Group           = series:next_number(Classes),
    GroupBox        = Group,

    List            = series:next_number(Classes),
    ListBox         = List,

    SortedList      = series:next_number(Classes),

    Combo           = series:next_number(Classes),
    ComboBox        = Combo,

    SortedCombo     = series:next_number(Classes),

    SimpleCombo     = series:next_number(Classes),

    DropDownList    = series:next_number(Classes),

    EditText        = series:next_number(Classes),
    EditBox         = EditText,
    TextBox         = EditText,
    SleText         = EditText,

    MleText         = series:next_number(Classes),

    LText           = series:next_number(Classes),
    Label           = LText,

    RText           = series:next_number(Classes),

    CText           = series:next_number(Classes),

    HScroll         = series:next_number(Classes),

    VScroll         = series:next_number(Classes),

    Icon            = series:next_number(Classes),

    Bitmap          = series:next_number(Classes),

    Menu            = series:next_number(Classes),

    Popup           = series:next_number(Classes),

    MenuItem        = series:next_number(Classes),

    MenuSpacer      = series:next_number(Classes),

    Pixmap          = series:next_number(Classes),

    ToolBar         = series:next_number(Classes),

    StatusBar       = series:next_number(Classes),

    PictureButton   = series:next_number(Classes),

    ToggleButton    = series:next_number(Classes),

    TogglePicture   = series:next_number(Classes),

    HTrackBar       = series:next_number(Classes),

    VTrackBar       = series:next_number(Classes),

    TabControl      = series:next_number(Classes),

    TabItem         = series:next_number(Classes),

    ProgressBar     = series:next_number(Classes),

    ListView        = series:next_number(Classes),

    ImageList       = series:next_number(Classes),

    TreeView        = series:next_number(Classes),

    RichEdit        = series:next_number(Classes),

    MonthCalendar   = series:next_number(Classes),

    UpDown          = series:next_number(Classes),

    ReBar           = series:next_number(Classes),

    ReBarBand       = series:next_number(Classes),

    ToolTip         = series:next_number(Classes),

    FlatToolBar     = series:next_number(Classes),

    SepButton       = series:next_number(Classes),

    ComboBoxEx      = series:next_number(Classes)


-- hidden classes
constant
    Screen_         = series:next_number(Classes),
    Printer_        = series:next_number(Classes)

integer NumClasses
        NumClasses = series:current_number(Classes)

sequence vEventCodes
sequence vWinIconNames
sequence vEventNamesUpper
sequence vEventNames
sequence vControlTypes
sequence vControlNames
sequence vControlRID
constant
    w32CRID       = series:next_number(0),
    kCRID_Create  = series:next_number(w32CRID),
    kCRID_Destroy = series:next_number(w32CRID),
    kCRID_Process = series:next_number(w32CRID),
    kCRID_Control = series:next_number(w32CRID),
    kCRID_SIZEOF  = series:current_number(w32CRID)

sequence vWinExFlagValues
sequence vWinFlagValues
sequence vWinExFlagNames
sequence vWinFlagNames
sequence vColorNames
sequence vColorValues
sequence vLVExFlagValues
sequence vLVExFlagNames

global integer
    Screen,         -- id of screen
    Printer         -- id of printer


-----------------------------------------------------------------------------
-- names of indexes for window_change
constant
    MY_SMALLCHANGE      = 1,        -- scroll bar line up/down amount
    MY_LARGECHANGE      = 2         -- scroll bar page up/down amount


-----------------------------------------------------------------------------
sequence
    className,      -- class name
    classType,      -- message class
    classStyle,     -- attributes
    classStyleEx,   -- extended class attributes
    classAttr,      -- Attributes used internally by win32lib
    classBGColor,   -- Default background color
    classDefPointer,-- Default shape for Mouse Pointer
    classFGColor,   -- Default foregrond color
    vWindowClassStyle -- The styles used in registering a Window class.

    vWindowClassStyle = {CS_DBLCLKS}--CS_HREDRAW, CS_VREDRAW }

    className     = repeat( -1, NumClasses )
    classType     = repeat( -1, NumClasses )
    classStyle    = repeat( 0, NumClasses )
    classStyleEx  = repeat( 0, NumClasses )
    classAttr     = repeat( 0, NumClasses )
    classDefPointer = repeat(IDC_ARROW, NumClasses )
    classBGColor  = repeat( WindowColor, NumClasses )
    classFGColor  = repeat( w32Color_WINDOWTEXT, NumClasses )

-- special win32lib BG color values
global constant
    w32BGTransparent = {},  -- Takes on the parent's BG color.
    w32WinDefColor   = {{}} -- Use Windows default Color

-- win32lib class attribute flags.
global constant
    w32Clickable  = #0001,  -- Can allow mouseup detection to fire onClick handler
    w32NoConv     = #0002,  -- Must not allow relative dimension conversions
    w32PictCtrl   = #0004,  -- Controls that pass bitmaps in the flags
    w32CtrlTab    = #0008,  -- CTRL-tabkey must be used to move tabstops
    w32AutoSelect = #0010,  -- Control's data gets selected when it gets focus
    w32AutoCancel = #0020,  -- Control has auto hotkey set to ESCAPE
    w32NoRenderDisabled = #0040, -- Control is not shown with different BG when disabled.
    w32UseSubProc = #0080,  -- If using default BG, use the subclassed proc rather than the default proc.
    w32OwnerId    = #0100,  -- Supplies owner's id in createEx() API call
    w32Virtual    = #0200,  -- This is a virtual control. The effective parent is really the grandparent.
    w32Toolbar    = #0400,  -- This acts as a toolbar on top of client area
    w32Statusbar  = #0800,  -- This acts as a statusbar on bottom of client area
    w32HasChildren= #1000   -- This type of control can have children

constant vAutoSelect = 0 & "AutoSelect"
constant vCanFocus = 0 & "CanFocus"
integer AutoReBarSizing AutoReBarSizing = w32False

    classAttr [Screen_] = w32NoConv
    classAttr [Printer_] = w32NoConv


-----------------------------------------------------------------------------
--/topic Controls
--/const Window
--/desc A Window is a normal Win32 window.

    className[ Window ] = "" -- To be determined at creation time.
    classType[ Window ] = WINDOW
    classStyle[ Window ] = WS_OVERLAPPEDWINDOW
    classStyleEx [ Window ] = WS_EX_ACCEPTFILES
    classAttr [ Window ] = w32Clickable


-----------------------------------------------------------------------------
--/topic Controls
--/const PushButton
--/desc Command button control.
-- A PushButton is a normal push button (sometimes called
-- /i command /i button). A PushButton has the following attributes:
--
-- /li /b WS_CHILD: child control of the parent
-- /li /b WS_VISIBLE: it is visible
-- /li /b BS_PUSHBUTTON: button style is pushbutton
-- /li /b WS_TABSTOP: the control can be tabbed to

    className[ PushButton ] = "button"
    classType[ PushButton ] = BUTTON
    classStyle[ PushButton ] = w32or_all( { WS_CLIPPINGCHILD,
	    	            WS_VISIBLE,
	    	            BS_PUSHBUTTON,
	    	            WS_TABSTOP} )

    classAttr [ PushButton ] = 0
    classBGColor [ PushButton ] = w32BGTransparent

-----------------------------------------------------------------------------
--/topic Controls
--/const DefPushButton
--/desc Default command button control.
-- A DefPushButton is a /PushButton, but
-- is displayed with an extra border indicating that this button
-- will automatically be selected if the user presses the Return
-- button on the keyboard.
--
-- A DefPushButton has the following attributes:
--
-- /li /b WS_CHILD: child control of the parent
-- /li /b WS_VISIBLE: it is visible
-- /li /b BS_DEFPUSHBUTTON: button style is default pushbutton
-- /li /b WS_TABSTOP: the control can be tabbed to

    className[ DefPushButton ] = "button"
    classType[ DefPushButton ] = BUTTON
    classStyle[ DefPushButton ] = w32or_all( {     WS_CLIPPINGCHILD,
	    	    	    WS_VISIBLE,
	    	    	    BS_DEFPUSHBUTTON,
	    	    	    WS_TABSTOP} )
    classAttr [ DefPushButton ] = w32UseSubProc

-----------------------------------------------------------------------------
--/topic Controls
--/const CancelButton
--/desc Command button that reacts to the Escape key.
-- A CancelButton is a /PushButton, but
-- is displayed with italic font indicating that this button
-- will automatically be selected if the user presses the Escape
-- key.
--
-- A CancelButton has the following attributes:
--
-- /li /b WS_CHILD: child control of the parent
-- /li /b WS_VISIBLE: it is visible
-- /li /b WS_TABSTOP: the control can be tabbed to

    className[ CancelButton ] = "button"
    classType[ CancelButton ] = BUTTON
    classStyle[ CancelButton ] = w32or_all( {     WS_CLIPPINGCHILD,
	    	    	    WS_VISIBLE,
	    	    	    BS_PUSHBUTTON,
	    	    	    WS_TABSTOP} )
    classAttr [ CancelButton ] = w32AutoCancel

-----------------------------------------------------------------------------
--/topic Controls
--/const CheckBox
--/desc CheckBox control.
-- A CheckBox is a button that can be toggled on or off.
-- It appears as a box with a label to the side. Clicking the
-- checkbox causes an 'X' to be toggled in the box.
--
-- A CheckBox has the following attributes:
--
-- /li /b WS_CHILD: child control of the parent
-- /li /b WS_VISIBLE: it is visible
-- /li /b BS_AUTOCHECKBOX: checkbox, default window handling
-- /li /b WS_TABSTOP: the control can be tabbed to

    className[ CheckBox ] = "button"
    classType[ CheckBox ] = BUTTON
    classStyle[ CheckBox ] = w32or_all( {  WS_CLIPPINGCHILD,
	    	        WS_VISIBLE,
	    	        BS_AUTOCHECKBOX,
	    	        WS_TABSTOP,
                    BS_NOTIFY} )
    classBGColor[ CheckBox ] = w32BGTransparent
    classAttr [ CheckBox ] = w32UseSubProc

-----------------------------------------------------------------------------
--/topic Controls
--/const TriCheckBox
--/desc Three state checkbox control.
-- A TriCheckBox is similar to a /CheckBox, but it
-- has three states: on, off, or dim.
--
-- A TriCheckBox has the following attributes:
--
-- /li /b WS_CHILD: child control of the parent
-- /li /b WS_VISIBLE: it is visible
-- /li /b BS_AUTO3STATE: tri-state check box
-- /li /b WS_TABSTOP: the control can be tabbed to

    className[ TriCheckBox ] = "button"
    classType[ TriCheckBox ] = BUTTON
    classStyle[ TriCheckBox ] = w32or_all( {   WS_CLIPPINGCHILD,
	    	            WS_VISIBLE,
	    	            BS_AUTO3STATE,
	    	            WS_TABSTOP,
                        BS_NOTIFY} )
    classAttr [ TriCheckBox ] = w32UseSubProc
    classBGColor[ TriCheckBox ] = w32BGTransparent


-----------------------------------------------------------------------------
--/topic Controls
--/const Radio
--/desc Radio button control.
-- A Radio is similar to a /CheckBox, in functionality.
-- Like a checkbox, it can be toggled on and off. However, radio buttons
-- are grouped controls - if one is toggled on, the rest in the group are
-- toggled off.
--
-- Win32Lib considers a radio button in a group if they are contained
-- by the same /Group control. If there is no /Group control,
-- then all the radio buttons are considered to belong to the same
-- group.
--
-- A Radio has the following attributes:
--
-- /li /b WS_CHILD: child control of the parent
-- /li /b WS_VISIBLE: it is visible
-- /li /b BS_AUTORADIOBUTTON: radio button control
-- /li /b WS_TABSTOP: the control can be tabbed to

    className[ Radio ] = "button"
    classType[ Radio ] = BUTTON
    classStyle[ Radio ] = w32or_all( { WS_CHILD,
	    	        WS_VISIBLE,
	    	        BS_AUTORADIOBUTTON,
	    	        WS_TABSTOP,
                    BS_NOTIFY} )
    classStyleEx[ Radio] = WS_EX_TRANSPARENT
    --classAttr [ Radio ] =  w32UseSubProc
    --classBGColor[ Radio ] = w32BGTransparent

-----------------------------------------------------------------------------
--/topic Controls
--/const Group
--/desc Group control.
-- A Group is a static control, and recieves no events. It's
-- main function is to seperate other controls into groups.
--
-- In addition to providing a visual cue, the group alters the behavior of
-- the /Radio control; all the radio buttons within a single group are
-- considered to belong to the same group.
--
-- When placing controls in groups, it's a good idea to make them
-- children of the Group, instead of children of the Window. If you
-- don't, the Group may end up routing events meant for the control to
-- itself. For example, /onDragAndDrop events will be routed to the
-- Group instead of the child.
--
-- A Group has the following attributes:
--
-- /li /b WS_CHILD: child control of the parent
-- /li /b WS_VISIBLE: it is visible
-- /li /b WS_GROUPBOX: group box control

    className[ Group ] = "button"
    classType[ Group ] = BUTTON
    classStyle[ Group ] = w32or_all( { WS_CHILD, WS_CLIPSIBLINGS,
	    	        WS_VISIBLE,
	    	        BS_GROUPBOX,
	    	        WS_TABSTOP} )
    classAttr [ Group ] = w32Clickable + w32UseSubProc + w32HasChildren
    classStyleEx[ Group ] = WS_EX_TRANSPARENT



-----------------------------------------------------------------------------
--/topic Controls
--/const SortedList
--/desc Sorted list control.
-- A SortedList contains a list of items, arranged in alphabetical
-- order. To have an unsorted list, use the /List control instead.
--
-- A SortedList has the following attributes:
--
-- /li /b WS_CHILD: child control of the parent
-- /li /b WS_VISIBLE: it is visible
-- /li /b LBS_NOTIFY: notify parent of events
-- /li /b LBS_SORT: sort items in list
-- /li /b WS_VSCROLL: attach a vertical scroll bar
-- /li /b WS_BORDER: draw a border on the control
-- /li /b WS_TABSTOP: the control can be tabbed to
-- /li /b WS_EX_CLIENTEDGE: 3D effect
-- /li /b WS_EX_ACCEPTFILES: drag and drop support


    className[ SortedList ] = "listbox"
    classType[ SortedList ] = LISTBOX
    classStyle[ SortedList ] = w32or_all( {    WS_CLIPPINGCHILD,
	    	            WS_VISIBLE,
	    	            LBS_NOTIFY,
	    	            LBS_SORT,
	    	            WS_VSCROLL,
	    	            WS_BORDER,
	    	            WS_TABSTOP} )

    classStyleEx[ SortedList ] = w32or_all( {WS_EX_CLIENTEDGE,
	    	          WS_EX_ACCEPTFILES} )

    classAttr [ SortedList ] = w32Clickable
    classBGColor[ SortedList ] = w32WinDefColor -- w32Color_WINDOW

-----------------------------------------------------------------------------
--/topic Controls
--/const List
--/desc List.
-- A List contains a list of items, arranged in the order that
-- they were placed into the list. To have a sorted list, either sort
-- the items before placing them into the list, or use the /SortedList
-- control.
--
-- A List has the following attributes:
--
-- /li /b WS_CHILD: child control of the parent
-- /li /b WS_VISIBLE: it is visible
-- /li /b LBS_NOTIFY: notify parent of events
-- /li /b WS_VSCROLL: attach a vertical scroll bar
-- /li /b WS_BORDER: draw a border on the control
-- /li /b WS_TABSTOP: the control can be tabbed to
-- /li /b WS_EX_CLIENTEDGE: 3D effect
-- /li /b WS_EX_ACCEPTFILES: drag and drop support

    className[ List ] = "listbox"
    classType[ List ] = LISTBOX
    classStyle[ List ] = w32or_all( {  WS_CLIPPINGCHILD,
	    	        WS_VISIBLE,
	    	        LBS_NOTIFY,
	    	        WS_VSCROLL,
	    	        WS_BORDER,
	    	        WS_TABSTOP} )

    classStyleEx[ List ] = w32or_all( {WS_EX_CLIENTEDGE,
	    	        WS_EX_ACCEPTFILES} )

    classAttr [ List ] = w32Clickable
    classBGColor[ List ] = w32WinDefColor -- w32Color_WINDOW

-----------------------------------------------------------------------------
--/topic Controls
--/const Combo
--/desc Combo box control.
-- A Combo is a combination of an edit control and a list.
-- If you need the items in the combo to be sorted, use a /SortedCombo
-- instead. In addition to being able to select a value from the combo's
-- list, the user can enter their own value as well.
--
-- A Combo has the following attributes:
--
-- /li /b WS_CHILD: child control of the parent
-- /li /b WS_VISIBLE: it is visible
-- /li /b WS_VSCROLL: attach a vertical scroll bar
-- /li /b CBS_DROPDOWN: the list can drop down, like a menu
-- /li /b CBS_HASSTRINGS: contains string values
-- /li /b WS_TABSTOP: the control can be tabbed to

    className[ Combo ] = "combobox"
    classType[ Combo ] = COMBO
    classStyle[ Combo ] = w32or_all( {     WS_CLIPPINGCHILD,
	    	        WS_VISIBLE,
	    	        WS_VSCROLL,
	    	        CBS_DROPDOWN,
	    	        CBS_HASSTRINGS,
	    	        WS_TABSTOP} )
    classStyleEx[ Combo ] = w32or_all( {WS_EX_CLIENTEDGE,
	    	        WS_EX_ACCEPTFILES} )
    classAttr [ Combo ] = w32Clickable
    classBGColor[ Combo ] = w32WinDefColor -- w32Color_WINDOW


-----------------------------------------------------------------------------
--/topic Controls
--/const SortedCombo
--/desc Sorted combo box control.
-- A SortedCombo is a combination of an edit control and a list.
--
-- A SortedCombo has the following attributes:
--
-- /li /b WS_CHILD: child control of the parent
-- /li /b WS_VISIBLE: it is visible
-- /li /b WS_VSCROLL: attach a vertical scroll bar
-- /li /b CBS_DROPDOWN: the list can drop down, like a menu
-- /li /b CBS_HASSTRINGS: contains string values
-- /li /b CBS_SORT: sorted
-- /li /b WS_TABSTOP: the control can be tabbed to

    className[ SortedCombo ] = "combobox"
    classType[ SortedCombo ] = COMBO
    classStyle[ SortedCombo ] = w32or_all( {   WS_CLIPPINGCHILD,
	    	            WS_VISIBLE,
	    	            WS_VSCROLL,
	    	            CBS_DROPDOWN,
	    	            CBS_HASSTRINGS,
	    	            CBS_SORT,
	    	            WS_TABSTOP} )
    classStyleEx[ SortedCombo ] = w32or_all( {WS_EX_CLIENTEDGE,
	    	        WS_EX_ACCEPTFILES} )
    classAttr [ SortedCombo ] = w32Clickable
    classBGColor[ SortedCombo ] = w32WinDefColor -- w32Color_WINDOW

-----------------------------------------------------------------------------
--/topic Controls
--/const SimpleCombo
--/desc Simple combo box control.
-- A SimpleCombo is a combo box with no dropdown. The user can
-- select from various values by using the cursor keys.
--
-- A SimpleCombo has the following attributes:
--
-- /li /b WS_CHILD: child control of the parent
-- /li /b WS_VISIBLE: it is visible
-- /li /b CBS_SIMPLE: has a list of values
-- /li /b CBS_HASSTRINGS: contains string values
-- /li /b WS_TABSTOP: the control can be tabbed to

    className[ SimpleCombo ] = "combobox"
    classType[ SimpleCombo ] = COMBO
    classStyle[ SimpleCombo ] = w32or_all( {
	    	        WS_CLIPPINGCHILD,
	    	        WS_VISIBLE,
	    	        CBS_SIMPLE,
	    	        CBS_HASSTRINGS,
	    	        WS_TABSTOP} )
    classStyleEx[ SimpleCombo ] = w32or_all( {WS_EX_CLIENTEDGE,
	    	        WS_EX_ACCEPTFILES} )
    classAttr [ SimpleCombo ] = w32Clickable
    classBGColor[ SimpleCombo ] = w32WinDefColor -- w32Color_WINDOW


-----------------------------------------------------------------------------
--/topic Controls
--/const DropDownList
--/desc Drop down list control.
-- A DropDownList is like a /Combo, but the user can only
-- select items on the list, and not enter their own value into the edit
-- box.
--
-- A DropDownList has the following attributes:
--
-- /li /b WS_CHILD: child control of the parent
-- /li /b WS_VISIBLE: it is visible
-- /li /b WS_VSCROLL: attach a vertical scroll bar
-- /li /b CBS_DROPDOWNLIST: the list can drop down, like a menu
-- /li /b CBS_HASSTRINGS: contains string values
-- /li /b WS_TABSTOP: the control can be tabbed to

    className[ DropDownList ] = "combobox"
    classType[ DropDownList ] = COMBO
    classStyle[ DropDownList ] = w32or_all( { WS_CLIPPINGCHILD,
	    	           WS_VISIBLE,
	    	        WS_VSCROLL,
	    	           CBS_DROPDOWNLIST,
	    	           CBS_HASSTRINGS,
	    	            WS_TABSTOP} )
    classStyleEx[ DropDownList ] = w32or_all( {WS_EX_CLIENTEDGE,
	    	        WS_EX_ACCEPTFILES} )
    classAttr [ DropDownList ] = w32Clickable
    classBGColor[ DropDownList ] = w32WinDefColor -- w32Color_WINDOW

-----------------------------------------------------------------------------
--/topic Controls
--/const EditText
--/desc Text edit control control.
-- An EditText allows the user to enter a single-line of text into the control.
--
-- /b Note that when the user presses the Return Key, the focus will move to the next control
-- in the focus order. To prevent this from happening, you need to set a /w32HKeyPress handler
-- that sets the return value to -1 when a VK_RETURN key without shifts is received.
--
--/code
--      procedure IgnoreReturn(integer self, integer event, sequence parms)
--          if parms[1] = VK_RETURN and parms[2] = 0 then
--              returnValue(-1)
--          end if
--      end procedure
--      setHandler(myEditField, w32HKeyPress, routine_id("IgnoreReturn"))
--/endcode
--
-- A EditText has the following attributes:
--
-- /li /b WS_CHILD: child control of the parent
-- /li /b WS_VISIBLE: it is visible
-- /li /b ES_AUTOHSCROLL: automatic vertical scrollbar, if needed
-- /li /b ES_LEFT: left justify the text
-- /li /b WS_BORDER: draw with a border
-- /li /b WS_TABSTOP: the control can be tabbed to
-- /li /b WS_EX_CLIENTEDGE: 3D effect
-- /li /b WS_EX_ACCEPTFILES: drag and drop support

-- single line edit, left justified
    className[ EditText ] = "edit"
    classType[ EditText ] = EDIT
    classStyle[ EditText ] = w32or_all( { WS_CLIPPINGCHILD,
	    	        WS_VISIBLE,
	    	        WS_TABSTOP,
	    	        WS_BORDER,
	    	        ES_AUTOHSCROLL,
	    	        ES_LEFT} )

    classStyleEx[ EditText ] = w32or_all( {WS_EX_CLIENTEDGE,
	    	        WS_EX_ACCEPTFILES} )
    classAttr [ EditText ] = w32AutoSelect
    classDefPointer[ EditText ] = IDC_IBEAM
    classBGColor[ EditText ] = w32WinDefColor -- w32Color_WINDOW

-----------------------------------------------------------------------------
--/topic Controls
--/const MleText
--/desc Multi-line edit control.
-- An MleText (multi-line edit) control is like a mini-text editor.
-- The user can enter in multiple lines of text.
--
-- Since the Tab key is accepted as input into the MLE, the user has to
-- press Control+Tab to move to the next control, instead of the standard
-- Tab key.
--
-- A MleText has the following attributes:
--
-- /li /b WS_CHILD: child control of the parent
-- /li /b WS_VISIBLE: it is visible
-- /li /b WS_HSCROLL: horizontal scroll bar
-- /li /b WS_VSCROLL: vertical scroll bar
-- /li /b ES_LEFT: left justify the text
-- /li /b WS_BORDER: draw with a border
-- /li /b ES_MULTILINE: allow multiple lines of text
-- /li /b WS_TABSTOP: the control can be tabbed to
-- /li /b WS_EX_CLIENTEDGE: 3D effect
-- /li /b WS_EX_ACCEPTFILES: drag and drop support

    className[ MleText ] = "edit"
    classType[ MleText ] = EDIT
    classStyle[ MleText ] = w32or_all( {   WS_CLIPPINGCHILD,
	    	        WS_VISIBLE,
	    	        WS_TABSTOP,
	    	        WS_VSCROLL,
	    	        WS_BORDER,
	    	        ES_LEFT,
	    	        ES_MULTILINE} )
    classStyleEx[ MleText ] = w32or_all( {WS_EX_CLIENTEDGE,
	    	           WS_EX_ACCEPTFILES} )
    classAttr [ MleText ] = w32CtrlTab
    classDefPointer[ MleText ] = IDC_IBEAM
    classBGColor[ MleText ] = w32Color_WINDOW
-----------------------------------------------------------------------------
--/topic Controls
--/const LText
--/desc Left-justified label control.
-- An LText control does not respond to events.
--
-- An LText has the following attributes:
--
-- /li /b WS_CHILD: child control of the parent
-- /li /b WS_VISIBLE: it is visible
-- /li /b ES_LEFT: left justify the text
-- /li /b SS_NOTIFY: Enable click events


    className[ LText ] = "static"
    classType[ LText ] = STATIC
    classStyle[ LText ] = w32or_all( { WS_CLIPPINGCHILD,
	    	        WS_VISIBLE,
	    	        ES_LEFT,
                    SS_NOTIFY} )
    classAttr [ LText ] = 0
    classBGColor [ LText ] = w32BGTransparent

-----------------------------------------------------------------------------
--/topic Controls
--/const RText
--/desc Right-justified label control.
-- An RText control does not respond to events.
--
-- An RText has the following attributes:
--
-- /li /b WS_CHILD: child control of the parent
-- /li /b WS_VISIBLE: it is visible
-- /li /b ES_RIGHT: right justify the text
-- /li /b SS_NOTIFY: Enable click events

    className[ RText ] = "static"
    classType[ RText ] = STATIC
    classStyle[ RText ] = w32or_all( { WS_CLIPPINGCHILD,
	    	        WS_VISIBLE,
	    	        ES_RIGHT,
                    SS_NOTIFY} )
    classAttr [ RText ] = 0
    classBGColor [ RText ] = w32BGTransparent


-----------------------------------------------------------------------------
--/topic Controls
--/const CText
--/desc Center-justified label control.
-- A CText control does not respond to events.
--
-- A CText has the following attributes:
--
-- /li /b WS_CHILD: child control of the parent
-- /li /b WS_VISIBLE: it is visible
-- /li /b ES_CENTER: center justify the text
-- /li /b SS_NOTIFY: Enable click events

    className[ CText ] = "static"
    classType[ CText ] = STATIC
    classStyle[ CText ] = w32or_all( { WS_CLIPPINGCHILD,
	    	        WS_VISIBLE,
	    	        ES_CENTER,
                    SS_NOTIFY} )
    classAttr [ CText ] = 0
    classBGColor [ CText ] = w32BGTransparent


-----------------------------------------------------------------------------
--/topic Controls
--/const HScroll
--/desc Horizontal scrollbar control.
-- An HScroll has the following attributes:
--
-- /li /b WS_CHILD: child control of the parent
-- /li /b WS_VISIBLE: it is visible
-- /li /b SBS_HORZ: horizontal scroll bar
-- /li /b WS_TABSTOP: the control can be tabbed to


-- horizontal scroll bar
    className[ HScroll ] = "scrollbar"
    classType[ HScroll ] = SCROLLBAR
    classStyle[ HScroll ] = w32or_all( {   WS_CLIPPINGCHILD,
	    	        WS_VISIBLE,
	    	        SBS_HORZ,
	    	        WS_TABSTOP} )
    classAttr [ HScroll ] = w32UseSubProc + w32NoRenderDisabled
    classBGColor[ HScroll ] = w32WinDefColor


-----------------------------------------------------------------------------
--/topic Controls
--/const VScroll
--/desc Vertical scrollbar control.
--
-- A VScroll has the following attributes:
--
-- /li /b WS_CHILD: child control of the parent
-- /li /b WS_VISIBLE: it is visible
-- /li /b SBS_VERT: vertical scroll bar
-- /li /b WS_TABSTOP: the control can be tabbed to

    className[ VScroll ] = "scrollbar"
    classType[ VScroll ] = SCROLLBAR
    classStyle[ VScroll ] = w32or_all( {   WS_CLIPPINGCHILD,
	    	        WS_VISIBLE,
	    	        SBS_VERT,
	    	        WS_TABSTOP} )
    classAttr [ VScroll ] = w32UseSubProc + w32NoRenderDisabled
    classBGColor[ VScroll ] = w32WinDefColor

-----------------------------------------------------------------------------
--/topic Controls
--/const Icon
--/desc Icon control.
-- An Icon is a static small graphic. As a static control, it does
-- not respond to events.
--
-- An Icon has the following attributes:
--
-- /li /b WS_CHILD: child control of the parent
-- /li /b WS_VISIBLE: it is visible
-- /li /b SS_ICON: icon
-- /li /b SS_NOTIFY: Enable click events

    className[ Icon ] = "static"
    classType[ Icon ] = STATIC
    classStyle[ Icon ] = w32or_all( { WS_CLIPPINGCHILD,
	    	        WS_VISIBLE,
	    	       SS_ICON,
                   SS_NOTIFY} )
    classAttr [ Icon ] = 0


-----------------------------------------------------------------------------
--/topic Controls
--/const Bitmap
--/desc Static bitmap control.
-- A Bitmap does not respond to events.
--
-- A Bitmap has the following attributes:
--
-- /li /b WS_CHILD: child control of the parent
-- /li /b WS_VISIBLE: it is visible
-- /li /b SS_BITMAP: bitmap
-- /li /b SS_NOTIFY: Enable click events

    className[ Bitmap ] = "static"
    classType[ Bitmap ] = STATIC
    classStyle[ Bitmap ] = w32or_all( { WS_CLIPPINGCHILD,
	    	        WS_VISIBLE,
	    	        SS_BITMAP,
                    SS_NOTIFY} )
    classAttr [ Bitmap ] = 0

-----------------------------------------------------------------------------
--/topic Controls
--/const Menu
--/desc Menu bar item control.
-- A Menu is an item in a window's menubar. There is no need to
-- declare a menubar for a window; if a Menu is created, the menubar
-- will automatically be created for it.


-- menu bar item
    className[ Menu ] = ""
    classType[ Menu ] = MENU
    classAttr [ Menu ] = w32NoConv

-----------------------------------------------------------------------------
--/topic Controls
--/const Popup
--/desc Popup menu control.
-- A Popup is a menu not attached to a window. To display a popup,
-- use /popup().

    className[ Popup ] = ""
    classType[ Popup ] = POPUP

    classAttr [ Popup] = w32NoConv

-----------------------------------------------------------------------------
--/topic Controls
--/const MenuItem
--/desc Dropdown menu item control.
-- A MenuItem is an item in a window's Menu. Menu items are
-- placed sequentially into menus.
--
-- There is currently no way to remove menu items.

    className[ MenuItem ] = ""
    classType[ MenuItem ] = MENUITEM

    classAttr [ MenuItem ] = w32NoConv
-----------------------------------------------------------------------------

--/topic Controls
--/const MenuSpacer
--/desc Horizontal spacer (line) in menu items.
-- A MenuSpacer is placed as a horizontal line in a window's Menu.
--
-- There is currently no way to remove menu items.

    className[ MenuSpacer ] = ""
    classType[ MenuSpacer ] = MENUITEM

    classAttr [ MenuSpacer ] = w32NoConv

-----------------------------------------------------------------------------
--/topic Controls
--/const Pixmap
--/desc Color bitmap.
-- A Pixmap is an off-screen color bitmap. It can be displayed
-- in a window by using one of the /i bitblt functions (see
-- Graphics for details).

    className[ Pixmap ] = ""
    classType[ Pixmap ] = PIXMAP
    classAttr [ Pixmap ] = w32NoConv

-----------------------------------------------------------------------------
--/topic Controls
--/const ToolBar
--/desc Window toolbar control.
-- A ToolBar is a container at the top of a window that can hold
-- other controls - typically /PushButtons or /ToggleButtons.
-- Toolbars are implemented using the Win32 common control toolbar.
--
-- When the parent window is resized, Win32Lib automatically repositions
-- the ToolBar.
--
-- Note that the toolbar occupies space like any other control. To determine
-- what portion of the window's client area is not occupied by the toolbar
-- (and statusbar), use the /getClientRect function.
--
-- A ToolBar has the following attributes:
--
-- /li /b CCS_TOP: place on top of the window
-- /li /b CCS_NORESIZE: don't automatically resize (Win32Lib does it)
-- /li /b WS_CHILD: child control of parent
-- /li /b WS_BORDER: draw a border
-- /li /b WS_CLIPSIBLINGS: clip child controls

    className[ ToolBar ] = TOOLBARCLASSNAMEA
    classType[ ToolBar ] = COMMON_CONTROL
    classStyle[ ToolBar ] = w32or_all( {   CCS_TOP,
	    	        CCS_NORESIZE,
	    	        WS_CLIPPINGCHILD,
	    	        WS_VISIBLE,
	    	        WS_BORDER} )

    classAttr [ ToolBar ] = w32NoConv + w32Clickable + w32OwnerId + w32Toolbar
-----------------------------------------------------------------------------
--/topic Controls
--/const StatusBar
--/desc Window status bar control.
-- A StatusBar is a control placed at the bottom of the window
-- that status messages can be written into.
-- The status bar is implemented using the Win32 common control toolbar.
--
-- When the parent window is resized, Win32Lib automatically repositions
-- the StatusBar.
--
-- Note that the status bar occupies space like any other control. To
-- determine what portion of the window's client area is not occupied by
-- the statusbar (and toolbar), use the /getClientRect function.
--
-- A StatusBar has the following attributes:
--
-- /li /b CCS_BOTTOM: place on bottom of the window
-- /li /b WS_CHILD: child control of parent
-- /li /b WS_BORDER: draw a border
-- /li /b WS_CLIPSIBLINGS: clip child controls

    className[ StatusBar ]  = STATUSCLASSNAMEA
    classType[ StatusBar ]  = COMMON_CONTROL
    classStyle[ StatusBar ] = w32or_all( { WS_CLIPPINGCHILD,
	    	        WS_VISIBLE,
	    	        CCS_BOTTOM} )

    classAttr [ StatusBar ] = w32Clickable + w32OwnerId  + w32Statusbar
-----------------------------------------------------------------------------
--/topic Controls
--/const PictureButton
--/desc Command button with graphic control.
-- A PictureButton is a /PushButton with a graphic instead
-- of text. The graphic can be specified by passing the name or address of
-- a bitmap control in the /i flags parameter, or with /setBitmap,
-- /setIcon
--
-- A PictureButton is typically used in a /ToolBar.
--
-- This can show either an Icon or a Bitmap. The choice is made when
-- the control is created using the /create() routine. When being created,
-- the /i style parameter is used to designate the image and format of
-- images on the button. The /i style parameter can be one of ... /n
--/li /w32PB_BITMAP which indicates that the application will later explicitly
-- set a bitmap image to the button.
--/li 0 which is the same as /i w32PB_BITMAP
--/li /w32PB_ICON which indicates that the application will later explicitly
-- set an icon image to the button.
--/li A handle to a pre-loaded bitmap image.
--/li A handle to a pre-loaded icon image.
--/li A filename to either a .BMP or a .ICO file.
--
--
-- /li /b WS_CHILD: child control of the parent
-- /li /b WS_VISIBLE: it is visible
-- /li /b BS_PUSHBUTTON: button style is pushbutton
-- /li /b WS_TABSTOP: the control can be tabbed to

    className[ PictureButton ] = "button"
    classType[ PictureButton ] = BUTTON
    classStyle[ PictureButton ] = w32or_all( { WS_CLIPPINGCHILD,
	    	            WS_VISIBLE,
	    	            BS_PUSHBUTTON,
	    	            WS_TABSTOP} )
    classAttr [ PictureButton ] = w32PictCtrl

-----------------------------------------------------------------------------
--/topic Controls
--/const ToggleButton
--/desc Toggle button control.
-- A ToggleButton is a /PushButton that behaves like a
-- /CheckBox - clicking it toggles it down, clicking again toggles
-- it back up. It is typically used in a /ToolBar.
--
-- This can show either an Icon or a Bitmap. The choice is made when
-- the control is created using the /create() routine. When being created,
-- the /i style parameter is used to designate the image and format of
-- images on the button. The /i style parameter can be one of ... /n
--/li w32PB_BITMAP which indicates that the application will later explicitly
-- set a bitmap image to the button.
--/li 0 which is the same as /i w32PB_BITMAP
--/li w32PB_ICON which indicates that the application will later explicitly
-- set an icon image to the button.
--/li A handle to a pre-loaded bitmap image.
--/li A handle to a pre-loaded icon image.
--/li A filename to either a .BMP or a .ICO file.
--
--
-- /li /b WS_CHILD: child control of the parent
-- /li /b WS_VISIBLE: it is visible
-- /li /b BS_PUSHBUTTON: button style is pushbutton
-- /li /b BS_BITMAP: displays a bitmap
-- /li /b WS_TABSTOP: the control can be tabbed to

    className[ ToggleButton ] = "button"
    classType[ ToggleButton ] = BUTTON
    classStyle[ ToggleButton ] = w32or_all( {  WS_CLIPPINGCHILD,
	    	            WS_VISIBLE,
	    	            BS_PUSHLIKE,
	    	            BS_AUTOCHECKBOX,
	    	            WS_TABSTOP} )

    classAttr [ ToggleButton ] = 0

-----------------------------------------------------------------------------
--/topic Controls
--/const TogglePicture
--/desc Toggle button with graphic control.
-- A TogglePicture is a combination of a /ToggleButton
-- and a /PictureButton. The graphic can be specified by passing the
-- name or address of a bitmap in the /i flags parameter, or with
-- /setBitmap, /setIcon
--
-- This can show either an Icon or a Bitmap. The chice is made when
-- the control is created using the /create() routine.
--
--
-- /li /b WS_CHILD: child control of the parent
-- /li /b WS_VISIBLE: it is visible
-- /li /b BS_PUSHBUTTON: button style is pushbutton
-- /li /b WS_TABSTOP: the control can be tabbed to

    className[ TogglePicture ] = "button"
    classType[ TogglePicture ] = BUTTON
    classStyle[ TogglePicture ] = w32or_all( { WS_CLIPPINGCHILD,
	    	            WS_VISIBLE,
	    	            BS_PUSHLIKE,
	    	            BS_AUTOCHECKBOX,
	    	            WS_TABSTOP} )
    classAttr [ TogglePicture] = w32PictCtrl

-----------------------------------------------------------------------------
--/topic Controls
--/const HTrackBar
--/desc Horizontal track bar control.
-- An HTrackBar has the following attributes:
--
-- /li /b WS_CHILD: child control of the parent
-- /li /b WS_VISIBLE: it is visible
-- /li /b TBS_VERT: vertical scrollbar
-- /li /b TBS_AUTOTICKS: ticks automatically created
-- /li /b TBS_ENABLESELRANGE: range highlighted, triangles at end of range
-- /li /b WS_TABSTOP: the control can be tabbed to

    className[ HTrackBar ] = TRACKBAR_CLASSA
    classType[ HTrackBar ] = COMMON_CONTROL
    classStyle[ HTrackBar ] = w32or_all( { WS_CLIPPINGCHILD,
	    	           WS_VISIBLE,
	    	           TBS_HORZ,
	    	           TBS_AUTOTICKS,
	    	           TBS_ENABLESELRANGE,
	    	           WS_TABSTOP} )
    classAttr [ HTrackBar ] = w32Clickable  + w32OwnerId

-----------------------------------------------------------------------------
--/topic Controls
--/const VTrackBar
--/desc Vertical track bar control.
-- A VTrackBar has the following attributes:
--
-- /li /b WS_CHILD: child control of the parent
-- /li /b WS_VISIBLE: it is visible
-- /li /b TBS_VERT: vertical scrollbar
-- /li /b TBS_AUTOTICKS: ticks automatically created
-- /li /b TBS_ENABLESELRANGE: range highlighted, triangles at end of range
-- /li /b WS_TABSTOP: the control can be tabbed to

    className[ VTrackBar ] = TRACKBAR_CLASSA
    classType[ VTrackBar ] = COMMON_CONTROL
    classStyle[ VTrackBar ] = w32or_all( { WS_CLIPPINGCHILD,
	    	           WS_VISIBLE,
	    	           TBS_VERT,
	    	           TBS_AUTOTICKS,
	    	           TBS_ENABLESELRANGE,
	    	           WS_TABSTOP} )
    classAttr [ VTrackBar ] = w32Clickable  + w32OwnerId

-----------------------------------------------------------------------------
--/topic Controls
--/const TabControl
--/desc Tab Control.
-- A TabControl is a container control. It can have one or more /TabItems.
-- Selecting a /TabItem in a TabControl activates it, and displays any
-- controls that are associated with it.
--
-- Since the TabControl is a container, controls can be placed into it,
-- just like placing them into a window. However, it becomes the coder's
-- responsibility to show and hide various controls as different /TabItems
-- are selected. It is easier to associate controls with /TabItems, since
-- Win32Lib will automatically take care of those details.
--
-- The TabControl has the following attributes:
--
-- /li /b WS_CHILD: child control of the parent
-- /li /b WS_VISIBLE: it is visible
-- /li /b WS_CLIPCHILDEN: controls not fitting on the TabControl are clipped.
-- /li /b WS_TABSTOP: the control can be tabbed to

    className[ TabControl ] = WC_TABCONTROLA
    classType[ TabControl ] = COMMON_CONTROL
    classStyle[ TabControl ] = w32or_all( { WS_CLIPPINGCHILD,
	    	        WS_VISIBLE,
	    	        WS_CLIPCHILDREN,
	    	        WS_TABSTOP} )
    classAttr [ TabControl ] = w32Clickable  + w32OwnerId



-----------------------------------------------------------------------------
--/topic Controls
--/const TabItem
--/desc Tab on a TabControl.
-- A TabItem is a tab attached to the top of a /TabControl. TabItems respond
-- to being selected by triggering an /onClick event.
--
-- Items can be automatically displayed in a /TabControl by setting their
-- owner to the TabItem instead of the /TabControl. Win32Lib will
-- automatically reparent controls with TabItems to the TabControl, and
-- maintain a logical association between them. For example:
--
--/code
--  constant
--    Win     = create( Window, "Testing", 0, Default, Default, 100, 100, 0 ),
--    Tabs    = create( TabControl, "", Win, 10, 10, 80, 80, 0 ),
--    Tab1    = create( TabItem, "Tab Number &1", Tabs, 0, 0, 0, 0, 0 ),
--    Tab2    = create( TabItem, "Tab Number &2", Tabs, 0, 0, 0, 0, 0 ),
--    Button1 = create( PushButton, "Button 1", Tab2, 10, 60, 80, 40, 0 )
--
--/endcode
--
-- In the example above, Button1 is created in Tabs (the parent of Tab2).
-- When Tab2 is clicked, it will appear in Tabs at {10,60}. When Tab1 is
-- clicked, it will disappear from Tabs.

    className[ TabItem ] = "w32 TabItem"
    classType[ TabItem ] = -1 -- Not a real class
    classStyle[ TabItem ] = 0 -- WS_TABSTOP
    classAttr [ TabItem ] = w32Clickable + w32Virtual
    classBGColor [ TabItem ] = w32WinDefColor


-----------------------------------------------------------------------------
--/topic Controls
--/const ProgressBar
--/desc Progress Bar
-- A ProgressBar is used to show what amount of a task is complete.
-- To move the position of the ProgressBar indicator, call /setScrollPos.
-- By default, the ProgressBar ranges from 1 to 100. You can change the
-- range by calling /setScrollRange().
--
-- For the most part, the ProgressBar behaves like most other
-- /"Scroll Controls".
--
-- The following example creates a /Window that contains a /Timer and
-- a /ProgressBar. As the /Timer ticks, the ProgressBar is automatically
-- incremented.
--
--/code
--  constant
--      Win   = /create(/Window,"Timer Window",0,Default,Default,200,100,0),
--      PBar  = /create(/ProgressBar,"",Win,5,40,180,20,0),
--      Timer = 1
--
--  procedure tick( integer self, integer event, sequence parms)
--      integer timerId
--      timerId = parms[1]
--      -- advance the progress bar by 5 ticks
--      /setScrollPos( PBar, /getScrollPos( PBar ) + 5 )
--  end procedure
--  setHandler(Win, w32HTimer, routine_id( "tick" ))
--
--  -- tick once per second
--  /setTimer( Win, Timer, 1000 )
--
--  /WinMain( Win, Normal )
--/endcode

    className[ ProgressBar ] = PROGRESS_CLASSA
    classType[ ProgressBar ] = COMMON_CONTROL
    classStyle[ ProgressBar ] = w32or_all({WS_CHILD,WS_VISIBLE})

    classAttr [ ProgressBar ] = w32Clickable + w32OwnerId

-----------------------------------------------------------------------------
--/topic Controls
--/const ListView
--/desc ListView
-- A list view control is a window that displays collection of
-- items, each item consisting of an icon and a label.  List
-- view controls provide several ways of arranging items and
-- displaying individual items.  For example, additional information
-- about each item can be displayed in columns to the right of the
-- icon and label.
--
-- List views have 3 modes:
-- /li Icon
-- /li List
-- /li Report
--
-- Report mode can display multiple columns, which can be defined
-- upon creation of the control:
--
-- /code
--      Win = create( /Window, "The Window", 0, 0, 0, 300, 300, 0 ),
--      lv  = create( ListView, {"Column 1", Column 2"}, Win,
--                  20, 20, 200, 200, LVS_REPORT )
--      WinMain( Win, Normal )
-- /endcode
--
-- See also: /addIcon, /addLVItem, /deleteItem

    className[ ListView ] = WC_LISTVIEWA
    classType[ ListView ] = COMMON_CONTROL
    classStyle[ ListView ] = w32or_all({   WS_CLIPPINGCHILD,
	    	        WS_VISIBLE,
	    	        WS_BORDER,
	    	        WS_TABSTOP,
	    	        LVS_SHAREIMAGELISTS } )
    classStyleEx[ ListView ] = WS_EX_CLIENTEDGE
    classAttr [ ListView ] = w32Clickable + w32OwnerId
    classBGColor[ ListView ] = w32WinDefColor -- w32Color_WINDOW

constant
    lv_Default_Properties = { 0, -2, 0, 0},
    lvitem_MASK = w32or_all( { LVIF_TEXT, LVIF_IMAGE, LVIF_PARAM} )

--/topic Constants
--/const kLVColTypes
--/desc Used by /setLVAttr

--/topic Constants
--/const kLVSortSeq
--/desc Used by /setLVAttr

--/topic Constants
--/const kLVSortRtn
--/desc Used by /setLVAttr

global constant
    kLVColTypes = 1,
    kLVSortSeq = 2,
    kLVSortCol = 3,
    kLVSortRtn = 4


sequence
        lv_id,
        lv_properties,
        ilicon_list

        lv_id = {}
        lv_properties = {}
        ilicon_list = {}
integer
        lvInsertWhere
        lvInsertWhere = 1
atom
        vNextLVItemID
        vNextLVItemID = 0

atom    ILlarge,
        ILsmall

        ILlarge = 0
        ILsmall = 0
-----------------------------------------------------------------------------
--/topic Controls
--/const TreeView
--/desc TreeView
-- A tree view control is a window that displays a hierarchical list
-- of items, such as the headings in a document, the entries in an index,
-- or the files and directories on a disc.  Each item consists of a label
-- and an optional bitmapped image, and each item can have a list of subitems
-- associated with it.  By clicking an item, the user can expand and collapse
-- the associated list of subitems.
--
-- See also: /addTVItem, /deleteItem, /hitTestTV


    className[ TreeView ] = WC_TREEVIEWA
    classType[ TreeView ] = COMMON_CONTROL
    classStyle[ TreeView ] = w32or_all( { WS_CLIPPINGCHILD,
	    	           WS_VISIBLE,
	    	           WS_TABSTOP,
	    	           WS_BORDER } )
    classStyleEx[ TreeView ] = WS_EX_CLIENTEDGE
    classAttr [ TreeView ] =  w32OwnerId
    classBGColor [TreeView] = w32Color_WINDOW

    sequence tv_id, tvitem_data, tvitem_owner, tvitem_parent, tvitem_handle
    constant
        ktv_Blank = repeat(0, 5),
        tvitem_MASK = w32or_all( { TVIF_TEXT,
	                            TVIF_IMAGE,
	                            TVIF_SELECTEDIMAGE,
	                            TVIF_PARAM,
	                            TVIF_CHILDREN} ),
        ktv_NormImage = 1,
        ktv_SelectImage = 2,
        ktv_TextAddr  = 3,
        ktv_TextSize = 4,
        ktv_HasChildren = 5


    tv_id = {}
    tvitem_owner = {}
    tvitem_data = {}
    tvitem_parent = {}
    tvitem_handle = {}

-----------------------------------------------------------------------------
--/topic Controls
--/const RichEdit
--/desc RichEdit
-- A rich edit control is a window in which the user can enter and edit
-- text.  The text can be assigned character and paragraph formatting,
-- and can include embedded OLE objects.  Rich edit controls provide a
-- programming interface for formatting text.  However, and application
-- must implement any user interface components necessary to make formatting
-- operations available to the user.
--
-- Example:
--
--/code
--           -- Create the RichEdit control
--           RE = /create( /RichEdit, "", Win , 20, 20, 360, 200, ES_NOHIDESEL)
--/endcode

    className[ RichEdit ] = WC_RICHEDIT
    classType[ RichEdit ] = COMMON_CONTROL
    classStyle[ RichEdit ] = w32or_all( {  WS_CLIPPINGCHILD,
	    	        WS_VISIBLE,
	    	        WS_VSCROLL,
	    	        ES_DISABLENOSCROLL,
	    	        ES_AUTOVSCROLL,
	    	        WS_TABSTOP,
	    	        ES_SAVESEL,
	    	        ES_MULTILINE,
	    	        WS_BORDER } )
    classStyleEx[ RichEdit ] = WS_EX_CLIENTEDGE
    classAttr [ RichEdit ] = w32CtrlTab + w32OwnerId
    classDefPointer[ RichEdit ] = IDC_IBEAM

    classBGColor[ RichEdit ] = w32WinDefColor -- w32Color_WINDOW

-----------------------------------------------------------------------------
--/topic Controls
--/const MonthCalendar
--/desc MonthCalendar
-- MonthCalendar is a control used for selecting dates.  It displays
-- a calendar (one month at a time) from which the user can select a
-- date or a range of dates.
--
-- See also: /formatDate(), /getSelectedDate(), /getSelectedDateRange(),
--          /setMonthColor(), /setSelectedDate(), /setSelectedDateRange()

    className[ MonthCalendar ] = MONTHCAL_CLASS
    classType[ MonthCalendar ] = COMMON_CONTROL
    classStyle[ MonthCalendar ] = w32or_all( { WS_CLIPPINGCHILD,
	    	            WS_VISIBLE,
	    	            WS_TABSTOP,
	    	            WS_BORDER
	    	             } )
    classStyleEx[ MonthCalendar ] = MCS_DAYSTATE
    classAttr [ MonthCalendar ] =  w32OwnerId

--/topic Controls
--/const UpDown
--/desc UpDown
-- An Up-Down control is a pair of arrow buttons that the user can click
-- to increment or decrement a vaue, such as a scroll position or a number
-- displayed in a companion control.  The value associated with an up-down
-- control is called its /i current /i position.  An up-down control is
-- most often used with a companion control, which is called a /i buddy
-- /i window.  The updown control will take care of scroll events
-- automatically.
--
-- There are two ways to set a buddy window:
-- /li style flag /b UDS_AUTOBUDDY sets the buddy to the previous control
-- /li /setBuddy( id ) sets control id to the buddy window
--
-- Typical flags for an UpDown control are ...
--/code
--        w32or_all( {
--                    UDS_ALIGNRIGHT,
--                    UDS_SETBUDDYINT,
--                    UDS_ARROWKEYS,
--                    UDS_NOTHOUSANDS  -- Avoids a thousands separator.
--                })
--/endcode
--
-- See also: /getScrollPos, /setBuddy, /setScrollPos, /setScrollRange


    className[ UpDown ] = UPDOWN_CLASSA
    classType[ UpDown ] = COMMON_CONTROL
    classStyle[ UpDown ] = w32or_all( {    WS_CLIPPINGCHILD,
	    	        WS_VISIBLE
	    	        })
    classAttr [ UpDown ] =  w32OwnerId

-----------------------------------------------------------------------------
--/topic Controls
--/const ReBar
--/desc ReBar
-- Rebars are similar to toolbars, but can do some fancier things.  You
-- can put any sort of control into a rebar.
--
-- Example:
-- /code
--         -- create the rebar
--      rebar = /create( /ReBar, "", owner, x, y, cx, cy, flags )
--         -- create a band for the rebar
--      band = /create( /ReBarBand, caption, rebar, 0, 0, cx, cy, flags )
--         -- [NOTE: to create the band on a new line within the rebar,
--         -- use RBBS_BREAK ]
--         -- add controls to the bands.  Controls should be children
--         -- of the rebar.
--      combo = /create( /Combo, "", rebar, 0, 0, cx, cy, flags )
--      /addToBand( combo, band )
-- /endcode
--
-- See also: /addToBand(), /ReBarBand

    className[ ReBar ] = REBARCLASSNAME
    classType[ ReBar ] = COMMON_CONTROL
    classStyle[ ReBar ] = w32or_all( { WS_CLIPPINGCHILD,
	    	        WS_VISIBLE,
	    	        WS_TABSTOP,
	    	        WS_CLIPCHILDREN,
	    	        CCS_ADJUSTABLE,
	    	        WS_BORDER })
    classStyleEx[ ReBar ] = WS_EX_CLIENTEDGE
    classAttr [ ReBar ] = w32NoConv + w32OwnerId + w32Toolbar


--/topic Controls
--/const ToolTip
--/desc Creates a ToolTip control.
--This is not normally required as one is automatically created for
--your application whenever you use /setHint() or supply tooltip
--text when creating a control.

    className[ ToolTip ] = TOOLTIPS_CLASSA
    classType[ ToolTip ] = COMMON_CONTROL
    classStyle[ ToolTip ] = TTS_ALWAYSTIP
    classStyleEx[ ToolTip ] = WS_EX_TOPMOST
    classAttr [ ToolTip ] = w32NoConv


-----------------------------------------------------------------------------
--/topic Controls
--/const FlatToolbar
--/desc Creates a toolbar without a 3D border.


    className[ FlatToolBar ] = TOOLBARCLASSNAMEA
    classType[ FlatToolBar ] = COMMON_CONTROL
    classStyle[ FlatToolBar ] = w32or_all( {
	    	        CCS_TOP,
	    	        CCS_NORESIZE,
	    	        --CCS_ADJUSTABLE,
	    	        WS_CLIPPINGCHILD,
	    	        WS_VISIBLE,
	    	        WS_BORDER,
	    	        WS_TABSTOP,
	    	        TBSTYLE_FLAT,
	    	        TBSTYLE_TOOLTIPS } )
    classStyleEx[ FlatToolBar ] = TBSTYLE_EX_DRAWDDARROWS
    classAttr [ FlatToolBar ] = w32NoConv + w32Clickable + w32OwnerId + w32Toolbar

    atom himlFTBDefault, himlFTBHot, himlFTBDisabled
    sequence FTB_images

    himlFTBDefault = 0
    himlFTBHot = 0
    himlFTBDisabled = 0
    FTB_images = {}

--/topic Controls
--/const SepButton
--/desc Separator button for use with /FlatToolBar Controls
-- This should only be used with /FlatToolBar controls.  It creates
-- a divider between buttons, which is shown as a vertical line.
    className[ SepButton ]  = "button"
    classType[ SepButton ]  = BUTTON
    classStyle[ SepButton ] = TBSTYLE_SEP
    classAttr [ SepButton ] = w32NoConv + w32Clickable

--/topic Controls
--/const ComboBoxEx
--/desc Combobox with images
-- The /ComboBoxEx control works almost exactly like a normal /Combo, but
-- you can include images to be displayed along side the item text.
-- See /addItem for details.
    className[ ComboBoxEx ] = WC_COMBOBOXEX
    classType[ ComboBoxEx ] = COMMON_CONTROL
    classStyle[ ComboBoxEx ] = w32or_all( {
	    	        WS_CLIPPINGCHILD,
	    	        WS_VISIBLE,
	    	        CBS_DROPDOWN,
	    	        CBS_NOINTEGRALHEIGHT,
	    	        WS_TABSTOP} )

    classAttr [ ComboBoxEx ] = w32Clickable + w32OwnerId
    classBGColor[ ComboBoxEx ] = w32WinDefColor -- w32Color_WINDOW


------------------------------------------
--/topic Constants
--/const CCflags
--/desc Used by function /classDefaults() to indicate Style Flags

--/topic Constants
--/const CCexflags
--/desc Used by function /classDefaults() to indicate Extended Style Flags

--/topic Constants
--/const CCwinstyle
--/desc Used by function /classDefaults() to set the style flags when
--registering a new window class.

global constant
    CCflags = 1,       -- The code for class Style Flags
    CCexflags = 2,     -- The code for Extended Style Flags
    CCwinstyle = 3     -- Used to set the registered class style for windows

--/topic System Attributes
--/func classDefaults(integer class, sequence pData)
--/desc Used to change the default values for style and extended style flags.
--/ret The current values of these flags prior to changing them.
-- /i class is the type of control whose defaults you want to change. /n
-- /i pData is a sequence that contains zero or more sub-sequences. Each
-- sub-sequence must have two elements, the first is the type of flag being
-- changed, and the other is the new value for the flag. The flag value can
-- be either an atom with all the flags /b"or'd", or a sequence of individual
-- flags. /n
-- The types of flags that can be changed are: /n
--/li CCflags - Standard control flags
--/li CCexflags - Extended control flags
--/li CCwinstyle - Only applies to Window - the class style flags.
--
-- Note, if /i pData is an empty sequence, the current flags are returned.
-- example:
--/code
--   sequence oldFlags
--   -- Make LText initially hidden and have a border when displayed.
--   oldFlags = classDefaults(LText, {
--                   {CCflags, {WS_CHILD, ES_LEFT}},
--                   {CCexflags, WS_EX_CLIENTEDGE}
--                      })
--   -- Change the default class flags for windows.
--   oldFlags = classDefaults(Window, {
--                   {CCwinstyle, {CS_HREDRAW,CS_DBLCLKS}}
--                      })
--/endcode

global function classDefaults(integer class, sequence pData)
    sequence lCurDefaults

    -- Make sure only real class ids are supplied.
    if   class < 1
      or class > length(vControlTypes)
    then
        return {} -- Bad ID supplied.
    end if

    -- Collect the current values before changing them.
    lCurDefaults = {{CCflags, w32get_bits(classStyle[class])},
	        {CCexflags, w32get_bits(classStyleEx[class])},
	        {CCwinstyle, vWindowClassStyle}
	       }

    -- Change the defaults.
    for i = 1 to length(pData) do
        -- Only looking for sequences
        if sequence(pData[i]) then
            -- of two elements
            if length(pData[i]) = 2 then
        	    -- Is this the Style Flags?
        	    if pData[i][1] = CCflags then
        	        if atom(pData[i][2]) then
            	        classStyle[class] = pData[i][2]
        	        else
            	        classStyle[class] = w32or_all(pData[i][2])
        	        end if
        	    -- Is this the Extended Style Flags?
        	    elsif pData[i][1] = CCexflags then
        	        if atom(pData[i][2]) then
            	        classStyleEx[class] = pData[i][2]
        	        else
        	            classStyleEx[class] = w32or_all(pData[i][2])
        	        end if
        	    -- Is this the Class Style flags
        	    elsif pData[i][1] = CCwinstyle then
        	        if atom(pData[i][2]) then
        	            vWindowClassStyle = w32get_bits(pData[i][2])
        	        else
        	            vWindowClassStyle = pData[i][2]
        	        end if
        	    end if
            end if
        end if
    end for

    -- Return with what the defaults used to be.
    return lCurDefaults
end function

-----------------------------------------------------------------------------
--/topic Controls
--/const Screen
--/desc Identifes the screen.
-- The /Screen refers to the computer screen. It is automatically created,
-- and it most graphic methods that work in /Windows will also work with
-- the screen.
--
-- Example:
--/code
--          -- Draw an 'x' across the screen
--          sequence size
--
--          -- get the screen width & height
--          size = /getCtlSize( /Screen )
--
--          -- set the pen color to red
--          /setPenColor( /Screen, Red )
--
--          -- draw the lines
--          /drawLine( /Screen, 0, 0, size[1], size[2] )
--          /drawLine( /Screen, size[1], 0, size[2], 0 )
--/endcode

-----------------------------------------------------------------------------
--/topic Controls
--/const Printer
--/desc Handle to the printer.
-- The /Printer refers to the selected printer. Before it can be used,
-- you must first select a printer using /getPrinter. After you are done
-- printing, you should release the /Printer with /releasePrinter.
--
-- Each document should be begin and end with a /startDoc and /endDoc
-- pair. Likewise, each page should begin and end with a /startPage and
-- /endPage pair.
--
-- For the sake of space, the example doesn't use the values returned
-- by /getPrinter.
--
-- Example:
--
--/code
--    -- example of using printer
--    sequence result
--
--    -- select the printer
--    result = /getPrinter()
--
--    -- did the user select a printer?
--    if length( result ) then
--
--        -- start a new document
--        if not /startDoc( sprintf( "My Job, Copy %s", {i} ) ) then
--            exit
--        end if
--
--        -- start a new page
--        if not /startPage() then
--            exit
--        end if
--
--        -- print on the page
--        /wPuts( /Printer, "Hello, Printer!" )
--
--        -- close the page
--        if not /endPage() then
--            exit
--        end if
--
--        -- close the document
--        if not /endDoc() then
--            exit
--        end if
--
--        -- release the printer
--        /releasePrinter()
--
--    end if
--
--/endcode


-----------------------------------------------------------------------------
atom
    WndProcAddress,     -- 32 bit address of Window callback
    SubProcAddress      -- 32 bit address of Control callback


-----------------------------------------------------------------------------
-- vectors

-----------------------------------------------------------------------------
--/topic Events
--/const w32HMouse
--/desc Event triggered when a mouse action takes place.
-- /i parms = { integer event, integer x, integer y, integer shift, integer wheelmove } /n
--
-- The /i event parameter will be one of the following values:
--
-- /li /b MouseMove: the mouse was moved
-- /li /b LeftDown: the left mouse button was pressed
-- /li /b RightDown: the right mouse button was pressed
-- /li /b LeftUp: the left mouse button was released
-- /li /b RightUp: the right mouse button was released
-- /li /b LeftDoubleClick: the left mouse button was double clicked
-- /li /b RightDoubleClick: the right mouse button was double clicked
-- /li /b WheelMove: The mouse wheel has moved.
--
-- The /i x and /i y parameters specify where the mouse is located.
-- If the mouse has been /i grabbed (see /captureMouse), the values
-- of /i x and /i y can be negative if the mouse is outside the
-- client area.
--
-- The /i shift parameter has bits set indicating the if the keyboard
-- shift, control, and alt keys are pressed, and which mouse button was
-- pressed. /n
--The masks are:
--
-- /li /b ShiftMask --> Left and/or Right Shift key down
-- /li /b ControlMask --> Left and/or Right Control key down
-- /li /b AltMask --> Left and/or Right Alt key down
-- /li /b KeyMask --> Any of the Shift/Control/Alt keys down.
-- /li /b LeftBtnMask --> Left mouse button down.
-- /li /b RightBtnMask --> Right mouse button down.
-- /li /b MiddleBtnMask --> Middle mouse down.
-- /li /b BtnMask --> Any mouse button down.
--
--
--
-- /code
--      -- Is one of the shift keys is held down?
--      if and_bits( shift, ShiftMask ) then
--          . . .
--      end if
--      -- Check for the combination Ctrl and Right Mouse.
--      if and_bits( shift, ControlMask+RightBtnMask ) then
--          . . .
--      end if
-- /endcode
--
-- /b NOTE /i "/b wheelmove is not supported for the onXXX interface, only the"
-- /i "setHandler interface is supported." /n
-- The /i WheelMove parameter describes the direction and size of the mouse wheel
-- movement. A value /b greater than 0 means that the wheel moved 'up' or away
-- from the user, and a value /b less than zero means the wheel moved 'down'
-- or towards the user. And of course, a value of /b 0 means that
-- it didn't move at all. /n
-- The speed, or size, of the movement is the absolute value of this parameter. You
-- can use this in conjunction with /getWheelScrollLines() to work out how the
-- mouse wheel movement should effect your application.
--
--Example: /n
--/code
--   TopLine += parms[5] * getWheelScrollLines()
--   RefreshDisplay()
--/endcode
--
-- /b "Special Note:" If you call returnValue(0) inside your mouse handler
-- routine, this has the effect of causing the control that received
-- the mouse event to ignore it. This is only needed in rare circumstances
-- where your processing of the mouse event interferes with the control's
-- normal processing. For example, if you trap a Right Down event to
-- cause a popup menu to show, sometimes you also need to tell the
-- underlying control to ignore the button down event 'cos you used it.


--/topic Events
--/const w32HMouseTrap
--/desc Event triggered when a mouse action takes place inside a defined /MouseTrap for a control.
-- /i parms = { integer event, integer x, integer y, integer z, sequence traps, integer id } /n
--
-- The /i event parameter will be one of the following values:
--
-- /li /b MouseMove: the mouse was moved
-- /li /b LeftDown: the left mouse button was pressed
-- /li /b RightDown: the right mouse button was pressed
-- /li /b LeftUp: the left mouse button was released
-- /li /b RightUp: the right mouse button was released
-- /li /b LeftDoubleClick: the left mouse button was double clicked
-- /li /b RightDoubleClick: the right mouse button was double clicked
-- /li /b WheelMove: The mouse wheel has moved.
--
-- The /i x and /i y parameters specify where the mouse is located.
-- If the mouse has been /i grabbed (see /captureMouse), the values
-- of /i x and /i y can be negative if the mouse is outside the
-- client area.
--
-- The /i z parameter only applies to WheelMouse events and is the amount and direction
-- that the wheel moved. Positive values mean it move away from the user (up), and negative
-- values mean that it moved towards the user (down).
--
-- The /i traps parameter is a list of one or more mousetrap areas that are
-- under the mouse pointer. Each mousetrap is a sequence of 8 elements: /n
--/li integer: /b zorder, the higher numbers are further in the background. The
-- initial value is zero when a mousetrap is created.
--/li integer: /b left, the leftmost position of the mousetrap area
--/li integer: /b top, the topmost position of the mousetrap area
--/li integer: /b right, the rightmost position of the mousetrap area
--/li integer: /b bottom, the bottommost position of the mousetrap area
--/li integer: /b id, the id of this mousetrap area.
--/li object: /b userdata, the data set by calling /setTagMouseTrap(). This is
--never used by win32lib and is intended for use by the user for anything.
--/li sequence: /b filters, a list of zero or more mouse event codes that are used
--to filter in this mousetrap. Initially this set to {WM_LBUTTONDOWN} when
--then mousetrap is created. It can be changed by calling /filterMouseTrap().
--
--The /i id parameter is the control id that received the mouse event.
--
-- /b Note: This event is only invoked for MouseTraps that are enabled. When
-- a mousetrap is created it is automatically enabled, but this can be changed
-- by calling /enableMouseTrap().
--
-- /code
--      sequence mt
--      mt = {}
--      mt &= /createMouseTrap(vWin, {10,10,30,30})
--      mt &= /createMouseTrap(vWin, {30,10,50,30})
--      mt &= /createMouseTrap(vWin, {10,30,30,50})
--      mt &= /createMouseTrap(vWin, {30,30,50,50})
--      /filterMouseTrap(vWin, mt[2], {WheelMove})
--      /filterMouseTrap(vWin, mt[4], {WheelMove})
--
--      procedure MouseTrap_MyWindow(integer self, integer event, sequence parms)
--          sequence lMsg
--
--          lMsg = sprintf("event=%d x=%d y=%d", parms[1..3])
--          for i = 1 to length(parms[4]) do
--              lMsg &= sprintf("(depth=%d left=%d top=%d right=%d bottom=%d id=%d) ", parms[4][i])
--          end for
--          showMessage(lMsg)
--          -- Only interested in the top mousetrap area...
--          if parms[4][1][6] = mt[2] then
--              -- Wheel moved inside mousetrap #2
--          elsif parms[4][1][6] = mt[1] then
--              -- Left Button down inside mousetrap #1
--          end if
--      end procedure
--      setHandler(vWin, w32HMouseTrap, routine_id("MouseTrap_BasicWindow"))
--
-- /endcode
--
--If the hander for the w32HMouseTrap event returns any value, by calling /returnValue(),
-- the mouse event is not passed through to the underlying control.

-----------------------------------------------------------------------------
--/topic Events
--/const w32HClick
--/desc Invoked when the left mouse button is 'clicked' or a Button control is used.
--/i parms = {  }
--
--This event is triggered when a /PushButton, /CheckBox or /TabItem is clicked,
--or by a MenuItem selection.
--
-- It is /b not the same as a Mousedown event. For a /i click to happen, the left
-- mouse down and up events must be in the same control, be no more than 2 pixels
-- from each other, and the up event must be within a double-click period
-- of the down event.
--
-- The use of accelerator keys, generates a mouse click event.




-----------------------------------------------------------------------------
--/topic Events
--/const w32HPause
--/desc Invoked whenever the Pause key is pressed.
-- /i parms = {integer keyCode, integer shift}

-----------------------------------------------------------------------------
--/topic Events
--/const w32HBreak
--/desc Invoked whenever the Ctrl-Break key is pressed.
-- /i parms = {integer keyCode, integer shift}

-----------------------------------------------------------------------------
--/topic Events
--/const w32HIdle
--/desc Invoked whenever the application is not processing Windows messages.
-- /i parms = {integer Counter, atom MsgAddr}
--
-- Your application will only start getting these events once you have
-- called /setIdle(w32True).
--
-- The /i Counter starts at 1 for each time the handler is invoked after
-- the Windows Message Queue becomes empty again. That is, this handler
-- will be invoked repeatedly, while there are no messages to be processed.
-- You can tell when you application becomes idle when the /i Counter value
-- is 1. Values higher than 1 indicate that the application is /b still idle.
-- When the application becomes active again, the handler is called with a
-- /i Counter value of -1 and the /i MsgAddr contains the message that
-- 'woke up' the application.
--
-- When the value of /i Counter is greater than -1, the /i MsgAddr is the
-- address of the Msg structure that contains the last Windows
-- message before becoming idle. When the /i Counter is -1, this contains
-- the message that is about to be processed.
--
-- If your handler routine calls /returnValue, passing any value, this
-- will immediately wake up your application and cause it to process the
-- information contained in the structure pointer to by /i MsgAddr. This
-- means that you are expected to place into this structure, valid data
-- to simulate a Windows event.
--
-- /b Note: This event is not supported by the onXXX[] interface.

-----------------------------------------------------------------------------
--/topic Events
--/const w32HKeyPress
--/desc "Printable" key is pressed.
-- /i parms = { integer keyCode, integer shift}
--
-- The /i keyCode is ANSII value of the key. Only "visible" keys are
-- reported with this function. To trap "special" keys (such as the
-- cursor keys), use /onKeyDown.
--
--For example:
--
--/code
--      -- is it the letter 'a'?
--      if keyCode = 'a' then
--          -- it's the letter a
--      end if
--/endcode
--
-- The /i shift parameter has bits set indicating the if the shift,
-- control, and alt keys are pressed. The masks for each key are:
--
-- /li /b ShiftMask
-- /li /b ControlMask
-- /li /b AltMask
--
-- For example, to see if the control key is held down, you could write:
--
-- /code
--      -- control key held down?
--      if and_bits( shift, ControlMask ) then
--          -- control key is held down
--      end if
-- /endcode
--
-- If you want to to Windows to ignore the key, set the return value to -1.
--
-- /code
--      if find(keyCode,"0123456789") then
--          returnValue(-1) -- ignore digits.
--      end if
-- /endcode
--
-- If you want to to Windows to use a different key, set the return value to the new key.
--
-- /code
--     -- collect characters into the password, but don't show them.
--     PassWord &= keyCode
--     returnValue('-') -- return a dash for each character entered.
-- /endcode

-----------------------------------------------------------------------------
--/topic Events
--/const w32HKeyUp
--/desc Key is released.
-- /i parms = {integer keyCode, integer shift}
--
-- The /i keyCode is the raw scan code value of the key. Use the
-- /b VK_ constants to determine the value of the key.
--
-- The /i shift parameter has bits set indicating the if the shift,
-- control, and alt keys are pressed.
--
--See /onKeyDown for details.

-----------------------------------------------------------------------------
--/topic Events
--/const w32HKeyDown
--/desc Key is pressed.
-- /i parms = {integer keyCode, integer shift}
--
-- The /i keyCode is "raw" value of the key. The primary purpose
-- of onKeyDown is to trap "special" keys not reported by /onKeyPress.
--
-- The /i shift parameter has bits set indicating the if the shift,
-- control, and alt keys are pressed. The masks for each key are:
--
-- /li /b ShiftMask
-- /li /b ControlMask
-- /li /b AltMask
--
-- For example, to see if the Shift+Backspace key was pressed, you could
-- write:
--
-- /code
--      -- shift+backspace?
--      if  and_bits( shift, ControlMask )
--      and keyCode = VK_BACK then
--          -- shift+backspace held
--      end if
-- /endcode

-----------------------------------------------------------------------------
--/topic Events
--/const w32HResize
--/desc A /Window has been resized.
-- /i parms = { integer style, integer x, integer y}
--
-- The /i style is one of the following:
--
-- /li /b SIZE_RESTORED: Window was restored
-- /li /b SIZE_MINIMIZED: Window was minimized
-- /li /b SIZE_MAXIMIZED: Window was maximized
--
-- The /i x and /i y parameters are the new size of the id. /n
--
-- If your handler returns a value via /returnValue() then the
-- control is forced to be repainted. If it returns a zero (0) then the control's
-- background is not erased before repainting otherwise it is erased first.


--/topic Events
--/const w32HNotify
--/desc A control is forwarding a notification event.
-- /i parms = { integer sender, integer event, object userdata, sequence parms }
--
--A control gets this event when the /i sender control has just processed an
-- event of type /i event with parameters /i parms. This only happens
-- to controls that have told the /i sender that they want to be notified via the
-- /registerNotification() routine. The /i userdata is the same as that passed
-- in the /registerNotification() routine.
--
-- An example of using this facility could be if you wish a control to be notified whenever
-- its parent is resized. Or when a specific control gets focus.
--
--/b Note: This event is not supported by the onXXX interface.

-----------------------------------------------------------------------------
--/topic Events
--/const w32HChange
--/desc Selection or Value in a control is changed.
-- The contents of /i parms varies with the type of control. /b Note that they are
-- only available when using the /setHandler() interface.
--
-- For the List and Combo family of controls the parms are ... /n
-- { Event qualifier (integer), Index of affected item (integer) } /n
-- Note that the event qualifier is always 'w32CHG_Sel' at this stage.
--
-- For /ListView the parms are ...
--<ul>
--/li   Row Index,
--/li   Column Index,
--/li   New State Flags,
--/li   Changed Flags,
--/li   Mouse's X location,
--/li   Mouse's Y location,
--/li   lParam (user data) field
--</ul>
--
-- For /MonthCalendar the parms are ...
-- if the event is invoked by a date change cuased by pressing one of the
-- prev/next buttons or by paging up/down etc, then the parms are an empty
-- sequence. /n
-- If the event is invoked by an explicit date or date range being clicked then
-- the parms returns two dates. /n
--<ul>
--/li   Earliest Date,
--/li   Latest Date
--</ul>
--
-- /b Note, for Combo box controls, this is triggered when either the edit box area
-- has been changed by the user, or when the list item selection is about to change.
-- If the user is editing the edit box area then /getText will return the current
-- value of the edit box, but if this event was triggered due to the user selecting
-- a new item, /getText will return the previously selected item and you must
-- use /getItem(id, 0) to retrieve the new selection value.
--
-- To determine the new value of the control, use the appropriate
-- function - /getText, /isChecked, /getIndex etc.

-----------------------------------------------------------------------------
--/topic Events
--/const w32HDataChange
--/desc Value in a List or a Combo's list has changed.
--/i parms is { eventqual, index }
--<ul>
--/li   Event qualifier (integer)
--<ul>
--/li w32CHG_Add = Item added
--/li w32CHG_Chg = Item changed
--/li w32CHG_Del = Item deleted
--</ul>
--/li   Index of affected item (integer)
--</ul>
-- /b Note this event is only available when using the /setHandler() interface.

--/topic Events
--/const w32HDropDown
--/desc The dropdown portion of a combobox is about to be displayed.
-- /i parms = {}  /n
-- This can be used to dynamically load the values into a combobox.


--/topic Events
--/const w32HCloseUp
--/desc The dropdown portion of a combobox has just been closed.
-- /i parms = {}  /n

-----------------------------------------------------------------------------
--/topic Events
--/const w32HGotFocus
--/desc A /control (or /Window) receives focus.
-- /i parms = {}
--
-- /i Focus means that keyboard events are directed to that control.
-- Static controls (such as /LText) cannot get focus.
--
-- When a Win32Lib window gets focus, it will give focus back to the
-- last control in the window that had focus. If there are no controls in
-- the window that can recieve focus, the focus will remain with the
-- window.

-----------------------------------------------------------------------------
--/topic Events
--/const w32HLostFocus
--/desc A /Window or /control loses focus.
-- /i parms = {focusControl} /n
-- /i focusControl is the id of the control that had the focus. This is normally the
-- same as the /i self parameter but in the case where /i self is a parent Window
-- /i focusControl is the control within that window that had focus.
--
-- /b Note: That /i focusControl parameter is not supported with the onXXX interface.
--
-- /i Focus means that keyboard events are directed to that control. See
-- /onGotFocus.

-----------------------------------------------------------------------------
--/topic Events
--/const w32HScroll
--/desc Triggered when scrollbar value has changed, and when user has stopped scrolling.
-- /i parms = { integer position, integer ScrollType, integer WhichBar }
--
-- /i position indicates the new value of a scrollbar or trackbar.
--
-- /i ScrollType is one of... /n
--<ul>
--/li SB_LINEUP
--/li SB_LINELEFT
--/li SB_LINEDOWN
--/li SB_LINERIGHT
--/li SB_PAGEUP
--/li SB_PAGELEFT
--/li SB_PAGEDOWN
--/li SB_PAGERIGHT
--/li SB_THUMBPOSITION
--/li SB_THUMBTRACK
--/li SB_TOP
--/li SB_LEFT
--/li SB_BOTTOM
--/li SB_RIGHT
--/li SB_ENDSCROLL
--/li SB_UserDefined
--</ul>
--
-- /i WhichBar is one of... /n
--<ul>
--/li SB_HORZ
--/li SB_VERT
--</ul>
-- and only applies to the /Window control type.
--
-- /b Note: However, the /i ScrollType and /i WhichBar are only available
-- when using the setHandler() interface.
--
-- This event is only triggered for ... /n
--<ul>
--/li Windows with scrollbars
--/li VScroll
--/li HScroll
--/li VTrackBar
--/li HTrackBar
--/li ProgressBar
--</ul>
-----------------------------------------------------------------------------
--/topic Events
--/const w32HOpen
--/desc A /Window is opened.
-- /i parms = {}
--
-- This is typically triggered by /WinMain, or /openWindow,
-- before the window is visible by the user.
--
-- Typically, code that is run at this point does some sort of
-- initialization.
--
-- This event is only triggered for a /Window.

-----------------------------------------------------------------------------
--/topic Events
--/const w32HActivate
--/desc Occurs for Windows only and after the window is opened.
--/i parms = {}
--
-- This is typically triggered by /WinMain, or /openWindow. It differs from
-- w32HOpen in that it is triggered /b after a window is opened but before
-- control is returned to your application.
--
-- Typically, code that is run at this point does a setFocus or other
--initialization..
--
-- This event is only triggered for a /Window.

-----------------------------------------------------------------------------
--/topic Events
--/const w32HClose
--/desc A /Window is closed.
--/i parms = {}
--
-- This typically occurs via /closeWindow, although the user can select
-- the /i close control on the window as well.
--
-- Closing a window does not actually destroy it (unless it is the
-- main window; the window is merely hidden. Refer to /closeWindow for
-- more details.
--
-- If the onClose routine calls /returnValue() with a non-zero parameter,
-- win32lib aborts the Close operation, as if it hadn't been invoked. In this
-- way it is possible to do a conditional close.
--
-- This event is only triggered for a /Window.

-----------------------------------------------------------------------------
--/topic Events
--/const w32HDestroy
--/desc The control is about to be destroyed.
-- /i parms = {}
--
-- This is triggered when /destroy() has been called and before the control
-- is actually destroyed. It is designed for the application to perform any
-- cleaning up that might be required.
--
-- If the event handler return -1, then the control is not destroyed. This
-- enables the application to prevent a control from being destroyed.
--
-- /b Note, when the main window is closed, the /destroy routine is called
-- automatically as well.
--
--/code
--  procedure onDestroy_MsgWnd(integer self, integer event, sequence parms)
--     -- Don't allow it to go until the messages have been
--     -- acknowledged by the operator.
--     if vMsgAcknowledged = w32False then
--        returnValue(-1)
--     end if
--  end procedure
--  setHandler(MsgWnd, w32HDestroy, routine_id("onDestroy_MsgWnd"))
--
--/endcode

-----------------------------------------------------------------------------
--/topic Events
--/const w32HTimer
--/desc A timer is triggered.
-- /i parms = {atom TimerID}
--
-- Timers are clocks that are maintained by Windows, and they trigger these
-- events at a user-specified interval, measured in milliseconds.
--
-- They are created and removed with the calls:
--
-- /li /setTimer( window, TimerID, milliseconds )
-- /li /killTimer( window, TimerID )
--
-- A timer is not treated as an actual control. Rather, the event is sent
-- to the window that the timer is associated with.
--

-----------------------------------------------------------------------------
--/topic Events
--/const w32HPaint
--/desc A portion or all of a /Window needs to be redrawn.
-- /i parms = {atom x1, atom y1, atom  x2, atom  y2}
--
-- The parameters indicate the portion of the window that needs
-- to be updated.
--
-- Not only does {x1,y1,x2,y2} define the area that needs to be redrawn,
-- Windows restricts your application to only being able to draw in those
-- areas! If your application tries to write outside this rectangle on an
-- paint event, nothing will be drawn there.
--
-- Since Windows expects you application to be able to redraw any part
-- of the application's window when responding to an paint event, this
-- means that the paint routine must know how to render any part of the
-- window.
--
-- For programs without any graphics and text drawn on the window, there
-- is no problem - since there are no graphics, there is nothing to update.
--
-- If the application is fairly lightweight (such as a tic-tac-toe game),
-- you simply choose to ignore the parameters passed to your paint handler,
-- and redraw the entire window with each paint event.
--
-- If there is sufficient graphics to make the task of repainting the
-- window complex, the best approach is probably to do double-buffering
-- with a /Pixmap.

-----------------------------------------------------------------------------
--/topic Events
--/const w32HDragAndDrop
--/desc Something has been dragged onto the control or window.
-- /i parms = { integer id, sequence data }
--
-- This is triggered by the user dragging and dropping a file or a /ListView
-- or /TreeView item onto a control or window. /n
--
-- If /i id is zero, then windows is dropping one or more files onto the
-- control or window.  In this case, the handler is called multiple times: /n
-- In the first call, /i data contains one integer. This is the number of
-- files about to be passed to your handler routine. /n
-- Then your handler routine is called once per file being passed. /n
-- The final call to the handler is when /i data is an empty sequence. This
-- signifies that no more files will be passed.
--
-- For example, the following code adds the name of the files to TheList.
--
--/code
--      integer vFileCount
--      procedure dropped( integer self, integer event, sequence parms )
--          if parms[1] = 0 then
--              if length(parms[2]) = 1 then
--                  -- Opening call, the file count.
--                  /setEnable(actionButton, w32False)
--                  eraseItems(TheList)
--                  vFileCount = parms[2]
--
--              elsif length(parms[2]) = 0 then
--                  -- Final call.
--                  /setEnable(actionButton, w32True)
--
--              else
--                  -- add the file name to the list
--                  /addItem( TheList, parms[2] )
--              end if
--          end if
--      end procedure
--      setHandler(TheList, w32HDragAndDrop, routine_id("dropped"))
--/endcode
--
-- If /i id is not zero, then it is the Win32Lib id of the control from
-- which items have been dragged.  The second parameter is a sequence of the
-- item id's.

-----------------------------------------------------------------------------
--/topic Events
--/const w32HEvent
--/desc An event (any type) has occured.
-- /i parms = { atom winmsg, atom wParam, atom lParam }
--
-- Before the events are processed by any of the trap routines or
-- default Windows routines, the w32HEvent is triggered.
--
-- If you want to skip the default Windows processing of the /i winmsg,
-- pass a value to the /returnValue() routine.

--/topic Events
--/const w32HAfterEvent
--/desc Occurs after normal Windows processing of an event (any type).
-- /i parms = { atom winmsg, atom wParam, atom lParam, atom lWinReturn }
--
-- After the message is processed by the Windows, Win32lib, and any event
-- handlers, this is triggered.
--
global constant
    w32CHG_Add = series:next_number("w32HChange"),
    w32CHG_Chg = series:next_number("w32HChange"),
    w32CHG_Del = series:next_number("w32HChange"),
    w32CHG_Sel = series:next_number("w32HChange")

integer vOnXXXSupport vOnXXXSupport = w32False
global sequence
    onMouse,
    onClick,
    onKeyPress,
    onKeyUp,
    onKeyDown,
    onResize,
    onChange,
    onGotFocus,
    onLostFocus,
    onScroll,
    onOpen,
    onActivate,
    onClose,
    onDestroy,
    onTimer,
    onPaint,
    onDragAndDrop,
    onEvent

    onMouse             = {}
    onClick             = {}
    onKeyPress          = {}
    onKeyUp             = {}
    onKeyDown           = {}
    onResize            = {}
    onChange            = {}
    onGotFocus          = {}
    onLostFocus         = {}
    onScroll            = {}
    onOpen              = {}
    onActivate          = {}
    onClose             = {}
    onDestroy           = {}
    onTimer             = {}
    onPaint             = {}
    onDragAndDrop       = {}
    onEvent             = {}

integer mainWindow
sequence vRecent vRecent = { 0, 0, 0, {-1}}
global constant
    w32RecentMenu = 1,
    w32RecentWindow = 2,
    w32RecentTabControl = 3,
    w32RecentForms = 4,
    w32GetMainWindow    = "GetMainWindow"

integer
    modalWindow,
    modalStyle,
    modalDepth
atom
    modalhWnd

sequence
    modalStack

    mainWindow  = 0     -- no main window set yet
    modalStack  = {}    -- modals under modal window
    modalWindow = 0     -- no modal windows
    modalhWnd   = 0     -- no modal window handles
    modalStyle  = 0     -- Modal Style
    modalDepth  = 0     -- Depth of the Dialog stack

-- controls
integer focus_current focus_current = -1
integer vPrevCtlBlkLength
sequence
    ctlblk_freelist,            -- A list of the free control blocks.
    ctrl_Handle,              -- hwnd of controls
    ctrl_Handle_type,         -- Type of handle
    ctrl_Destroyed,           -- true if destroyed
    ctrl_Function,                -- Long pointer to function
    ctrl_Family,              -- control class
    ctrl_Type,                -- win32lib type
    ctrl_Focus_order,         -- focus order of controls
    ctrl_Current_focus,               -- current focus
    ctrl_Previous_focus,          -- the previous current focus
    ctrl_Parent,               -- owner
    ctrl_Menu,                -- for windows: the menu id. for menus: self id
    ctrl_Popup,               -- records attached popmenus
    ctrl_Notify_List,            -- a list of ids that want to be notified of events
    ctrl_Toolbar,             -- toolbar in window
    ctrl_Statusbar,           -- statusbar in window
    ctrl_Hint_Text,             -- tooltip text or flattoolbar button's caption
    ctrl_Hint_Width,          -- tooltip width in pixels
    ctrl_Font,                -- font resource
    ctrl_Fg_Color,              -- foreground color
    ctrl_Bg_Color,              -- background color
    ctrl_Pen,                 -- pen: { id, color, style }
    ctrl_X_Pos,                   -- x position
    ctrl_Y_Pos,                   -- y position
    ctrl_Erase,               -- True if user self-erases background.
    ctrl_Scroll,              -- scroll: { small, large }  or {{vSmall, vLarge},{hSmall, hLarge}} for Windows
    ctrl_Range,               -- scroll range { low, high } or {{vLow, vHigh},{hLow, hHigh}} for Windows
    ctrl_Tabitems,            -- tabs in tab control
    ctrl_Group,               -- items grouped with window, but not owned
    ctrl_Cursor,              -- cursor associated with window
    ctrl_Hotkey_Keys,         -- hotkeys associated with the window
    ctrl_Hotkey_Ids,          -- ids associated with hotkeys
    ctrl_Text_Alignment,           -- alignment of text
    ctrl_Closed,              -- true if window has been closed.
    ctrl_TabKey_Used,          -- true if control uses raw tab keys,
	    	    --   false if CTRL-tabkey must be used.
    ctrl_Handlers,        -- Routine IDs for event handlers.
    ctrl_Bg_Brush,              -- Brush for background.
    ctrl_UserData,                 -- User defined data for control
    ctrl_IntData,                -- User defined data for control
    ctrl_Name,                -- User-defined name for this control
    ctrl_Deferred_Handlers,    -- A list of deferred handler references
    ctrl_Auto_Height,          -- Is this an auto height sizing control
    ctrl_Auto_Width,           -- Is this an auto width sizing control
    ctrl_Init_Posns,                -- Contains the initial children control positions
    ctrl_ClassAddr,               -- RAM Address of Window class name string
    ctrl_Mousetrap               -- List of target mousetraps in a window.

    -- initialize
    vPrevCtlBlkLength   = 3
    ctlblk_freelist     = {0}
    ctrl_Handle       = {}
    ctrl_Handle_type  = {}
    ctrl_Destroyed    = {}
    ctrl_Function         = {}
    ctrl_Family        = {}
    ctrl_Type         = {}
    ctrl_Focus_order  = {}
    ctrl_Current_focus        = {}
    ctrl_Previous_focus   = {}
    ctrl_Parent        = {}
    ctrl_Menu         = {}
    ctrl_Popup        = {}
    ctrl_Notify_List     = {}
    ctrl_Toolbar      = {}
    ctrl_Statusbar    = {}
    ctrl_Hint_Text      = {}
    ctrl_Hint_Width   = {}
    ctrl_Font         = {}
    ctrl_Fg_Color       = {}
    ctrl_Bg_Color       = {}
    ctrl_Pen          = {}
    ctrl_X_Pos            = {}
    ctrl_Y_Pos            = {}
    ctrl_Erase        = {}
    ctrl_Scroll       = {}
    ctrl_Range        = {}
    ctrl_Tabitems     = {}
    ctrl_Group        = {}
    ctrl_Cursor       = {}
    ctrl_Hotkey_Ids   = {}
    ctrl_Hotkey_Keys  = {}
    ctrl_Text_Alignment    = {}
    ctrl_Closed       = {}
    ctrl_TabKey_Used   = {}
    ctrl_Handlers = {}
    ctrl_Bg_Brush       = {}
    ctrl_UserData          = {}
    ctrl_IntData         = {}
    ctrl_Name         = {}
    ctrl_Deferred_Handlers = {}
    ctrl_Auto_Height   = {}
    ctrl_Auto_Width    = {}
    ctrl_Init_Posns         = {}
    ctrl_ClassAddr        = {}
    ctrl_Mousetrap       = {}

-- 'structure' indexes for user defined properties held in tag field.
constant tagPropId = 3, tagPropInit = 2, tagPropData = 1

constant CONTROLINFOS = series:next_number(0)
global constant
   CONTROLINFO_handle       = series:next_number(CONTROLINFOS),
   CONTROLINFO_handle_type  = series:next_number(CONTROLINFOS),
   CONTROLINFO_destroyed    = series:next_number(CONTROLINFOS),
   CONTROLINFO_func         = series:next_number(CONTROLINFOS),
   CONTROLINFO_class        = series:next_number(CONTROLINFOS),
   CONTROLINFO_type         = series:next_number(CONTROLINFOS),
   CONTROLINFO_focus_order  = series:next_number(CONTROLINFOS),
   CONTROLINFO_focus        = series:next_number(CONTROLINFOS),
   CONTROLINFO_owner        = series:next_number(CONTROLINFOS),
   CONTROLINFO_menu         = series:next_number(CONTROLINFOS),
   CONTROLINFO_toolbar      = series:next_number(CONTROLINFOS),
   CONTROLINFO_statusbar    = series:next_number(CONTROLINFOS),
   CONTROLINFO_tooltip      = series:next_number(CONTROLINFOS),
   CONTROLINFO_font         = series:next_number(CONTROLINFOS),
   CONTROLINFO_fcolor       = series:next_number(CONTROLINFOS),
   CONTROLINFO_bcolor       = series:next_number(CONTROLINFOS),
   CONTROLINFO_pen          = series:next_number(CONTROLINFOS),
   CONTROLINFO_x            = series:next_number(CONTROLINFOS),
   CONTROLINFO_y            = series:next_number(CONTROLINFOS),
   CONTROLINFO_erase        = series:next_number(CONTROLINFOS),
   CONTROLINFO_scroll       = series:next_number(CONTROLINFOS),
   CONTROLINFO_range        = series:next_number(CONTROLINFOS),
   CONTROLINFO_tabitems     = series:next_number(CONTROLINFOS),
   CONTROLINFO_group        = series:next_number(CONTROLINFOS),
   CONTROLINFO_cursor       = series:next_number(CONTROLINFOS),
   CONTROLINFO_hotkey_keys  = series:next_number(CONTROLINFOS),
   CONTROLINFO_hotkey_ids   = series:next_number(CONTROLINFOS),
   CONTROLINFO_textalign    = series:next_number(CONTROLINFOS),
   CONTROLINFO_closed       = series:next_number(CONTROLINFOS),
   CONTROLINFO_tabenabled   = series:next_number(CONTROLINFOS),
   CONTROLINFO_eventhandler = series:next_number(CONTROLINFOS),
   CONTROLINFO_bbrush       = series:next_number(CONTROLINFOS),
   CONTROLINFO_classinfo    = series:next_number(CONTROLINFOS),
   CONTROLINFO_tag          = series:next_number(CONTROLINFOS),
   CONTROLINFO_tooltipwid   = series:next_number(CONTROLINFOS),
   CONTROLINFO_lost_focus   = series:next_number(CONTROLINFOS),
   CONTROLINFO_itag         = series:next_number(CONTROLINFOS),
   CONTROLINFO_name         = series:next_number(CONTROLINFOS),
   CONTROLINFO_deferredhandlers = series:next_number(CONTROLINFOS),
   CONTROLINFO_autoheight   = series:next_number(CONTROLINFOS),
   CONTROLINFO_autowidth    = series:next_number(CONTROLINFOS),
   CONTROLINFO_init         = series:next_number(CONTROLINFOS),
   CONTROLINFO_popup        = series:next_number(CONTROLINFOS),
   CONTROLINFO_mousetrap    = series:next_number(CONTROLINFOS),
   CONTROLINFO_notifyid     = series:next_number(CONTROLINFOS)

constant
    kht_Window = 1,
    kht_Bitmap = 2,
    kht_Menu   = 3,
    kht_TabItem = 4,
    kht_ImageList = 5


-----------------------------------------------------------------------------
-- Tool tips
global integer
    tooltipControl     -- id of tooltip control
-- defaults
    tooltipControl  = 0
-----------------------------------------------------------------------------
-- Pen Colors

global constant
    Black           = rgb( #00, #00, #00 ),
    NavyBlue        = rgb( #00, #00, #60 ),
    Blue            = rgb( #00, #00, #80 ),
    BrightBlue      = rgb( #00, #00, #FF ),
    ForestGreen     = rgb( #00, #60, #00 ),
    Green           = rgb( #00, #80, #00 ),
    Cyan            = rgb( #00, #80, #80 ),
    SkyBlue         = rgb( #00, #80, #FF ),
    BrightGreen     = rgb( #00, #FF, #00 ),
    BrightCyan      = rgb( #00, #FF, #FF ),
    DarkGray        = rgb( #40, #40, #40 ),
    Eggplant        = rgb( #70, #20, #70 ),
    Red             = rgb( #80, #00, #00 ),
    Magenta         = rgb( #80, #00, #80 ),
    DarkBrown       = rgb( #80, #50, #00 ),
    Olive           = rgb( #80, #80, #00 ),
    Gray            = rgb( #80, #80, #80 ),
    Brown           = rgb( #B0, #70, #00 ),
    LightGray       = rgb( #C0, #C0, #C0 ),
    Purple          = rgb( #D0, #80, #D0 ),
    White           = rgb( #E0, #E0, #E0 ),
    BrightRed       = rgb( #FF, #00, #00 ),
    BrightMagenta   = rgb( #FF, #00, #FF ),
    Violet          = rgb( #FF, #80, #FF ),
    Orange          = rgb( #FF, #B0, #60 ),
    Pink            = rgb( #FF, #B0, #B0 ),
    Yellow          = rgb( #FF, #FF, #00 ),
    Parchment       = rgb( #FF, #FF, #E0 ),
    BrightWhite     = rgb( #FF, #FF, #FF )

vColorNames = {
    "BLACK",
    "NAVYBLUE",
    "BLUE",
    "BRIGHTBLUE",
    "FORESTGREEN",
    "GREEN",
    "CYAN",
    "SKYBLUE",
    "BRIGHTGREEN",
    "BRIGHTCYAN",
    "DARKGRAY",
    "EGGPLANT",
    "RED",
    "MAGENTA",
    "DARKBROWN",
    "OLIVE",
    "GRAY",
    "BROWN",
    "LIGHTGRAY",
    "PURPLE",
    "WHITE",
    "BRIGHTRED",
    "BRIGHTMAGENTA",
    "VIOLET",
    "ORANGE",
    "PINK",
    "YELLOW",
    "PARCHMENT",
    "BRIGHTWHITE"
}
vColorValues = {
    Black,
    NavyBlue,
    Blue,
    BrightBlue,
    ForestGreen,
    Green,
    Cyan,
    SkyBlue,
    BrightGreen,
    BrightCyan,
    DarkGray,
    Eggplant,
    Red,
    Magenta,
    DarkBrown,
    Olive,
    Gray,
    Brown,
    LightGray,
    Purple,
    White,
    BrightRed,
    BrightMagenta,
    Violet,
    Orange,
    Pink,
    Yellow,
    Parchment,
    BrightWhite,
    0  -- Default value.
}

--  Pen Styles
global constant
    Solid        = 0,
    Dash         = 1,                   --  -------
    Dot          = 2,                   --  .......
    DashDot      = 3,                   --  _._._._
    DashDotDot   = 4                    --  _.._.._

atom
    -- transparent color
    transColor,
    -- default font
    DefaultFontID  DefaultFontID = -1
sequence transTuple


constant
    -- null brush
    NullBrushID     = w32Func( xGetStockObject, { NULL_BRUSH } ),
    -- default pen
    DefaultPenID    = w32Func( xGetStockObject, {BLACK_PEN}),
    -- pen attributes
    PenColor        = 1,
    PenStyle        = 2,
    PenROP2         = 3,
    PenBkMode       = 4,
    PenWidth        = 5,
    PenBkColor      = 6,
    PenBrushColor   = 7,
    PenDefaults     = { Black, Solid, R2_COPYPEN, TRANSPARENT,
	         1, w32Color_BTNFACE, {}},
    -- font attributes
    FontName        = 1,
    FontSize        = 2,
    FontAttrib      = 3,
    FontColor       = 4
sequence FontDefaults

-- Grab the Win32lib default values from the system environment symbol "w32Defaults"

procedure GetDefaults()
    object lDefaults

    -- Hardcoded defaults.
    FontDefaults    = { "ms sans serif", 8, 0, Black }

    lDefaults = getenv("w32Defaults")
    if sequence(lDefaults) then
        lDefaults = w32MakeArgs(lDefaults, ',', ':')
        for i = 1 to length(lDefaults) do
            if equal(lDefaults[i][w32AKey], "FONT") then
                if length(lDefaults[i]) = 2 then
                    FontDefaults = lDefaults[i][w32AValue]
                    if length(FontDefaults) = 0 then
                        FontDefaults = {{{},"Arial"}}
                    end if
                    if length(FontDefaults) = 1 then
                        FontDefaults = append(FontDefaults, {{},8})
                    end if
                    if length(FontDefaults) = 2 then
                        FontDefaults = append(FontDefaults, {{},Normal})
                    end if
                    if length(FontDefaults) = 3 then
                        FontDefaults = append(FontDefaults, {{},Black})
                    end if
                end if
                for j = 1 to 4 do
                    FontDefaults[j] = FontDefaults[j][2]
                end for
            end if
        end for
    end if
end procedure
GetDefaults()

--/Topic Constants
--/const Default
--/desc Indicates the use of the Windows default position values when creating /Controls.

global constant
    Default = CW_USEDEFAULT,
    Center = "center"




--/topic System Attributes
--/func getMainWindow()
--/desc Gets the id of the main window for this application.
--/ret INTEGER: ID of main window.
--
--Example
--/code
--      win = getMainWindow()
--/endcode
global function getMainWindow()
    return mainWindow
end function
r_getMainWindow = routine_id("getMainWindow")

--/topic System Attributes
--/func setMainWindow(integer New)
--/desc Used to tell the library which window is the primary one.
--This is only used if you wish to change the default window that
--is set by calling /WinMain().
--
--Example
--/code
--      integer CurWin
--      CurWin = setMainWindow( AltWindow )
--/endcode

global function setMainWindow(integer pNew)
    integer lOld
    lOld = mainWindow
    mainWindow = pNew
    return lOld
end function


global function getRecent(integer pType)
    if find(pType, {w32RecentMenu, w32RecentWindow, w32RecentTabControl, w32RecentForms}) then
        return vRecent[pType]
    end if
    return 0
end function

--/topic System Attributes
--/func validId(object id)
--/desc Tests to see if the specified id is a valid one.
--/ret w32True if valid, w32False otherwise.

-----------------------------------------------------------------------------
global function validId( object id )
    -- returns true for valid Ids
  if not integer(id) then
    return w32False
  end if
  if id <= 0 then
    return w32False
  end if
  if id > length(ctrl_Handle) then
    return w32False
  end if
  if ctrl_Destroyed[id] < 0 then
    return w32False
  end if
  if ctrl_Handle[id] = 0 then
    return w32False
  end if
 if ctrl_Parent[id]=0 then
     return w32True
  end if
 return validId(ctrl_Parent[id])
end function
r_validId = routine_id("validId")

-----------------------------------------------------------------------------
procedure setId( atom hWnd, integer id )
    VOID = w32Func( xSetWindowLong, { hWnd, GWL_USERDATA, id } )
end procedure

--/topic Utilities
--/func getHandles()
--/desc Gets all the hWnd handles for every control created in your application.
--/ret A sequence of atoms.
--/code
--        addBtn = create(PushButton, "", 100,100, 40,40,0)
--        allHandles = getHandles()
--        otherfunc( allHandles[ addBtn ], ... )
--/endcode
global function getHandles()
    return ctrl_Handle
end function

-----------------------------------------------------------------------------
--/topic System Attributes
--/func getId( object hWnd )
--/desc Finds the control/window ID given a Window Handle.
--/ret INTEGER: The Id corresponding to the /i hWnd supplied.
-- If the supplied hWnd is invalid or not belonging to a control
-- created by win32lib, this function will return zero.
--
-- /b"Note 1" this can be used to find a TreeView Item's Id from it's handle by
-- using the syntax:  id = getId( {TV, hTVI} )
--
--/b"Note 2" if /i hWnd is the special value /b w32GetMainWindow, it will return the
-- Id of the main window as used in the /MainWin() routine. This is useful if you
-- are writing an add-on library to this one.
--


constant qGetWindowLong = define_c_func(open_dll("user32.dll"), "GetWindowLongA", {C_POINTER, C_LONG}, C_LONG)

global function getId( object hWnd )
    atom lId

    if sequence(hWnd) and length(hWnd) = 2 then
        return find( hWnd[2], tvitem_handle )
    elsif not equal(hWnd, w32GetMainWindow) then
        --lId = w32Func( xGetWindowLong, { hWnd, GWL_USERDATA } )
        lId = c_func(qGetWindowLong, {hWnd, GWL_USERDATA } )
        if not integer(lId) then
            lId = 0
        end if
        return lId
    else
        return mainWindow
    end if
end function

--/topic System Attributes
--/func getHWND(integer controlID)
--/desc Returns the Windows Handle of the specified control
--/ret The control's hWnd
-- This function is almost the same as /getHandle except that it does /b not
-- validate the /i controlID value supplied to it, and it cannot be used
-- to get the handle of a Treeview item. /n
-- You would use this function if you already knew that the /i controlID was
-- valid and you needed a faster routine than /getHandle.
--
--Example
--/code
--      atom hWnd
--      hWnd = getHWND(myWindow)
--/endcode

global function getHWND( object id )
    return ctrl_Handle[ id ]
end function

-----------------------------------------------------------------------------
--/topic System Attributes
--/func getHandle(integer controlID OR sequence {TVid, TVItemID} )
--/desc Returns the Windows Handle of the specified control
--/ret The control's hWnd
-- This aborts the application if the specified id is invalid.
--
-- This can also return the handle of a treeview item by using the
-- syntax {tv, tvitem}
--
--Example
--/code
--      atom hWnd, hTV
--      hWnd = getHandle(myWindow)
--      hTV = getHandle( {myTreeView, Itemx} )
--/endcode

global function getHandle( object id )
    atom hWnd
    -- return the handle for the window
    -- generates warning if not a valid id or handle
    -- in range?

    -- Special case. A zero id returns a zero handle.
    if equal(id, 0) then
        return 0
    end if

    if sequence(id) and
        length(id) = 2 and
        validId(id[1]) and
        ctrl_Type[id[1]] = TreeView and
        id[2] > 0 and
        id[2] <= length(tvitem_handle) and
        tvitem_owner[id[2]] = id[1] then
            return tvitem_handle[id[2]]
    end if

    if validId( id ) then
        -- Get the stored value of the handle.
        if ctrl_Type[id] = TabItem then
            -- Use the tab control's handle.
            hWnd = ctrl_Handle[ ctrl_Parent[ id ] ]
        else
            hWnd =  ctrl_Handle[ id ]
        end if

        -- if its a control handle, then getID must work too.
        if  ctrl_Handle_type[ id ] != kht_Window
         or getId(hWnd) = id then
            if hWnd = -1 then
                hWnd = 0
            end if
        else
            warnErr( append(Err_GETHCHANGED, {id, getId(hWnd)} ))
        end if
        return hWnd

    else
        if compare(id,0) > 0 and compare(id,length(ctrl_Handle)) <= 0  then
            if ctrl_Destroyed[id] < 0 then
        	    warnErr( Err_GETHOBJECTDESTROYED )
            end if

            if ctrl_Handle[id] = 0 then
    	        warnErr( Err_GETHNULLHANDLE )
            end if
        end if

        warnErr( Err_GETHFAIL )
    end if

    return 0 -- Bad handle
end function
r_getHandle = routine_id("getHandle")


--/topic System Attributes
--/func getIdName(integer controlID)
--/desc Returns the name of a control, given it's id.
--/ret SEQUENCE: The control's name /b or INTEGER: No name available.
--/b "Also see:" /setIDName and /newUIObj
--
--A return of "" means that the /i controlID was not valid. /n
--A return of 0 means that the /i controlID has no name.
--
--Example
--/code
--      sequence name
--      name = getIdName(myWindow)
--/endcode

global function getIdName(integer id)
    if validId(id) then
        return ctrl_Name[id]
    else
        return ""
    end if
end function

--/topic Miscellaneous
--/func makeStandardName(sequence Name)
--/desc Transforms a string into a standardized format suitable for naming things.
--/ret SEQUENCE: A Standard Name format
--/i Name is any string. It is converted to a standard form by removing any characters
--that are not alphanumeric, except that the first character can only be alphabetic or
-- the underscore character.
--
--Example:
--/code
--      sequence lName
--      lName = makeStandardName("Customer Dialog #1")
--      -- This should return "CustomerDialog1"
--/endcode

global function makeStandardName(sequence pName)
    integer i

    pName = w32trim(pName)
    -- Remove any chars that cannot be in names.
    i = 1
    while i <= length(pName) do
        if not w32CType(pName[i], NameChar_CT) then
            pName = w32removeIndex(i, pName)
        else
            if i = 1 and (w32CType(pName[1], Digit_CT) or w32CType(pName[1], Punct_CT)) then
                pName = w32removeIndex(1, pName)
            else
                i += 1
            end if
        end if
    end while

    return pName
end function

--/topic System Attributes
--/proc setIdName(integer controlID, sequence Name)
--/desc Sets the name of a control, given it's id.
--/b "Also see:" /getIDName and /newUIObj /n
-- This routine ensures that only alphanumeric and '_' characters are in the name. All
-- other characters stripped off the /Name parameter.
--
--Example
--/code
--      sequence name
--      setIdName(myWindow, "Prime Window")
--/endcode

global procedure setIdName(integer id, sequence pName)
    ctrl_Name[id] = makeStandardName(pName)
end procedure

--/topic System Attributes
--/func getNameId(sequence Name)
--/desc Returns the id of a control, given it's name.
--/ret SEQUENCE: The control's ID.
--/b "Also see:" /setIdName, /getIdName and /newUIObj
--
--A return of zero indicates that the name was not found. /n
--If more than one control has the same name, the result is
--still returned but it may be any of those controls. In this
--case it might be better to use /getNameIdInContext().
--
--Example
--/code
--      integer id
--      id = getNameId("Prime Window")
--/endcode

global function getNameId(sequence pName)
    return find(makeStandardName(pName), ctrl_Name)
end function

--/topic System Attributes
--/func getNameIdInContext(sequence Name, integer Parent)
--/desc Returns the id of a control, given it's name and parent control.
--/ret SEQUENCE: The control's ID.
--/b "Also see:" /setIdName, /getNameId, /getIdName and /newUIObj
--
--A return of zero indicates that the name was not found.
--
--Example
--/code
--      integer id
--      id = getNameIdInContext("AcceptButton", CustomerWindow)
--/endcode

global function getNameIdInContext(sequence pName, object pParent)
    integer lParent
    sequence lName
    sequence lDependents
    integer  lEnd, lStart

    -- Standardize the supplied name.
    lName = makeStandardName(pName)


    -- Build a list of candidate controls
    if sequence(pParent) then
        pParent = getNameId(makeStandardName(pParent))
    end if
    if pParent <= 0 then
        if vRecent[w32RecentWindow] > 0 then
            pParent = vRecent[w32RecentWindow]
        elsif mainWindow > 0 then
            pParent = mainWindow
        else
            pParent = 1
        end if
    end if
    lDependents = {pParent}
    lStart = 1
    lEnd = 0
    while lEnd < length(lDependents) do
        lEnd = length(lDependents)
        for i = lStart to lEnd do
            lDependents &= ctrl_Group[lDependents[i]]
        end for
        lStart = lEnd + 1
    end while

    -- Start searching for the name in this context.
    for i = 1 to length(lDependents) do
        lStart = lDependents[i]
        if equal(lName, ctrl_Name[lStart]) then
            return lStart
        end if
    end for

    return 0

end function

--/topic Low Level Routines
--/func sendMessage( object id, atom command, object wParam, object lParam )
--/desc Send a Win32 message to the requested control.
--/ret ATOM: Win32 result code.
--
-- /i id is either a control ID, or a control Name. /n
-- /i command is the Windows Message code to send. /n
-- /i wParam and lParam are the appropriate data items for the specific
-- /i command you are sending. These can be either atom values or text strings.
--
--There are hundreds of Windows message codes. Each type of control responds to
-- commands that are specific to it. There are too many to document here but
-- they can be found in many publications - the easiest might be the Microsoft
-- SDK documentation found at /b "http://msdn.microsoft.com"
--
--Example:
--/code
--      res = sendMessage(myToolbar, TB_ADDSTRING, 0, "Test String" )
--/endcode

constant qSendMessage = define_c_func(open_dll("user32.dll"),
          "SendMessageA", {C_POINTER, C_UINT, C_LONG, C_LONG}, C_LONG)

global function sendMessage( object id, atom pCmd, object wParm, object lParm )
    -- send a command to a control
    atom memset
    atom lRetVal

    if sequence(id) then
        id = getNameId(id)
    end if

--    if validId(id) then
--    if id > 0 then
        memset = 0
        -- Check for text being passed.
        if sequence(wParm) then
            memset = w32new_memset()
            wParm = w32acquire_mem(memset, wParm)
        end if
        if sequence(lParm) then
            if memset = 0 then
                memset = w32new_memset()
            end if
            lParm = w32acquire_mem(memset, lParm)
        end if

        lRetVal = c_func( qSendMessage, { ctrl_Handle[id], pCmd, wParm, lParm } )
        if memset != 0 then
            w32release_mem(memset)
        end if
        return lRetVal
--    else
--        return 0
--    end if
end function

-----------------------------------------------------------------------------
procedure pushSelf( integer id )
    -- push the current self and return value onto stack
    if SP = length(idStack) then
        idStack &= repeat(0, 10)
        returnStack &= repeat(0, 10)
    end if
    SP += 1
    idStack[SP] = id
    returnStack[SP] = 0
end procedure

-----------------------------------------------------------------------------
function popSelf()
    -- pop the current id from the stack
    -- return the return value

    -- get the return value
    if SP <= 0 then
        abortErr(Err_STACKERR)
    end if

    -- pop the self and return stacks
    SP -= 1
    return returnStack[SP+1]

end function

-----------------------------------------------------------------------------
--/topic Events
--/proc returnValue( value )
--/desc Override default value returned by handler.
-- This allows you to override the value an event handler returns to Win32.
-- By default, when an event is processed, it goes through these steps:
--
-- /li /onEvent: If there is an /onEvent handler for this control, it
--          is passed the event.
-- /li Event Trap: If there is a specific handler for this event, that
--          handler is triggered. For example, /b WM_SETFOCUS triggers
--          /onGotFocus, /b WM_SIZE triggers /onResize, etc.
-- /li Default Windows Handler: Finally, the default Window handler for
--          the control is called. In the case of subclassed /controls,
--          /i CallWindowProc calls the normal handler; for /windows,
--          /i DefWindowProc is called.
--
-- Setting /returnValue causes processing to stop at the step that the
-- value was set in, and return that value to Windows.
--
-- Example:
--
--/code
--          -- prevent Button1 from seeing any space bar keys
--          procedure Button1_KeyDown( integer self, integer event, sequence parms)
--              integer keycode
--              integer shift
--              keycode = parms[1]
--              shift = parms[2]
--              if keycode = VK_SPACE then
--                  -- set return value
--                  /returnValue( w32True )
--              end if
--          end procedure
--          /setHandler( Button1, w32HKeyDown, routine_id("Button1_KeyDown"))
--/endcode

global procedure returnValue( object returns )
    -- change the return value of the current control
    if SP <= 0 then
        abortErr(Err_STACKERR)
    end if

    returnStack[SP] = {returns}
end procedure

--/topic Events
--/proc resetReturnValue( )
--/desc Removes any value returned by handler.
--
--Example
--/code
--      resetReturnValue()
--/endcode
global procedure resetReturnValue( )
    -- change the return value of the current control
    if SP <= 0 then
        abortErr(Err_STACKERR)
    end if

    returnStack[SP] = 0
end procedure

-----------------------------------------------------------------------------
--/topic Events
--/func getReturnValue( )
--/desc Gets the current value of the value that will be returned to Windows.
--/ret OBJECT: A sequence if set by an event handler, otherwise an atom.
--
--Example:
--/code
--      object rv
--      -- Set a return value if not already set.
--      rv = getReturnValue()
--      if not sequence(rv) then
--          returnValue(-1)
--      end if
--/endcode
global function getReturnValue(  )
    -- gets the current return value of the current control
    if SP < 0 then
        abortErr(Err_STACKERR)
    elsif SP = 0 then
        return 0
    end if

    return returnStack[SP]
end function

-----------------------------------------------------------------------------
--/topic Events
--/func setCallback( integer routineID)
--/desc gets and sets the application's generic callback routine id
--/ret INTEGER: The current value of the application's callback routine id.
--/i routineID is either -1 or a valid routine id. /n
--This sets the application's callback routine id and returns the old
--value. /n
--The application may call the callback routine for a number of reasons
--during the running of a program. It is mainly used to get information
--needed by Win32Lib that it has not received so far.
--
--The callback routine must be a /b procedure that takes three parameters:- /n
-- /b integer /i self /n
-- /b integer /i event /n
-- /b sequence /i data /n
--
--The contents of the parameters passed to the callback routine depend on
-- the value of the /i event parameter. /n
--When /i event /b"= w32HGetHandler" is called when Win32lib needs an event handler
-- to be associated for a specific control's event. This comes about when using
-- the "events=..." parameter in the /newUIObj routine./n
--The /i data contains three values... /n
-- [1] A string in the form ~<eventname>_~<controlname>, eg. "Click_OkayBtn" /n
-- [2] An integer with the symbolic event code, eg. w32HClick /n
-- [3] A string containing the control's name. /n
--And the /i self parameter contains the control-id for the control needing
-- the handler routine.
--
--Example
--/code
--      integer oldrtn
--      oldrtn = setCallback(routine_id("AppCallback"))
--/endcode
global function setCallback(integer pRoutineID)
    integer lOldRtn

    lOldRtn = r_AppCallback
    r_AppCallback = pRoutineID

    return lOldRtn
end function

-----------------------------------------------------------------------------
--/topic Events
--/func invokeHandler( integer id, integer event, sequence params)
--/desc Triggers a Win32Lib event.
--/ret OBJECT: The value set by returnValue() if called inside
--the handler, zero otherwise.
--
--Example:
--/code
--      object rv
--      -- Simulate a button press on the Close Button.
--      rv = invokeHandler(btnClose, w32HClick, {})
--      if not sequence(rv) then
--          closeWindow(mainWin)
--      end if
--/endcode

global function invokeHandler(integer id, integer event, sequence params)
    sequence lRoutines
    integer  lCallType
    integer lPos
    sequence lNotify
    integer lRecvr

    if validId(id) = w32False then
        return 0
    end if

    pushSelf(id)
    lRoutines = {}
    lCallType = 1

    -- Check for any 'screen' event first.
    if length(ctrl_Handlers[Screen][event]) > 0 then
	    lRoutines = append(lRoutines,ctrl_Handlers[Screen][event])
    end if

    -- And now for any control-owned event
    if id != Screen and length(ctrl_Handlers[id][event]) > 0 then
        lRoutines = append(lRoutines,ctrl_Handlers[id][event])
    end if

    if length(lRoutines) = 0 and vOnXXXSupport = w32True then
        lCallType = 2
        if event = w32HMouse then
            if id != Screen and onMouse[Screen] >= 0 then
	            lRoutines &= onMouse[Screen]
            end if

            lRoutines &= onMouse[id]
            -- Mouse Wheel not supported for onXXX
            params = params[1..4]
        elsif event = w32HClick then
            if id != Screen and onClick[Screen] >= 0 then
    	        lRoutines &= onClick[Screen]
            end if

            lRoutines &= onClick[id]
            params = {}

        elsif event = w32HKeyPress then
            if id != Screen and onKeyPress[Screen] >= 0 then
                lRoutines &= onKeyPress[Screen]
            end if

            lRoutines &= onKeyPress[id]
        elsif event = w32HKeyUp then
            if id != Screen and onKeyUp[Screen] >= 0 then
                lRoutines &= onKeyUp[Screen]
            end if

            lRoutines &= onKeyUp[id]
        elsif event = w32HKeyDown then
            if id != Screen and onKeyDown[Screen] >= 0 then
	            lRoutines &= onKeyDown[Screen]
            end if

            lRoutines &= onKeyDown[id]
        elsif event = w32HResize then
            if id != Screen and onResize[Screen] >= 0 then
    	        lRoutines &= onResize[Screen]
            end if

            lRoutines &= onResize[id]
        elsif event = w32HChange then
            if id != Screen and onChange[Screen] >= 0 then
                lRoutines &= onChange[Screen]
            end if

            lRoutines &= onChange[id]
            -- Strip off extra parameters that would break old usage.
            params = {}
        elsif event = w32HGotFocus then
            if id != Screen and onGotFocus[Screen] >= 0 then
                lRoutines &= onGotFocus[Screen]
            end if

            lRoutines &= onGotFocus[id]
        elsif event = w32HLostFocus then
            if id != Screen and onLostFocus[Screen] >= 0 then
	            lRoutines &= onLostFocus[Screen]
	            params = {} -- focusControl is not supported with onXXX.
            end if

            lRoutines &= onLostFocus[id]
        elsif event = w32HScroll then
            if id != Screen and onScroll[Screen] >= 0 then
    	        lRoutines &= onScroll[Screen]
            end if

            lRoutines &= onScroll[id]
            -- Strip off extra parameters that would break onScroll usage.
            params = {params[1]}

        elsif event = w32HOpen then
            if id != Screen and onOpen[Screen] >= 0 then
                lRoutines &= onOpen[Screen]
            end if

            lRoutines &= onOpen[id]
        elsif event = w32HActivate then
            if id != Screen and onActivate[Screen] >= 0 then
                lRoutines &= onActivate[Screen]
            end if

            lRoutines &= onActivate[id]
        elsif event = w32HClose then
            if id != Screen and onClose[Screen] >= 0 then
	            lRoutines &= onClose[Screen]
            end if

            lRoutines &= onClose[id]
        elsif event = w32HDestroy then
            if id != Screen and onDestroy[Screen] >= 0 then
    	        lRoutines &= onDestroy[Screen]
            end if

            lRoutines &= onDestroy[id]
        elsif event = w32HTimer then
            if id != Screen and onTimer[Screen] >= 0 then
                lRoutines &= onTimer[Screen]
            end if

            lRoutines &= onTimer[id]
        elsif event = w32HPaint then
            if id != Screen and onPaint[Screen] >= 0 then
                lRoutines &= onPaint[Screen]
            end if

            lRoutines &= onPaint[id]
        elsif event = w32HDragAndDrop then
            if id != Screen and onDragAndDrop[Screen] >= 0  then
	            lRoutines &= onDragAndDrop[Screen]
            end if

            lRoutines &= onDragAndDrop[id]
        elsif event = w32HEvent then
            if id != Screen and onEvent[Screen] >= 0 then
    	        lRoutines &= onEvent[Screen]
            end if

            lRoutines &= onEvent[id]
        end if
    end if

    for i = 1 to length(lRoutines) do
        if not equal(lRoutines[i],-1) then
            if lCallType = 1 then
                for j = 1 to length(lRoutines[i]) do
                    call_proc(lRoutines[i][j], {id, event, params})
                end for
            else
                -- onXXX interface
                call_proc(lRoutines[i], params)
            end if
        end if
    end for

    -- Check if any notifications are required.
    if event != w32HNotify then
        -- Avoid recursive notifications!
        lNotify = ctrl_Notify_List[id][1]

        for i = 1 to length(lNotify) do
            lRecvr = lNotify[i]
            lPos = find(event, ctrl_Notify_List[id][2][i])
            if lPos then
                VOID = invokeHandler(lRecvr, w32HNotify,
                        {id, event,ctrl_Notify_List[id][3][i][lPos],params })
            end if
        end for
    end if

    return popSelf()
end function

--/topic Events
--/proc setHandler( object id, object htype, object routine)
--/desc Sets up an user written event handler
--/i id is the ID of the control that the event applies to. /n
--/i htype is the type of event to trap. /n
--/i routine is the routine_id of the user written code that will handle
-- the event.
--
-- /b Note that /i id can be a sequence of ids. You would do this if they all
-- shared the same handler code. /n
-- /b Note that /i htype can be a sequence of event codes. You would do this
-- if the same handler code is to be invoked for different events. /n
-- /b Note that /i routine can be a sequence of routine_id() values. You
-- would do this to set a chain of routines that are triggered for each
-- event listed in /i htype. /n
-- This routine actually adds the handler's routine_id to the end of a list
-- of such routines for this ID and Event combination. This way, you can
-- chain together independantly written routines to fire for the same
-- id and same events.
--
-- A special note. To remove the current chain, set /i routine to -1. To clear
-- the existing chain before setting a new one, you can also pass /i routine
-- as {-1, routine_id("myhandler")}
--
-- /b "How the Event Handler subsystem works" /n
-- The Win32lib library receives various events notifications from Windows.
-- If an event handler has been set up for the specific control-event
-- combination, the library invokes the user written routine before
-- continuing. Each event handler is a procedure that is passed three
-- parameters by the library. /n
-- 1) integer /i ID. The control id that the event applies to. /n
-- 2) integer /i Event. The event code that invoked this routine. This
-- enables a single routine to handler multiple event types. /n
-- 3) sequence /i Params. This is a list of zero or more parameters
-- associated with the specific event. For example, a w32HKeyDown event will
-- have the keycode and shift mask in these parameters.
--
--Example
--/code
--  -- Set a single routine to be triggered by one type of event.
--  setHandler(myWindow, w32HPaint, routine_id("repaintWindow"))
--
--  -- Set the same handler for two different buttons.
--  setHandler( {btn1, btn2}, w32HClick, routine_id("click_buttons"))
--
--  -- Set the same handler for two different events.
--  setHandler( btn1, {w32HClick, w32HKeyPress}, routine_id("click_buttons"))
--
--  -- Set a chain of handlers.
--  setHandler( btn1, w32HClick, routine_id("click_buttons"))
--  if DebugSwitch = w32True then
--      -- add a second routine to be called.
--      setHandler( btn1, w32HClick, routine_id("Debugger"))
--  end if
--/endcode

global procedure setHandler( object id, object htype, object routine)
    integer lTemp
    integer lControl
    integer lEvent
    integer lWhere

    if atom(id) then
        id = {id}
    end if

    if atom(htype) then
        htype = {htype}
    end if

    if atom(routine) then
        routine = {routine}
    end if

    for i = 1 to length(id) do
        lControl = id[i]
        for j = 1 to length(htype) do
            lEvent = htype[j]
            if validId(lControl)
              and lEvent > 0
              and lEvent <= w32LastEventType then

                -- Special for Combo boxes and dragging.
                if lEvent = w32HDragAndDrop then
                    lTemp = call_func(r_getEdit,{lControl})
                    if lTemp != 0 then
                        -- Set the same handler for the Combo's editbox.
                        setHandler(lTemp, htype, routine)
                    end if
                elsif find(lEvent, {w32HBreak, w32HPause, w32HIdle}) then
                    -- These must only apply to the screen control.
                    lControl = Screen
                end if

                lWhere = 1
                for k = 1 to length(routine) do
                    if routine[k] = -1 then
                        if k = 1 then
                            -- Clear any existing list of handlers.
                            ctrl_Handlers[lControl][lEvent] = {}
                        end if
                    elsif routine[k] = -2 then
                        lWhere = -1
                    else
                        -- Add this routine (if not already there) into the list.
                        if find(routine[k], ctrl_Handlers[lControl][lEvent]) = 0 then
                            if lWhere = 1 then
        	                    ctrl_Handlers[lControl][lEvent] &= routine[k]
        	                else
        	                    -- Force it to be at the head of the handler list.
        	                    ctrl_Handlers[lControl][lEvent] = routine[k] & ctrl_Handlers[lControl][lEvent]
        	                end if
        	            end if
        	        end if
        	    end for
            end if
        end for
    end for

    -- Shutdown onXXX if any handler is set.
    vOnXXXSupport = w32False
end procedure

--/topic Events
--/func getHandler( integer id, integer htype)
--/desc Gets the event handler(s) defined for a control.
--/ret SEQUENCE: A list of handlers defined so for this control event.
--
--/i id is the ID of the control that the event applies to. /n
--/i htype is the type of event being handled. /n
--
--Example
--/code
--       object hl
--       -- Make sure my handler is installed before any others.
--       hl = getHandler(myWindow, w32HPaint)
--       -- Chain mine to the front.
--       setHandler(myWindow, w32HPaint, -1 & routine_id("mypainter") & hl)
--/endcode

global function getHandler( integer id, integer htype)
    if validId(id) and htype >= 0 and htype <= w32LastEventType then
        return ctrl_Handlers[id][htype]
    else
        return {}
    end if
end function

--/topic Events
--/proc removeHandler( object id, object htype, object routine)
--/desc Removes user written event handlers previously set with /setHandler()
--/i id is one or more control IDs. /n
--/i htype is one or more event types. /n
--/i routine is one or more routine_ids previously set for the control-event combinations
-- in the previous parameters.
--
-- You use this routine to get rid of a handler that had been established earlier.
--
--Example:
--/code
--      removeHandler( {Btn1, Btn2}, w32HClick, routine_id("CommonHandler"))
--/endcode
global procedure removeHandler(object id, object pEvent, object pRoutine)
	integer lControl, lEvent, lIndex
	sequence lHandlers, lRoutines

	if atom(id) then
        id = {id}
    end if
	if atom(pEvent) then
        pEvent = {pEvent}
    end if
	if atom(pRoutine) then
        pRoutine = {pRoutine}
    end if

	for i=1 to length(id) do
		lControl = id[i]
		if validId(lControl) then
			lHandlers = ctrl_Handlers[id[i]]
			for j= 1 to length(pEvent) do
				lEvent = pEvent[j]
				if lEvent > 0 and lEvent <= w32LastEventType then
					lRoutines = lHandlers[lEvent]
					for k= 1 to length(pRoutine) do
						lIndex = find(pRoutine[k], lRoutines)
						if lIndex > 0 then
							lRoutines = lRoutines[1..lIndex-1] &  lRoutines[lIndex+1..length(lRoutines)]
						end if
					end for
					lHandlers[lEvent] = lRoutines
				end if
			end for
			ctrl_Handlers[id[i]] = lHandlers
		end if
	end for
end procedure

-----------------------------------------------------------------------------
--/topic Events
--/func onXXX( integer flag )
--/desc Sets the support for the onXXX[] syntax.
--/ret INTEGER: The current setting of this support.
--
-- By default, the library supports the onXXX syntax but this will
-- change with version 0.70. From then, the default will be /b not to support
-- this interface and then you will have to explictly turn it on via
-- this function.
--
-- Support for the onXXX syntax will be removed from the library from version 1.0 onwards.
--
-- /b Note: Using onXXX support is much slower than  using the /setHandler() syntax.
--
-- If you choose to turn onXXX support off, you must use /setHandler()
-- and all your onXXX[] routine_ids will be ignored.
--
-- Also note that any call to /setHandler will turn /b off onXXX support. So if you need to
-- mix both syntaxes, you must call onXXX(1) after your last setHandler() call.
--
--Example:
--/code
--      integer lOld
--      -- Turn off onXXX support.
--      lOld = onXXX (w32False)
--/endcode
global function onXXX(integer flag)
    integer lOld

    lOld = vOnXXXSupport
    vOnXXXSupport = w32iff(flag = 0, w32False, w32True)

    return lOld
end function

------------------------------------------------------------------
procedure ResolveDeferredHandler(integer id)
------------------------------------------------------------------
    sequence lEventName
    object lRtnId
    sequence lRoutineName
    integer lPos
    integer lEvent
    object lTemp

    if r_AppCallback < 0 then
        return
    end if

    pushSelf(id)
    lPos = 1

    while lPos <= length(ctrl_Deferred_Handlers[id]) do
        lEvent = ctrl_Deferred_Handlers[id][lPos]
        lEventName = w32lookup(lEvent, vEventCodes, vEventNames)
        if length(lEventName) > 0 then
            if lPos != length(ctrl_Deferred_Handlers[id]) and
               sequence(ctrl_Deferred_Handlers[id][lPos+1]) then
                lPos += 1
                lRoutineName = ctrl_Deferred_Handlers[id][lPos]
            else
                lRoutineName = lEventName & '_' & getIdName(id)
            end if
            if not find(r_autoclose,ctrl_Handlers[id][lEvent]) then
                call_proc(r_AppCallback, {id, w32HGetHandler, {
                                lRoutineName,
                                lEvent,
                                getIdName(id)}
                                        })
                lRtnId = getReturnValue()
                if sequence(lRtnId) then
                    lTemp = vOnXXXSupport
                    setHandler(id, lEvent, lRtnId[1])
                    vOnXXXSupport = lTemp
                    resetReturnValue()
                end if
            end if
        end if
        lPos += 1
    end while
    VOID = popSelf()
    -- Clear the list of events to resolve.
    ctrl_Deferred_Handlers[id] = {}
end procedure


-----------------------------------------------------------------------------
-----------------------------------------------------------------------------
-- RESOURCE TRACKING
--
-- This is used to track GDI resources held by the application.
-- This module is defined early on so that on an abortErr, the
-- code can still run the cleanup.

--/topic Resources
--/const ForPaint
--/desc Indicates that the resource lives until the end of the onPaint operation.

--/topic Resources
--/const ForProgram
--/desc Indicates that the resource lives until the end of the program.

global constant
    ForPaint   = -1,    -- resource lives until end of onPaint
    ForProgram = -2     -- resource lives until end of program

global constant
    ResSTRUCT   = series:next_number(0),
    ResHandle   = series:next_number(ResSTRUCT),    -- Win32 handle (primary key)
    ResOwner    = series:next_number(ResSTRUCT),    -- the resource WinLib id
    ResLife     = series:next_number(ResSTRUCT),    -- how long the resource lives
    ResObjType  = series:next_number(ResSTRUCT),    -- Type of resource being tracked.
    ResCnt      = series:next_number(ResSTRUCT),    -- Number of times tracked.
    ResTag      = series:next_number(ResSTRUCT),    -- Optional user supplied data
    ResStatus   = series:next_number(ResSTRUCT),    -- Optional user supplied data
    NewRes      = repeat( 0, series:current_number(ResSTRUCT) ),

    enumObject = series:next_number(0),
    kPenObject = series:next_number(enumObject),
    kBrushObject = series:next_number(enumObject),
    kFontObject = series:next_number(enumObject),
    kBitmapObject = series:next_number(enumObject),
    kIconObject = series:next_number(enumObject),
    kObjectTypes = {kPenObject,kBrushObject, kFontObject,
                    kBitmapObject, kIconObject},
    kNewDC = 0 & repeat({}, series:current_number(enumObject)),

    kUnknownObject = 0,
    kTrackedID = 1,
    kTrackedCurDC = 2,
    kTrackedDCCnt = 1,
    kTrackedDCHdl = 2,
    kTrackedDCSaved = 3,
    kTrackedDCReason = 4,
    kDCReasonApp = 1,
    kDCReasonPaint = 0


sequence
    heldResource,   -- list of held resources, and their scope
    heldCursor,     -- list of held cursors
    vHRFree         -- list of free spots in heldResource
integer vHRI

sequence grabbedHDC
    grabbedHDC = {}

-- This variable is used to help debugging of resources. It is not
-- 'used' in the library itself.


    -- initialize
    heldResource    = {}
    heldCursor      = {}
    vHRFree = {}
    vHRI = 0

--/topic Fonts
--/func setFontWeight( integer pNewWeight)
--/desc Sets what you mean by 'bold' when using /setFont(..., /i Bold )
--/ret The font weight setting before you changed it.
-- Use can use the following names for the standard font weights... /n
--/li FW_DONTCARE  Sets to the Windows default.
--/li FW_THIN
--/li FW_EXTRALIGHT /i aka FW_ULTRALIGHT
--/li FW_LIGHT
--/li FW_NORMAL /i aka FW_REGULAR
--/li FW_MEDIUM
--/li FW_SEMIBOLD /i aka FW_DEMIBOLD
--/li FW_BOLD /i"The default for Win32lib"
--/li FW_EXTRABOLD /i aka FW_ULTRABOLD
--/li FW_HEAVY /i aka FW_BLACK
--
-- Note, if you call this function with /i pNewWeight set to -1, the current
-- weight value is returned without changing it.
--
-- For video devices, there is not much difference in the rendering, but on other devices
-- it might make a difference.
--
-- Example:
--/code
--    integer lOldWeight
--    lOldWeight = setFontWeight(FW_LIGHT)
--    /setFont(aControl, "Courier New", 12, Bold)
--
--/endcode
------------------------------------------------------------------------------
global function setFontWeight( integer pNewWeight)
integer
     lOldWeight

   lOldWeight = vFontWeight

   if pNewWeight >= 0
   then
      pNewWeight = 100 * floor((pNewWeight + 99)/100)
      if pNewWeight > FW_HEAVY
      then
     pNewWeight = FW_HEAVY
      end if

      vFontWeight = pNewWeight
   end if

   return lOldWeight
end function


sequence vStockResources
vStockResources = {DefaultFontID, DefaultPenID, NullBrushID}
for i = 0 to STOCK_LAST  do
   vStockResources &= i
end for

-----------------------------------------------------------------------------
function isStockResource( atom a )
    -- returns true if a is a stock object
    -- any resource created with GetStockObject should be added here

    return find(a, vStockResources)
end function


sequence vDCs vDCs = {}
integer vMaxPenCache vMaxPenCache = 20

--/topic Resources
--/info
-- This set of routines helps you to manage Windows resources.
--
-- A number of different types of resources are used in Windows programmming. The
-- main ones are GDI objects, such as Fonts, and Brushes.
--
-- Whenever a resource is created by the library, it is tracked so that it can be released back to
-- Windows when finished with. Typically, a resource is created when you call a drawing routine or
-- change a font, and a resource is deleted when the drawing routine is fininshed or replaced with
-- another resource of the same type.


--/topic Resources
--/proc deleteObject( object resource )
--/desc Deletes a Windows GDI resource.
-- /i resource is the Handle of the object to be deleted.
global procedure deleteObject( object resource )
    atom lObject
    -- deletes an object if not a stock resource
    -- removes it from the tracking list
    integer at
    integer lDelete
    atom lRC

    if atom(resource) then
        lObject = resource
        lDelete = w32True
    else
        lObject = resource[1]
        lDelete = resource[2]
    end if

    -- Stock resources are not tracked.
    if isStockResource( lObject ) then
        return
    end if

    -- Was a real delete requested?
    if (lDelete = w32True) then
        VOID = w32Func( xDeleteObject, {lObject} )
    end if

    -- is this a known resource?
    at = w32findKey( lObject, heldResource )
    if (at != 0) then
        -- remove from my list of held resources --
        heldResource[at][ResHandle] = 0  -- Invalidate entry
        heldResource[at][ResStatus] = 0  -- Invalidate entry
        vHRI += 1 -- Point to next freelist entry
        vHRFree[vHRI] = at -- Update free list
    end if

end procedure

-----------------------------------------------------------------------------
--/topic Resources
--/func findTrackedObject( integer pOwner, sequence pTag )
--/desc Looks amongst the tracked objects for one that matches the criteria.
--/ret A sequence containing a list of resources matching the criteria.
-- /i pOwner is the /b ID of the control that owns the resource being tracked. /n
-- /i pTag is the 'tag' data stored with the resource when it was first tracked.
-- If this is an empty sequence, all resources for this /i pOwner will be returned.
global function findTrackedObject( object pOwner, sequence pTag)
    sequence lResult
    sequence lResource

    lResult = {}
    for i = 1 to length(heldResource) do
        lResource = heldResource[i]
        if lResource[ResStatus] = 1 and equal(lResource[ResOwner], pOwner)  then
            if length(pTag) > 0 then
                if equal(pTag, lResource[ResTag]) then
                    lResult &= lResource[ResHandle]
                end if
            else
                lResult &= lResource[ResHandle]
            end if
        end if
    end for

    return lResult
end function

--/topic Resources
--/func getTrackedObject( object Resource )
--/desc Gets the data saved against this /i Resource
--/ret A sequence containing the tracking data
-- /i Resource is the resource, eg. Bitmap, Pen, Brush, that was tracked. /n
-- If this is an empty sequence, it means that the resource was not being tracked.
global function getTrackedObject( object pResource)
    sequence lResult

    lResult = {}
    for i = 1 to length(heldResource) do
        if heldResource[i][ResStatus] = 1 and equal(heldResource[i][ResHandle],pResource)  then
            return heldResource[i]
        end if
    end for
    return {}
end function

-----------------------------------------------------------------------------
--/topic Resources
--/proc trackObject( object owner, object resource, integer lifetime )
--/desc Tracks an object as a held resource.
-- /i owner is the /b ID of the control that owns the resource being tracked. It
-- can be a simple control id or  a 2-element sequence {id, object-type}. There
-- are some predefined object types: /n
--<ul>
--/li IMAGE_BITMAP
--/li IMAGE_ICON
--</ul>
-- /i resource is the resource being tracked. This is usually a memory address of a structure you have created.
-- /i lifetime is how long this resource needs to be kept for. The possible code values are /n
-- /li /ForPaint if this a resource held during a Paint operation. /n
-- /li /ForProgram if this is to be held for the duration of the application. Win32lib
-- won't delete this resource. If you need to, you have to explicitly delete it.
--
-- Note that /i resource can be a two-element sequence. The first element is the
-- actual resource being tracked, and the second is anything you wish to tag
-- along with the resource. You can then use /findTrackedObject() to retrieve
-- the resource being tracked.
--
--Example:
--/code
--      trackObject (myEdit, hBGBrush, ForProgram)
--/endcode

global procedure trackObject( object owner, object pObject, integer lifetime )
    atom lObject
    integer at

    -- tracks object as held resource
    sequence res
    object lTag
    integer lObjType
    -- Get the 'extra' parameters...
    if atom(pObject) then
        lObject = pObject
        lTag = -1
    else
        lObject = pObject[1]
        lTag = pObject[2]
    end if
    if isStockResource( lObject ) then
        -- Don't bother tracking stock resources.
        return
    end if

    if atom(owner) then
        lObjType = kUnknownObject
    else
        lObjType = owner[2]
        owner = owner[1]
    end if


    -- don't add to list if it's already there.
    at = w32findKey( lObject, heldResource )
    if at = 0   then
        -- add the resource to the resource list

        if vHRI < 1 then
            heldResource &= repeat(NewRes, 16)
            vHRFree &= repeat(0, 16)
            for i = 1 to 16 do
                vHRFree[i] = length(heldResource) - i + 1
            end for
            vHRI = 16
        end if
        at = vHRFree[vHRI]
        vHRI -= 1
        -- create a resource and assign its attributes
        heldResource[at][ResHandle] = lObject
        heldResource[at][ResOwner]  = owner
        heldResource[at][ResLife]   = lifetime
        heldResource[at][ResTag]    = lTag
        heldResource[at][ResObjType] = lObjType
        heldResource[at][ResCnt] = 1
        heldResource[at][ResStatus] = 1 -- Valid entry

    else
        if heldResource[at][ResOwner] = owner then
            heldResource[at][ResCnt] += 1

        elsif heldResource[at][ResOwner] = -1 then
            -- This resource now has an owner
            heldResource[at][ResOwner] = owner

        else
            -- ?? Should this ever happen?
            warnErr(Err_WRONGOWNER)
        end if
    end if

end procedure

-----------------------------------------------------------------------------
global procedure replaceObject( object pId, integer pObjType, atom pDC, atom pNewObject,
	    	        integer pLifetime )

    -- adds resource tracking to selectObject
    atom lReplacedObject
    integer lDCI
    integer lObjType
    sequence lDC


    -- Track the DC's current objects
    lDCI = w32findKey(pDC, vDCs)
    if lDCI = 0 then
        vDCs = append(vDCs, kNewDC)
        lDCI = length(vDCs)
        vDCs[lDCI][1] = pDC
    end if

    -- select current, replace prior
    lReplacedObject = w32Func( xSelectObject, {pDC, pNewObject} )

    lObjType = pObjType + 1

    -- Take a local copy of the DC's tracking data for performance reasons.
    lDC = vDCs[lDCI][lObjType]

    if length(lDC) = 0 then
        -- First time this type of object has been replaced in this DC.
        lDC = {lReplacedObject, pNewObject}
        -- track the object
        trackObject( {pId, pObjType}, pNewObject, pLifetime )

    elsif lReplacedObject = lDC[2] then
        -- Candidate for deletion (except fonts, bitmaps and icons)
        -- 'cos I've just replaced the one I previously installed.
        if find(pObjType, {kBitmapObject, kIconObject, kFontObject}) = 0 then
            deleteObject(lReplacedObject)
        else
            deleteObject({lReplacedObject, w32False})
        end if

        if pNewObject =  lDC[1] then
            -- Just replaced the original, so remove tracking data.
            deleteObject({pNewObject, w32False})
            lDC = {}
        else
            -- Record the one I just installed.
            lDC[2] = pNewObject
            -- track the object
            trackObject( {pId,pObjType}, pNewObject, pLifetime )
        end if

    elsif lReplacedObject = lDC[1] then
        -- I've just replaced the original object
        -- So I must delete the one I just replaced.
        if pObjType != kFontObject then
            deleteObject(lDC[2])
        end if
        lDC = {}

    else
        -- Not one of mine.
        if lReplacedObject != 0 then
            if find(lReplacedObject, vFontHandles) = 0 then
                deleteObject(lReplacedObject)
            end if
        end if

        -- Remember to delete installed resource, unless its a font.
        if (pObjType != kFontObject) and length(getTrackedObject(lDC[2])) > 0 then
            deleteObject(lDC[2])
        end if

        -- If I've just replaced the original, then
        -- clear out the entries.
        if pNewObject = lDC[1] then
            if find(pNewObject, vFontHandles) = 0 then
                deleteObject(pNewObject)
            end if
            lDC = {}
        else
            -- Record the one I just installed.
            lDC[2] = pNewObject
        end if

    end if

    -- Update the shared DC tracking variable.
    vDCs[lDCI][lObjType] = lDC
end procedure

-----------------------------------------------------------------------------
global procedure trackCursor( object hCursor )

    -- tracks cursors as resources
    -- don't add to list if already there
    if not find( hCursor, heldCursor ) then
        -- add to list
        heldCursor = append(heldCursor, hCursor)
    end if

end procedure

-----------------------------------------------------------------------------
--/topic Mouse
--/func loadCursor(sequence CursorFile)
--/desc Loads a cursor from a file.
--/ret ATOM: The handle to a loaded cursor
--
-- If this returns zero, then the cursor was not loaded.
--
--/Example:
--/code
--      mC = loadCursor("hands.ani")
--      setMousePointer(myList, mC)
--/endcode
global function loadCursor( sequence pCursorFile)
    atom hCursor

    hCursor = w32Func(xLoadCursorFromFile, {pCursorFile})
    trackCursor(hCursor)

    return hCursor
end function

-----------------------------------------------------------------------------
global procedure releaseResourcesForID( object pIdLife )
    atom id
    integer lSpecificLifetime

    -- Free resources associated with a particular resource
    sequence lHeld
    sequence lResList

    if atom(pIdLife) then
        id       = pIdLife
        lSpecificLifetime = 0    -- Force release to happen.
    else
        id       = pIdLife[1]
        lSpecificLifetime = pIdLife[2]
        if lSpecificLifetime = ForProgram then
            return -- Not allowed to get rid of these ones.
        end if
    end if

    -- copy, because list shrinks
    lHeld = heldResource

    -- for each resource
    for i = 1 to length( lHeld ) do
        lResList = lHeld[i]
        if lResList[ResStatus] = 1  -- still valid
            and
           lResList[ResOwner] = id  -- got the correct id
            and
           (lSpecificLifetime = 0 or lResList[ResLife] = lSpecificLifetime)
        then
            -- release the object
            deleteObject( lResList[ResHandle] )

        end if
   end for


end procedure

-----------------------------------------------------------------------------

global procedure releaseAllResources(integer pMode)
    -- Free up all resources
    VOID = detachCleanUp(r_libCleanUp)

    for i = 1 to length(ctrl_Handle) do
        if ctrl_Type[i] = Window then
            if ctrl_Parent[i] = 0 then
                call_proc(r_destroy,{i})
            end if
        elsif ctrl_Type[i] = Pixmap then
            call_proc(r_destroy,{i})
        end if
    end for

    -- for each resource
    for i = 1 to length( heldResource ) do
        -- release the object and remove it from the list
        if heldResource[i][ResStatus] = 1 then
            deleteObject( heldResource[i][ResHandle] )
        end if
    end for

    -- release the cursors
    for i = 1 to length( heldCursor ) do
        if atom(heldCursor[i]) then
            VOID = w32Func( xDestroyCursor, { heldCursor[i] } )
        end if
    end for

    heldCursor = {}

    -- Release the crypto handle.
    if vCSP != 0 then
        VOID = w32Func(xCryptReleaseContext,{vCSP, 0})
        vCSP = 0
    end if

    -- give back all memory blocks acquired.
    w32release_mem(vPermMemSet)

    w32release_all_mem()

    vWinMainState = kFinished

    if pMode = 0 then
        abortErr("") -- Force any user cleanups to run.
    end if
end procedure

-----------------------------------------------------------------------------
--/topic Graphics
--/func colorValue(object Color)
--/desc Converts the parameter into the equivalent 24-bit color value.
--/ret ATOM: 24-bit color value.
--The /i Color parameter can take one of the following forms ... /n
--/li A atom expression that results in an integer from 0 to #FFFFFF
--/li One of the predefined Win32Lib color names, eg. Cyan, BrightMagenta, ...
--/li One of the system symbolic color names, eg. COLOR_BUTTONFACE
--/li One of the predefined Win32Lib color names as a negative string, eg. -"cyan", -"red", ...
--/li One of the predefined Win32Lib color names as a string, except for "red" eg. "cyan", "blue", ...
--/li A 3-element sequence in the form { red, green, blue } where each element is
-- an integer in the range 0 to 255.
--
--Example:
--/code
--      atom theColor
--      theColor = colorValue( -"Parchment" )
--      theColor = colorValue( {45,82,191} )
--      theColor = colorValue( Magenta )
--      theColor = colorValue( COLOR_ACTIVEBORDER )
--      theColor = colorValue( #C0C0C0 )
--/endcode
global function colorValue(object pColor)
    atom lColor
    integer lPos

    lColor = 0  -- Default is Black
    if sequence(pColor) then
        if length(pColor) = 3 and pColor[1] >= 0 then
            -- Note that this can be ambiguous if the string for "red" is used,
            -- as that is a 3-element sequence.
            return rgb(pColor[1], pColor[2], pColor[3])
        end if

        lPos = find(upper(pColor), vColorNames)
        if lPos = 0 then
            lPos = find(-upper(pColor), vColorNames)
        end if
        if lPos != 0 then
            lColor = vColorValues[lPos]
        end if
    else
        lColor = UseColor(pColor)
    end if

    return lColor
end function
r_colorValue  = routine_id("colorValue")


--/topic Utilities
--/func getStyleFlags( id )
--/desc Retrieves the standard and extra style flags for a control.
--/ret SEQUENCE: {ATOM: standard, ATOM: extra}
--Example
--/code
--      sequence lFlags
--      lFlags = getStyleFlags(myButton)
--/endcode
global function getStyleFlags( integer id)
    atom hWnd

    hWnd = getHWND(id)
    return { w32Func( xGetWindowLong, { hWnd, GWL_STYLE   }),
             w32Func( xGetWindowLong, { hWnd, GWL_EXSTYLE })
           }
end function

-----------------------------------------------------------------------------
--/topic Utilities
--/proc removeStyle( id, style )
--/desc Remove a style from a control.
--If /i style is an atom then only the normal Windows style is modified,
-- but if style is a sequence, it must be a tw-atom sequence. The first is
-- the normal styles, and the second is the extended styles.
--
--Example
--/code
--        removeStyle(w1, {
--                 -- normal styles
--                 (WS_MINIMIZEBOX+WS_MAXIMIZEBOX+WS_THICKFRAME),
--                 -- extended styles
--                 (WS_EX_CLIENTEDGE)
--                   })
--/endcode
global procedure removeStyle( integer id, object styles )
    atom curStyle, styleMask, hWnd, style

    if equal(styles, w32AUTOCLOSE) then
        style = find(r_autoclose, ctrl_Handlers[id][w32HClick])
        if style != 0 then
            ctrl_Handlers[id][w32HClick] = w32removeIndex(style,
                ctrl_Handlers[id][w32HClick])
        end if
        return
    end if

    hWnd = getHandle( id )
    if sequence(styles) then
        style = styles[1]
    else
        style = styles
    end if

    if style != 0 then
        curStyle = w32Func( xGetWindowLong, { hWnd, GWL_STYLE })
        styleMask = xor_bits( #FFFFFFFF, style )
        style = and_bits( styleMask ,curStyle )
        if style != curStyle then
            VOID = w32Func( xSetWindowLong,{ hWnd, GWL_STYLE, style })
        end if
    end if

    if sequence(styles) and styles[2] != 0 then
        style = styles[2]
        curStyle = w32Func( xGetWindowLong, { hWnd, GWL_EXSTYLE })
        styleMask = xor_bits( #FFFFFFFF, style )
        style = and_bits( styleMask ,curStyle )
        if style != curStyle then
            VOID = w32Func( xSetWindowLong,{ hWnd, GWL_EXSTYLE, style })
        end if
    end if

    VOID = w32Func(xSetForegroundWindow, {hWnd})
    VOID = w32Func(xSetWindowPos, {hWnd, 0, 0, 0, 0, 0, SWP_UPDATECACHE})

end procedure

--/topic Utilities
--/proc addStyle( id, style )
--/desc Add a style to a control.
--If /i style is an atom then only the normal Windows style is modified,
-- but if style is a sequence, it must be a two-atom sequence. The first is
-- the normal styles, and the second is the extended styles.
--
--A special use of this is to set a control to close its parent window. To
-- do this call the routine using the style /i w32AUTOCLOSE.
--
--Example
--/code
--        addStyle(w1, {
--                 -- normal styles
--                 (WS_MINIMIZEBOX+WS_MAXIMIZEBOX+WS_THICKFRAME),
--                 -- extended styles
--                 (WS_EX_CLIENTEDGE)
--                })
--      -- Set the control to close the window
--      addStyle( BtnClose, w32AUTOCLOSE)
--/endcode

global procedure addStyle( integer id, object styles )
    atom curStyle, hWnd, style
    object lTemp

    if equal(styles, w32AUTOCLOSE) then
        lTemp = vOnXXXSupport
        setHandler(id, w32HClick, r_autoclose)
        vOnXXXSupport = lTemp
        return
    end if

    hWnd = getHandle( id )

    if sequence(styles) then
        style = styles[1]
    else
        style = styles
    end if

    if style != 0 then
        curStyle = w32Func( xGetWindowLong, { hWnd, GWL_STYLE })
        style = or_bits( style ,curStyle )
        if style != curStyle then
            VOID = w32Func( xSetWindowLong,{ hWnd, GWL_STYLE, style })
        end if
    end if

    if sequence(styles) and styles[2] != 0 then
        style = styles[2]
        curStyle = w32Func( xGetWindowLong, { hWnd, GWL_EXSTYLE })
        style = or_bits( style ,curStyle )
        if style != curStyle then
            if and_bits(style, WS_EX_TOPMOST) then
                call_proc(r_moveZOrder,{id, HWND_TOPMOST})
            end if
            VOID = w32Func( xSetWindowLong,{ hWnd, GWL_EXSTYLE, style })
        end if
    end if

    VOID = w32Func(xSetForegroundWindow, {hWnd})
    VOID = w32Func(xSetWindowPos, {hWnd, 0, 0, 0, 0, 0, SWP_UPDATECACHE})
end procedure
r_addStyle = routine_id("addStyle")

--/topic System Attributes
--/func ClientToScreen(integer id, integer x, integer y)
--/desc Converts a point in a control to screen-based coordinates.
--/ret SEQUENCE: {screenX, screenY}
--
--Example
--/code
--      sequence sPosn
--      -- Find the screen position of the window's top left corner.
--      sPosn = ClientToScreen(myWindow, 0, 0)
--      printf(o, "Window is at %d, %d", {sPosn[1], sPosn[2]})
--/endcode

-- Create a buffer of 16 point structs to allow for 16 levels of nested interrrupts (not likely to happen)
atom cts_preallocated
cts_preallocated = w32acquire_mem(vPermMemSet, SIZEOF_POINT * 16)
global function ClientToScreen(integer id, integer x, integer y)
    atom    pt
    sequence lPoints
    -- Allocate a point structure
    pt = cts_preallocated
    cts_preallocated += SIZEOF_POINT

    poke4(pt, {x,y})
    -- convert to screen space
    VOID = w32Func( xClientToScreen, { getHandle( id ), pt } )

    -- get position
    lPoints = peek4s({pt,2})
    cts_preallocated = pt

    return lPoints
end function

--/topic System Attributes
--/func ScreenToClient(integer id, integer x, integer y)
--/desc Converts a point on a screen to control-based coordinates.
--/ret SEQUENCE: {ControlX, ControlY}
--
--Example
--/code
--      sequence cPosn, mXY
--      -- Find where the mouse is relative to the window.
--      mYX = getPointerPos()
--      cPosn = ScreenToClient(myWindow, mXY[1], mXY[2])
--      printf(o, "Mouse is at %d, %d", {cPosn[1], cPosn[2]})
--/endcode

global function ScreenToClient(integer id, integer x, integer y)
    integer viewX, viewY
    atom    pt
    -- Allocate a point structure
    pt  = w32acquire_mem( 0, SIZEOF_POINT )

    -- set to client (0, 0)
    w32store( pt, ptX, x )
    w32store( pt, ptY, y )

    -- convert to screen space
    if not w32Func( xScreenToClient, { getHandle( id ), pt } ) then
    abortErr( Err_SCREENTOCLIENT )
    end if

    -- get position
    viewX = w32fetch( pt, ptX )
    viewY = w32fetch( pt, ptY )

    w32release_mem(pt)

    return {viewX, viewY}
end function


--/topic System Attributes
--/func clientToClient(integer id1, integer id2, sequence xy)
--/desc Converts a point in /i id1 to a relative point in /i id2
--/ret SEQUENCE: {X, Y}
--/i xy is a sequence in the format { X, Y} which specifies a point in
-- the control /i id1. This value is transformed so that it is relative to
-- the control /i id2.
--
--Example
--/code
--      sequence mXY
--      -- Find where the point 2,-4 relative to the editbox is
--      -- relative to the label.
--      mXY = clientToClient(MyEditBox, MyLabelText, {2, -4 })
--
--/endcode

global function clientToClient(integer id1, integer id2, sequence xy)
    atom    pt
    sequence lPoints
    integer lParent

    -- Allocate a point structure
    pt = cts_preallocated
    cts_preallocated += SIZEOF_POINT

    poke4(pt, xy[1..2])
    -- convert to screen space relative to id1
    VOID = w32Func( xClientToScreen, { getHandle( id1 ), pt } )
    -- convert from screen space relative to id2
    VOID = w32Func( xScreenToClient, { getHandle( id2 ), pt } )

    -- get position
    lPoints = peek4s({pt,2})
    cts_preallocated = pt

    return lPoints
end function


--/topic Constants
--/const w32Edge
--/desc Specifies the extreme edge required when creating or moving a control.
--example
--/code
--          -- Create a edit area
--          myEdit = /create(MleText, "", myWin,
--                     0.50,           -- left edge is 50% of window's width
--                     20,             -- top edge is 20 pixels down
--                     w32Edge,        -- right edge is window's right edge
--                     {w32Edge, -25},  -- bottom edge is window's bottom
--                                     --   edge less 25 pixels.
--                     0)
--/endcode

--/topic Constants
--/const w32AltEdge
--/desc Specifies the alternate edge required when creating or moving a control.
-- This only makes sense when used in specifing the X,Y positions. The constant
-- is a reference to the 'far' edge. This is the Righthand side for the X
-- co-ordinate, and the Bottom edge for the Y co-ordinate. It is usually used
-- in conjection with negative offsets.
--example
--/code
--          -- Create a edit area aligned with the righhand edge.
--          fldWidth = 100
--          myEdit = /create(MleText, "", myWin,
--                     -- left edge is 'fldWidth' pixels from the RHS side of the window.
--                     {w32AltEdge, -fldWidth}
--                     20,             -- top edge is 20 pixels down
--                     fldWidth,       -- width of the field
--                     200,            -- height of 200 pixels
--                     0)
--/endcode

global constant w32Edge = {-1},
	    w32AltEdge = {-2},
        w32SameSize = {-3}

--------------------------------------
function convDimension(object pRaw, atom pLowEdge, atom pExtremeEdge,
	           atom pParentSize, atom pControlEdge)
--------------------------------------
    atom lNewDimension
    atom lPctSize
    atom lOffset
    sequence lMinMax
    atom lEdge
    object lRaw_1
    object lRaw_2

    if equal(pRaw, CW_USEDEFAULT) then
        return pRaw
    end if

    -- Initialise
    lMinMax = {}
    lPctSize = 0
    lOffset = 0
    lEdge = 0

    -- Check for a sequence first.
    if sequence(pRaw) then
        -- Check for simple edge request
        if equal(pRaw, w32Edge) then
            lPctSize = 0
            lOffset = pExtremeEdge
            lEdge = 1
        -- Check for complex request
        elsif length(pRaw) >= 2 then
            -- Copy to locals for performance reasons.
            lRaw_1 = pRaw[1]
            lRaw_2 = pRaw[2]

            -- Either the first or second could be the edge request.
            if equal(lRaw_1, w32Edge) then
    	    lOffset = pExtremeEdge
    	    lPctSize = lRaw_2
    	    lEdge = 1
            elsif equal(lRaw_2, w32Edge) then
    	    lOffset = pExtremeEdge
    	    lPctSize = lRaw_1
    	    lEdge = 1
            elsif equal(lRaw_1, w32AltEdge) then
    	    lOffset = pParentSize
    	    lPctSize = lRaw_2
            elsif equal(lRaw_2, w32AltEdge) then
    	    lOffset = pParentSize
    	    lPctSize = lRaw_1
            -- Either the first or second could be a % request
            elsif integer(lRaw_2) then
    	    lPctSize = lRaw_1
    	    lOffset = lRaw_2
    	    elsif atom(lRaw_2) and (lRaw_2 >= 1 or lRaw_2 < 0) then
    	    lPctSize = lRaw_1
    	    lOffset = floor(lRaw_2)
            else
    	    lPctSize = lRaw_2
    	    lOffset = lRaw_1
            end if
            -- Check to see if a limit has been requested.
            if length(pRaw) = 3
              and sequence(pRaw[3])
              and length(pRaw[3]) = 2
            then
    	    lMinMax = pRaw[3]
            end if
        end if
    else
        -- A simple % or pixel specified.
        lPctSize = pRaw
        lOffset = 0
    end if

    -- Calc the percentage of the parent size.
    if lPctSize > 0 and lPctSize < 1 then
        lPctSize *= pParentSize
    end if

    -- Add LowEdge to cater for client borders etc...
    lNewDimension = floor(lPctSize) + lOffset + pLowEdge

    -- Make adjustment if 'extreme' edge was asked for.
    if lEdge = 1 then
        lNewDimension += pControlEdge
    end if

    -- Check that the result is within the limits.
    if length(lMinMax) = 2 then
        if lNewDimension < lMinMax[1] then
            lNewDimension = lMinMax[1]
        end if
        if lNewDimension > lMinMax[2] then
            lNewDimension = lMinMax[2]
        end if
    end if


    return floor(lNewDimension)
end function

--------------------------------------
--/topic System Attributes
--/func convPctToPixel(integer id, object x, object y, object width, object height)
--/desc Converts relative coordinates to pixel coordinates.
--/ret SEQUENCE: 4-element list {Left, Top, Width, Height}
--This is used internally by /create() and a number of other routines
--to convert things like %values to pixels.
--
-- Each dimension can be expressed as either... /n
-- a) an integer >= 0, in which case it is not touched. /n
--     eg.  50 (= 50 pixels) /n
-- b) an atom in the range > 0 and ~< 1, which is taken to be a % /n
--    of the control's parent dimension. /n
--     eg.  0.50 (= 50% of parent's size) /n
-- c) The constant /i w32Edge which signifies the parent's extreme  /n
--    client edge for the dimension. That is, either the rightmost or /n
--    bottom most edge, as appropriate. /n
-- d) a sequence of two elements, the first as in (b) or (c) above, and /n
--    the other a pixel offset. The offset is added after converting. /n
--     eg.  {0.50, -3} ( = 50% of parent size less 3 pixels) /n
--     eq   (w32Edge, -10} ( = right/bottom pixel less 10 pixels) /n
-- e) a sequence of three elements, the first two as in (d), and /n
--    the other a two-element sequence containing the minimum and /n
--    maximum allowable values. These can be a percentage or a /n
--    pixel amount.  /n
--     eg.  {0.50, -3, {0.2, 300}} ( = 50% of parent size less /n
--            3 pixels, and a minimum of 20 pixels and a /n
--            maximum of 300 pixels) /n
--Example:
--/code
--       sequence BBox
--       BBox = convPctToPixels( myEditBox, 0.30, {w32Edge,-40}, {0.1,4}, 35)
--
--/endcode
global function convPctToPixel(integer id,
	        object x, object y, object width, object height)
    -- Converts a controls coordinates from percentages to pixels.
    sequence BBox
    sequence PBox
    integer lParent


    -- Not a valid ID, or this type of control cannot
    -- be converted, just return what was supplied.
    if   validId(id) = w32False
      or and_bits(classAttr[ctrl_Type[id]], w32NoConv) != 0
    then
        return {x, y, width, height}
    end if

    --Get the control's parent.
    lParent = ctrl_Parent[id]
    if lParent = 0 then
        lParent = Screen
    end if

    -- Get the parent's current dimensions.
    PBox = call_func(r_getClientRect, {lParent})

    -- Convert Right/Bottom pixel to width and height
    PBox[3] = PBox[3] - PBox[1] - 1
    PBox[4] = PBox[4] - PBox[2] - 1

    if integer(x) and integer(y) and integer(width) and integer(height) then
        return {x+PBox[1], y+PBox[2], width, height}
    end if

    BBox = {0, 0, 0, 0}

    if equal(x, Center) then
        if equal(y, Default) then
            y = 0
        end if
        BBox[1] = floor(PBox[3]/2)
    else
        BBox[1] = convDimension(     x, PBox[1], PBox[1], PBox[3], 0)
    end if

    if equal(y, Center) then
        if equal(x, Default) then
            BBox[1] = 0
        end if
        BBox[2] = floor(PBox[4]/2)
    else
        BBox[2] = convDimension(     y, PBox[2], PBox[2], PBox[4], 0)
    end if

    BBox[3] = convDimension( width,       0, PBox[3], PBox[3], PBox[1] - BBox[1])

    BBox[4] = convDimension(height,       0, PBox[4], PBox[4], PBox[2] - BBox[2])

    if equal(x, Center) then
        BBox[1] = BBox[1] - floor(BBox[3]/2)
    end if

    if equal(y, Center) then
        BBox[2] = BBox[2] - floor(BBox[4]/2)
    end if

    return BBox
end function

-----------------------------------------------------------------------------
-----------------------------------------------------------------------------
-- Printer Support

atom printerDC
printerDC = 0
global constant
    w32InchScale = 'i',
    w32MillScale = 'm',
    w32PixelScale = 'p',
    w32TwipsScale = 't'

-----------------------------------------------------------------------------
--/topic Printing
--/proc releasePrinter()
--/desc Release the /Printer, freeing it up for others to use.
-- The /Printer must first be grabbed with /getPrinter.
--
-- Refer to /Printer for details.

global procedure releasePrinter()

    -- is there a dc to delete?
    if printerDC then

        -- release resources
        releaseResourcesForID( {Printer, ForPaint} )

        -- attempt to delete it
        if not w32Func( xDeleteDC, {printerDC} ) then
            warnErr( Err_RELEASEPRINTER )
        end if

        -- clear the handle
        printerDC = 0

    end if

end procedure


----------------------------------------------
--/topic Printing
--/func getPrintChoice(integer pMaxPages, object pFlags, atom pPrintDlg)
--/desc Get the choices from a user before printing.
--/ret SEQUENCE: { startpage, endpage, copies, printerDC, collate, p2f, orient, paper }, or {} if user aborted.
-- This pops up the "Select Printer" dialog for the
-- user to select a printer from.
--
-- /i pMaxPages specifies the maximum number of pages that a user can print,
-- /i pFlags is additional flags for the dialog box. See the Microsoft
-- documentation for details. It is either a sequence of flag values, in
-- which case it replaces the default ones, or it is an atom of OR'd flags
-- which are OR'd with the defaults (PD_ALLPAGES).
--
-- /i pPrintDlg is used for experts only. If zero, it is ignored. Otherwise
-- it is the address of a PRINTDLG structure which has been correctly setup
-- by the caller.
--
-- The returned sequence has the starting and ending pages that the user selected. If
-- these are both 0, then the user only wants the current document selection printed.
-- If these are both -1, then the user wants all pages printed.
--
-- /i copies is the number of copies to be printed. /n
-- /i printerDC is the Printer's Device Context. This is not normally used directly
-- but is available for advanced users. /n
-- /i collate is w32True if the user wants the output collated. /n
-- /i p2f is w32True if the user wants output to go to a file rather than the printer. /n
-- /i orient is either DMORIENT_PORTRAIT or DMORIENT_LANDSCAPE. /n
-- /i paper is the numeric code for the type of paper requested. /n
--
-- See also /Printer
global function getPrintChoice(integer pMaxPages, object pFlags, atom pPrintDlg)
    atom result
    integer fromPage, toPage, copies, collate, p2f, orient, paper
    atom mem, flags
    atom lDevMode

    -- get memory for the dialog
    if pPrintDlg = 0 then
        mem = w32acquire_mem( 0, SIZEOF_PRINTDLG )
        -- set up
        w32store( mem, PRINTDLG_lStructSize, SIZEOF_PRINTDLG )
        w32store( mem, PRINTDLG_nMinPage, 1 )
    else
        mem = pPrintDlg
    end if

    -- default flags
    if atom(pFlags) then
        pFlags &= PD_ALLPAGES -- initially set the 'All Pages' radio button
    end if
    flags = w32or_all(pFlags & PD_RETURNDC)

    -- set up
    w32store( mem, PRINTDLG_flags, flags )
    w32store( mem, PRINTDLG_nMaxPage, pMaxPages )
    w32store( mem, PRINTDLG_nCopies, 1)
    w32store( mem, PRINTDLG_nToPage, pMaxPages)
    w32store( mem, PRINTDLG_nFromPage, 1)
    -- need to release?
    releasePrinter()

    -- call the routine
    result = w32Func(xPrintDlg, {mem})
    if result then
        -- store the new dc
        printerDC = w32fetch( mem, PRINTDLG_hdc )

        -- fetch values
        copies   = w32fetch( mem, PRINTDLG_nCopies  )
        flags    = w32fetch( mem, PRINTDLG_flags )
        if and_bits(flags, PD_PAGENUMS) then
            fromPage = w32fetch( mem, PRINTDLG_nFromPage )
            toPage   = w32fetch( mem, PRINTDLG_nToPage )

        elsif and_bits(flags, PD_ALLPAGES) then
            fromPage = -1
            toPage   = -1

        else -- PD_SELECTION active
            fromPage = 0
            toPage   = 0
        end if

        collate= (and_bits(flags,PD_COLLATE) != 0)
        p2f = (and_bits(flags,PD_PRINTTOFILE) != 0)
        lDevMode = w32fetch(mem,PRINTDLG_pDevMode)
        orient = w32fetch( lDevMode, DEVMODE_dmOrientation )
        paper = w32fetch( lDevMode, DEVMODE_dmPaperSize)


    else
        VOID = w32Func(xGetLastError,{})
    end if

    -- release the memory
    if pPrintDlg = 0 then
        w32release_mem( mem )
    end if

    -- what to return?
    if printerDC then
        -- information the user selected
        return { fromPage, toPage, copies, printerDC, collate, p2f, orient, paper }
    else
        -- failed
        return {}
    end if

end function

-----------------------------------------------------------------------------
--/topic Printing
--/func getPrinter()
--/desc Get the /Printer.
--/ret SEQUENCE: { start page, end page, copies, printerDC, collate, p2f, orient, paper }, or {} if user aborted.
-- This pops up the "Select Printer" dialog for the
-- user to select a printer from. It defaults to a maximum of 999 pages.
--
-- See /getPrintChoice for details about this routine. /n
--
-- See also /Printer.

global function getPrinter()
    return getPrintChoice(999, 0, 0)
end function


--/topic Dialogs
--/func getPageSetupEx(atom Flags)
--/desc Page setup dialog
--/ret SEQUENCE : { paperSize, margins , orientation, papertype}  /b or  w32False if the user cancels
--/i Flags are the /b"or'd" flags... /n
--<ul>
--/li PSD_DEFAULTMINMARGINS
--/li PSD_DISABLEMARGINS
--/li PSD_DISABLEORIENTATION
--/li PSD_DISABLEPAGEPAINTING
--/li PSD_DISABLEPAPER
--/li PSD_DISABLEPRINTER
--/li PSD_ENABLEPAGEPAINTHOOK
--/li PSD_ENABLEPAGESETUPHOOK
--/li PSD_ENABLEPAGESETUPTEMPLATE
--/li PSD_ENABLEPAGESETUPTEMPLATEHANDLE
--/li PSD_INHUNDREDTHSOFMILLIMETERS
--/li PSD_INTHOUSANDTHSOFINCHES
--/li PSD_INWININIINTLMEASURE
--/li PSD_MARGINS
--/li PSD_MINMARGINS
--/li PSD_NOWARNING
--/li PSD_RETURNDEFAULT
--/li PSD_SHOWHELP
--
--The return values are ... /n
--</ul>
-- /li /i paperSize: { x, y }
-- /li /i margins: {left, top, right, bottom }
-- /li /i orientation: Either DMORIENT_PORTRAIT or DMORIENT_LANDSCAPE.
-- /li /i papertype: The numeric code for the type of paper.
--
-- This also sets the printer to the user's selection.
global function getPageSetupEx(atom pFlags, atom pSetupDlg)
    atom psd, ok, paperSize, margins, devname, devmode
    object result

    -- get memory for the dialog
    if pSetupDlg = 0 then
        psd = w32acquire_mem( 0, SIZEOF_PAGESETUPDLG )
    else
        psd = pSetupDlg
    end if

    w32store( psd, PAGESETUPDLG_lStructSize, SIZEOF_PAGESETUPDLG )
    w32store( psd, PAGESETUPDLG_Flags, pFlags )


    ok = w32Func( xPageSetupDlg, { psd } )

    if ok then
        -- Release the previous printer context
        releasePrinter()

        paperSize = psd + PAGESETUPDLG_ptPaperSize[1]
        margins = psd + PAGESETUPDLG_rtMargin[1]

        devmode=w32fetch(psd,PAGESETUPDLG_pDevMode)

        result = { {
	        w32fetch( paperSize, ptX ),
	        w32fetch( paperSize, ptY ) },
	       {
	        w32fetch( margins, rectLeft ),
	        w32fetch( margins, rectTop ),
	        w32fetch( margins, rectRight ),
	        w32fetch( margins, rectBottom ) },
            w32fetch( devmode, DEVMODE_dmOrientation ),
            w32fetch( devmode, DEVMODE_dmPaperSize )
           }

        devname = w32fetch( psd, PAGESETUPDLG_pDevNames )

        printerDC = w32Func( xCreateDC, {
                0,
                devname + w32fetch( devname, DEVNAMES_wDeviceOffset ) ,
                0,
                w32fetch( psd, PAGESETUPDLG_pDevMode)
               })

    else
        result = 0
    end if

    -- release the memory
    if pSetupDlg = 0 then
        w32release_mem( psd )
    end if
    return result
end function

--/topic Dialogs
--/func getPageSetup()
--/desc Page setup dialog
--/ret SEQUENCE: { paperSize, margins, orientation, papertype }  /b or  w32False if the user cancels
-- This calls /getPageSetupEx() using the default flags of ... /n
--<ul>
--/li PSD_DEFAULTMINMARGINS
--/li PSD_INTHOUSANDTHSOFINCHES
--</ul>
global function getPageSetup()
    return getPageSetupEx(or_bits( PSD_DEFAULTMINMARGINS,
	                               PSD_INTHOUSANDTHSOFINCHES),
                          0
	                     )
end function
---------------------------------------------------------------------------
--/topic Printing
--/func startDoc( sequence jobname )
--/desc Starts a new document on /Printer.
--/ret INTEGER: w32True if succeeds.
-- Start a new document on the /Printer. /n
-- The /i jobname parameter can either be the name of the job as seen by the system or
-- { jobname, filename }. If /i filename is "", then the default of "FILE:" is used. /n
--
-- If the filename is specified, the document is sent to the file rather than the printer device. /n
-- If the filename is "FILE:" then the user will be prompted for the name of the file to use.
--
-- Refer to /Printer for details.

global function startDoc( sequence job )
    -- start the document

    atom di, result

    result = 0
    if printerDC != 0 then
        -- Allocate the structure
        di = w32acquire_mem( 0, SIZEOF_DOCINFO )

        -- store the values
        w32store( di, DOCINFO_cbSize,       SIZEOF_DOCINFO )
        w32store( di, DOCINFO_lpszDocName,  job )
        w32store( di, DOCINFO_lpszOutput,   NULL )
        if length(job)=2 and sequence(job[2]) then  -- print to file requested
            w32store( di, DOCINFO_lpszDocName,  job[1] )
            if length(job[2]) != 0 then
                w32store( di, DOCINFO_lpszOutput,   job[2] )
            else
                w32store( di, DOCINFO_lpszOutput,   "FILE:" )
            end if
        else
            w32store( di, DOCINFO_lpszDocName,  job )
            w32store( di, DOCINFO_lpszOutput,   NULL )
        end if
        w32store( di, DOCINFO_lpszDatatype, NULL )
        w32store( di, DOCINFO_fwType,       NULL )

        result = w32Func( xStartDoc, { printerDC, di } )

        -- Free the structure
        w32release_mem(di)
    end if

    -- returns true if succeeds
    return (result > 0)

end function

-----------------------------------------------------------------------------
--/topic Printing
--/func endDoc()
--/desc Ends the print job.
--/ret w32True if succeeds.
-- Applications should call /endDoc when finished printing.
--
-- Refer to /Printer for details.

global function endDoc()
    if printerDC != 0 then
        -- end the document
        return w32Func( xEndDoc, {printerDC} ) >= 0
    else
        return 0
    end if

end function

--/topic Printing
--/proc abortDoc()
--/desc Abandons the print job, flushing anything created so far for it.
-- Applications should call /abortDoc to cancel a print job.

global procedure abortDoc()
    if printerDC != 0 then
        -- cancel the document.
        VOID = w32Func( xAbortDoc, {printerDC} )
    end if
end procedure


-----------------------------------------------------------------------------
--/topic Printing
--/func startPage()
--/desc Prepares the printer to begin a new page.
--/ret w32True if succeeds.
--
-- Refer to /Printer for details.

global function startPage()
    if printerDC != 0 then
        -- start the document
        return w32Func( xStartPage, {printerDC} ) >= 0
    else
        return 0
    end if
end function

-----------------------------------------------------------------------------
--/topic Printing
--/func endPage()
--/desc Ends the printing of the current page.
--/ret w32True if succeeds.
--
-- Refer to /Printer for details.

global function endPage()
    if printerDC != 0 then
        -- end the document
        return w32Func( xEndPage, {printerDC} ) >= 0
    else
        return 0
    end if
end function

-----------------------------------------------------------------------------


-----------------------------------------------------------------------------
--/topic Attributes
--/proc setReadOnly( integer id, integer YesNo )
--/desc Sets the read-only state of an edit control.
-- /i YesNo is w32True to set it to read-only, and w32False to allow keystrokes.
--
--Example:
--/code
--      setReadOnly( myEdit, w32True)
--/endcode
global procedure setReadOnly( integer id, integer YesNo )
    VOID = sendMessage(id, EM_SETREADONLY, YesNo,0)
end procedure


-----------------------------------------------------------------------------
-----------------------------------------------------------------------------
--/topic Low Level Routines
--/func getDC( id )
--/desc Get the DC (device context) of the control.
--/ret ATOM: Device Context (DC) of the control.
-- If the DC is already grabbed, the value is simply returned without
-- grabbing it again.
--
-- There are some special cases that are handled:
--
-- /li Normal controls: This includes any control that is normally
--          visible on the screen. This performs a normal /b GetDC.
-- /li /Screen: Passing the parameter of /Screen returns the
--          DC of the monitor.
-- /li /Printer: Passing the parameter of /Printer returns the
--          printer's DC, assuming that one has been selected with
--          /getPrinter.
-- /li /b Pixmaps: This causes a DC compatible with the screen resolution
--          to be created with the pixmap selected into it.
-- /li /b Other: If the value passed is not identifiable as a valid
--          Win32Lib control, it is assumed to be a DIB. A compatible DC
--          is created, and the DIB is selected into it.
--
-- When you are done with the DC, it should be released with /releaseDC
-- /b unless the DC was obtained during an /onPaint event, since the DC
-- will be released automatically.

global function getDC( object pID )
    -- get device context.

    integer lPos
    atom lhDC, lNewBmp, lSavedDC
    object lOption

    lOption = {}

    if sequence(pID) then
        lOption = pID[2]
        pID = pID[1]
    end if

    -- Check that I haven't already got a DC for this control.
    lPos = w32findKey(pID, grabbedHDC)
    if lPos != 0 then
        grabbedHDC[lPos][kTrackedCurDC][kTrackedDCCnt] += 1
        return grabbedHDC[lPos][kTrackedCurDC][kTrackedDCHdl]
    end if

    lhDC = NULL
    lSavedDC = NULL
    lNewBmp = NULL


    -- get the device context
    if pID = Screen then

        lhDC = w32Func( xGetDC, {0} )

    elsif pID = Printer then
        -- the printer dc
        lhDC = printerDC

    elsif not validId( pID ) then
        -- the pID isn't a valid handle, so assume it is a bitmap.

        -- create a memory device context compatible with the screen
        lhDC = w32Func( xCreateCompatibleDC, {NULL} )

        -- select the bitmap into it
        lNewBmp = pID

    elsif ctrl_Family[ pID ] = PIXMAP then
        -- pixmap class

        -- create a memory device context compatible with the screen
        lhDC = w32Func( xCreateCompatibleDC, {NULL} )

        -- select the bitmap into it
        lNewBmp = getHandle(pID)

    else
        lhDC = w32Func( xGetDC, {getHandle( pID )} )

    end if

    if lhDC = NULL then
        if equal(lOption, {}) then
            warnErr( Err_GETDCFAIL)
        else
            return 0
        end if
    end if


    if lNewBmp != NULL then

        replaceObject(pID, kBitmapObject, lhDC, lNewBmp, ForProgram )
    else
        -- save the current device context
        lSavedDC = w32Func( xSaveDC, {lhDC} )
    end if

    -- add to list

    grabbedHDC = prepend( grabbedHDC, {pID,{1,lhDC, lSavedDC, kDCReasonApp}} )

    return lhDC

end function
r_getDC = routine_id("getDC")

-----------------------------------------------------------------------------
--/topic Low Level Routines
--/proc releaseDC( control )
--/desc Release the device context of the control.
-- The DC should have been obtained with /getDC.
--
-- If the control is not a Pixmap or DIB, and the DC was obtained during an
-- /onPaint event, there is no need to release the DC. Win32Lib will
-- automatically release all DCs obtained during an /onPaint
-- there is no need to release the DC, since
-- Win32Lib will release all the DCs at the end of
-- supposed to have the DC, there is no need to release it.
--
-- If the control is the /Printer, there is no need to release the
-- DC using /releaseDC. Instead, use /releasePrinter

global procedure releaseDC( atom pID )

    atom lhDC, lSavedDC
    integer lPos, lObjIdx
    sequence lData

    lPos = w32findKey(pID, grabbedHDC)
    if lPos = 0 then
        -- Nothing to release.
        return
    end if

    -- Count down the references.
    grabbedHDC[lPos][kTrackedCurDC][kTrackedDCCnt] -= 1

    if grabbedHDC[lPos][kTrackedCurDC][kTrackedDCCnt] > 0 then
        -- Still some 'gets' outstanding, so don't release it yet.
        return
    end if

    -- get the lhDC from the list
    lData = grabbedHDC[lPos][kTrackedCurDC]

    -- remove from grabbed list
    grabbedHDC[lPos] = w32removeIndex(kTrackedCurDC, grabbedHDC[lPos])
    if length(grabbedHDC[lPos]) = 1 then
        -- No DCs remaining for this ID.
        grabbedHDC = w32removeIndex(lPos, grabbedHDC)
    end if

    lhDC = lData[kTrackedDCHdl]
    lPos = 0

    -- Restore any original resources.
    lPos = w32findKey(lhDC, vDCs)
    if lPos != 0 then
        for i = 1 to length(kObjectTypes)  do
            lObjIdx = kObjectTypes[i]+1
            if length(vDCs[lPos][lObjIdx]) > 0 then
                replaceObject(pID, kObjectTypes[i], lhDC, vDCs[lPos][lObjIdx][1], 0)
            end if
        end for
        vDCs = w32removeIndex(lPos, vDCs)
    end if

    -- restore the device context if required.
    if lData[kTrackedDCSaved] != NULL then
        if not w32Func( xRestoreDC, {lhDC, lData[kTrackedDCSaved]} ) then
            abortErr( Err_RELEASEDCRESTORE )
        end if
    end if

    -- Do a real release if not during a Paint event.
    if lData[kTrackedDCReason] = kDCReasonApp then
        if pID = Screen then

            -- release screen
            if w32Func( xReleaseDC, {0, lhDC} ) = 0 then
                warnErr( Err_RELEASESCREEN )
            end if

        elsif pID = Printer then
            -- does nothing; use releasePrinter instead.

        elsif not validId( pID ) then
            -- release the device context
            if not w32Func( xDeleteDC, {lhDC} ) then
                warnErr( Err_RELEASEBITMAP )
            end if

        elsif ctrl_Family[pID] = PIXMAP then
            -- release the device context
            if not w32Func( xDeleteDC, {lhDC} ) then
                warnErr( Err_RELEASEPIXMAP )
            end if

        else
            -- normal release
            if w32Func( xReleaseDC, {getHandle( pID ), lhDC} ) = 0 then
                warnErr( Err_RELEASEDC )
            end if

        end if

    end if

end procedure
r_releaseDC = routine_id("releaseDC")

--/topic Low Level Routines
--/func getIdFromDC(atom DC)
--/desc Finds the control Id associated with the supplied Device Context.
--/ret INTEGER: Control ID or 0 if the DC is not associated with a win32lib control.
--/i DC is the device context returned by /getDC
--
--This is primarily used by add-on libraries as a way to use Win32lib routines that need
-- a control ID rather than a device context.
--
--Example:
--/code
--      integer id
--      id = getIdFromDC ( theDC )
--/endcode

global function getIdFromDC( atom pHDC )
    integer lID
    integer lPos

    lPos = w32findKeyEx(pHDC, grabbedHDC, {kTrackedCurDC, kTrackedDCHdl})
    if lPos != 0 then
        lID = grabbedHDC[lPos][kTrackedID]
    else
        lID = 0
    end if
    return lID
end function
r_getIdFromDC = routine_id("getIdFromDC")

--/topic Attributes
--/func getWindowInfo(integer id, object pFields)
--/desc Get various information about a window.
--/ret SEQUENCE: A list of the requested field values.
--/i id is the id of a window that you want information from. /n
--/i pFields is a list of fields whose value can be requested. /n
--/define
--/term WINDOWINFO_WLeft
--      The Window border's left pixel position
--/term WINDOWINFO_WTop
--      The Window border's top pixel position
--/term WINDOWINFO_WRight
--      The Window border's right pixel position
--/term WINDOWINFO_WBottom
--      The Window border's bottom pixel position
--/term WINDOWINFO_CLeft
--      The Window client area's left pixel position
--/term WINDOWINFO_CTop
--      The Window client area's top pixel position
--/term WINDOWINFO_CRight
--      The Window client area's right pixel position
--/term WINDOWINFO_CBottom
--      The Window client area's bottom pixel position
--/term WINDOWINFO_Style
--      The Window style flags
--/term WINDOWINFO_ExStyle
--      The Window extended style flags
--/term WINDOWINFO_WindowStatus
--      The Window's activation status. Zero = not-active.
--/term WINDOWINFO_xWindowBorders
--      The width, in pixels, of the window border.
--/term WINDOWINFO_yWindowBorders
--      The height, in pixels, of the window border.
--/term WINDOWINFO_WindowType
--      The window class atom. Used in Win32 CreateWindow() calls.
--/term WINDOWINFO_CreatorVersion
--      The version of Windows 32 that created this window.
--/enddefine
--
--Example:
--/code
--       sequence lValues
--       lValues = getWindowInfo(myWin,
--                      {WINDOWINFO_WLeft,
--                       WINDOWINFO_WTop,
--                       WINDOWINFO_WindowStatus
--                      })
--       printf(o, "Window is at %d, %d and is %s",
--             {lValues[1], lValues[2],
--              w32iff(lValues[3], "active", "inactive")})
--/endcode

global function getWindowInfo(integer id, sequence pFields)
    sequence lResult
    atom     lWindowInfo
    lResult = {}

    lWindowInfo = w32acquire_mem(0, SIZEOF_WINDOWINFO)
    w32store(lWindowInfo, WINDOWINFO_cbSize, SIZEOF_WINDOWINFO)
    if w32Func(xGetWindowInfo,{ getHandle(id), lWindowInfo}) then
        for i = 1 to length(pFields) do
            lResult = append(lResult, w32fetch(lWindowInfo, pFields[i]))
        end for
    end if

    w32release_mem(lWindowInfo)

    return lResult
end function

--/topic Attributes
--/func getControlInfo(integer id, object pFields)
--/desc Get various internal information about a control.
--/ret SEQUENCE: A list of the requested field values.
--/i id is the id of a control that you want information from. /n
--/i pFields is a list of fields whose value can be requested. /n
--/define
--/term     CONTROLINFO_handle
--  Windows hWnd value of control
--/term     CONTROLINFO_handle_type
--  Type of handle /n
--    Window = 1  /n
--    Bitmap = 2  /n
--    Menu   = 3  /n
--    TabItem = 4  /n
--    ImageList = 5   /n
--/term     CONTROLINFO_destroyed
--  true if destroyed
--/term     CONTROLINFO_func
--  Long pointer to function
--/term     CONTROLINFO_class
--  control class
--/term     CONTROLINFO_classinfo
--  control class info used during create /n
-- The returns a sequence that contains... /n
--<ul>
--/li Name  : The name of the registered Window Class
--/li Type  : The family of controls. Possible values are:
-- WINDOW, BUTTON, COMBO, EDIT, LISTBOX, SCROLLBAR,
-- STATIC, MENU, POPUP, MENUITEM, PIXMAP, COMMON_CONTROL
--/li Style : The default Style Flags used by /createEx()
--/li StyleEx: The default Extended Style Flags used by /createEx()
--/li Attributes: The win32lib attributes of this control. Possible values are: /n
--  /b w32Clickable: Can allow mouseup detection to fire onClick handler /n
--  /b w32NoConv: Must not allow relative dimension conversions /n
--  /b w32PictCtrl: Controls that pass bitmaps in the flags /n
--  /b w32CtrlTab: CTRL-tabkey must be used to move tabstops /n
--/li Background Color : The default background color
--/li Foreground Color : The default foreground color
--/li Pointer : The default mouse pointer shape.
--</ul>
--/term     CONTROLINFO_type
--  win32lib type
--/term     CONTROLINFO_focus_order
--  focus order of controls
--/term     CONTROLINFO_focus
--  current focus
--/term     CONTROLINFO_owner
--  owner
--/term     CONTROLINFO_menu
--  menu in window
--/term     CONTROLINFO_popup
--  atached popup menu for the control
--/term     CONTROLINFO_notifyid
--  a list of ids that wish to be notified of events that happen to this control.
--/term     CONTROLINFO_toolbar
--  toolbar in window
--/term     CONTROLINFO_statusbar
--  statusbar in window
--/term     CONTROLINFO_tooltip
--  tooltip text or flattoolbar button's caption
--/term     CONTROLINFO_font
--  font resource
--/term     CONTROLINFO_fcolor
--  foreground color
--/term     CONTROLINFO_bcolor
--  background color
--/term     CONTROLINFO_pen
--  pen: { id, color, style }
--/term     CONTROLINFO_x
--  x position
--/term     CONTROLINFO_y
--  y position
--/term     CONTROLINFO_erase
--  True if application is responsible for erasing the window background.
--/term     CONTROLINFO_scroll
--  scroll: { small change, large change }
--/term     CONTROLINFO_range
--  scroll range { low, high }
--/term     CONTROLINFO_tabitems
--  tabs in tab control
--/term     CONTROLINFO_group
--  items owned by this window, regardless whether they are in the tab order or not.
--/term     CONTROLINFO_cursor
--  cursor associated with window
--/term     CONTROLINFO_hotkey_keys
--  hotkeys associated with the window
--/term     CONTROLINFO_hotkey_ids
--  ids associated with hotkeys
--/term     CONTROLINFO_textalign
--  alignment of text
--/term     CONTROLINFO_closed
--  true if window has been closed.
--/term     CONTROLINFO_tabenabled
--  true if control uses raw tab keys, false if CTRL-tabkey must be used.
--/term     CONTROLINFO_eventhandler
--  Routine IDs for event handlers.
--/term     CONTROLINFO_bbrush
--  The current Brush used to paint a control's background.
--/term     CONTROLINFO_cursor
--  The stack of cursor's used to set the current cursor shape
--/term     CONTROLINFO_tag
--  The current set of user defined properties for the control.
--/term     CONTROLINFO_name
--  The current user defined name for the control.
--/term     CONTROLINFO_deferredhandlers
--  The current set of unresolved event handlers for the control.
--/term     CONTROLINFO_autoheight
--  Is this an automatic height resizing control
--/term     CONTROLINFO_autowidth
--  Is this an automatic width resizing control
--/term     CONTROLINFO_init
--  Contains the initial Rect data for children controls if there is a toolbar in the window
--/term     CONTROLINFO_mousetrap
--  Contains a list of the defined mousetraps for a control.
--/enddefine
--
--Example:
--/code
--       sequence lValues
--       lValues = getControlInfo(myWin,
--                      {CONTROLINFO_handle,
--                       CONTROLINFO_owner,
--                       CONTROLINFO_type
--                      })
--/endcode

global function getControlInfo(integer id, object pFields)
    object lResult
    sequence lFields

    lResult = {}
    if atom(pFields) then
        lFields = {pFields}
    else
        lFields = pFields
    end if
    if id > 0 and id <= length(ctrl_Handle) then
    for i = 1 to length(lFields) do
        if lFields[i] = CONTROLINFO_handle then
    	    lResult = append(lResult, ctrl_Handle[id])
        elsif lFields[i] = CONTROLINFO_handle_type then
            lResult = append(lResult, ctrl_Handle_type[id])
        elsif lFields[i] = CONTROLINFO_destroyed then
	        lResult = append(lResult, ctrl_Destroyed[id])
        elsif lFields[i] = CONTROLINFO_func then
    	    lResult = append(lResult, ctrl_Function[id])
        elsif lFields[i] = CONTROLINFO_class then
            lResult = append(lResult, ctrl_Family[id])
        elsif lFields[i] = CONTROLINFO_type then
	        lResult = append(lResult, ctrl_Type[id])
        elsif lFields[i] = CONTROLINFO_focus_order then
    	    lResult = append(lResult, ctrl_Focus_order[id])
        elsif lFields[i] = CONTROLINFO_focus then
            lResult = append(lResult, ctrl_Current_focus[id])
        elsif lFields[i] = CONTROLINFO_lost_focus then
            lResult = append(lResult, ctrl_Previous_focus[id])
        elsif lFields[i] = CONTROLINFO_owner then
	        lResult = append(lResult, ctrl_Parent[id])
        elsif lFields[i] = CONTROLINFO_menu then
    	    lResult = append(lResult, ctrl_Menu[id])
        elsif lFields[i] = CONTROLINFO_popup then
    	    lResult = append(lResult, ctrl_Popup[id])
        elsif lFields[i] = CONTROLINFO_notifyid then
            lResult = append(lResult, ctrl_Notify_List[id])
        elsif lFields[i] = CONTROLINFO_toolbar then
            lResult = append(lResult, ctrl_Toolbar[id])
        elsif lFields[i] = CONTROLINFO_range then
	        lResult = append(lResult, ctrl_Range[id])
        elsif lFields[i] = CONTROLINFO_tooltip then
    	    lResult = append(lResult, ctrl_Hint_Text[id])
        elsif lFields[i] = CONTROLINFO_tooltipwid then
    	    lResult = append(lResult, ctrl_Hint_Width[id])
        elsif lFields[i] = CONTROLINFO_font then
            lResult = append(lResult, ctrl_Font[id])
        elsif lFields[i] = CONTROLINFO_fcolor then
	        lResult = append(lResult, ctrl_Fg_Color[id])
        elsif lFields[i] = CONTROLINFO_bcolor then
    	    lResult = append(lResult, ctrl_Bg_Color[id])
        elsif lFields[i] = CONTROLINFO_pen then
            lResult = append(lResult, ctrl_Pen[id])
        elsif lFields[i] = CONTROLINFO_x then
	        lResult = append(lResult, ctrl_X_Pos[id])
        elsif lFields[i] = CONTROLINFO_y then
    	    lResult = append(lResult, ctrl_Y_Pos[id])
        elsif lFields[i] = CONTROLINFO_erase then
    	    lResult = append(lResult, ctrl_Erase[id])
        elsif lFields[i] = CONTROLINFO_scroll then
            lResult = append(lResult, ctrl_Scroll[id])
        elsif lFields[i] = CONTROLINFO_range then
	        lResult = append(lResult, ctrl_Range[id])
        elsif lFields[i] = CONTROLINFO_tabitems then
    	    lResult = append(lResult, ctrl_Tabitems[id])
        elsif lFields[i] = CONTROLINFO_group then
            lResult = append(lResult, ctrl_Group[id])
        elsif lFields[i] = CONTROLINFO_cursor then
	        lResult = append(lResult, ctrl_Cursor[id])
        elsif lFields[i] = CONTROLINFO_hotkey_keys then
    	    lResult = append(lResult, ctrl_Hotkey_Keys[id])
        elsif lFields[i] = CONTROLINFO_hotkey_ids then
            lResult = append(lResult, ctrl_Hotkey_Ids[id])
        elsif lFields[i] = CONTROLINFO_textalign then
	        lResult = append(lResult, ctrl_Text_Alignment[id])
        elsif lFields[i] = CONTROLINFO_closed then
    	    lResult = append(lResult, ctrl_Closed[id])
        elsif lFields[i] = CONTROLINFO_tabenabled then
            lResult = append(lResult, ctrl_TabKey_Used[id])
        elsif lFields[i] = CONTROLINFO_eventhandler then
	        lResult = append(lResult, ctrl_Handlers[id])
        elsif lFields[i] = CONTROLINFO_bbrush then
    	    lResult = append(lResult, ctrl_Bg_Brush[id])
        elsif lFields[i] = CONTROLINFO_tag then
    	    lResult = append(lResult, ctrl_UserData[id])
        elsif lFields[i] = CONTROLINFO_itag then
    	    lResult = append(lResult, ctrl_IntData[id])
        elsif lFields[i] = CONTROLINFO_name then
    	    lResult = append(lResult, ctrl_Name[id])
        elsif lFields[i] = CONTROLINFO_deferredhandlers then
    	    lResult = append(lResult, ctrl_Deferred_Handlers[id])
        elsif lFields[i] = CONTROLINFO_autoheight then
    	    lResult = append(lResult, ctrl_Auto_Height[id])
        elsif lFields[i] = CONTROLINFO_autowidth then
    	    lResult = append(lResult, ctrl_Auto_Width[id])
        elsif lFields[i] = CONTROLINFO_init then
    	    lResult = append(lResult, ctrl_Init_Posns[id])
        elsif lFields[i] = CONTROLINFO_mousetrap then
    	    lResult = append(lResult, ctrl_Mousetrap[id])
        elsif lFields[i] = CONTROLINFO_classinfo then
            lResult = append(lResult,{
                        className[ctrl_Type[id]],
                        classType[ctrl_Type[id]],
                        classStyle[ctrl_Type[id]],
                        classStyleEx[ctrl_Type[id]],
                        classAttr[ctrl_Type[id]],
                        classBGColor[ctrl_Type[id]],
                        classFGColor[ctrl_Type[id]],
                        classDefPointer[ctrl_Type[id]]
                        })
        end if
    end for
    end if

    if atom(pFields) then
        lResult = lResult[1]
    end if
    return lResult
end function

-----------------------------------------------------------------------------
-- FONTS
--
-----------------------------------------------------------------------------

--/topic Fonts
--/func useLogicalResolution(integer pLogRes)
--/desc Sets the flag that determines if logical font resolution is used or not.
--/ret The previous value of the flag
-- /i pLogRes is 1 to use logical resolution (initial value),
-- 0 to use physical resolution.
global function useLogicalResolution(integer pLogRes)
    integer lOldValue

    lOldValue = vFontResolution
    vFontResolution = pLogRes

    return lOldValue
end function

--/topic Fonts
--/func convPointsToLogical(object id, object points, integer pLogRes)
--/desc Calculates the 'logical' height of a font given its 'points' size.
--/ret The logical font height.
--This can be used to speed up /setFont and /EzCreateFont calls by allowing
--you to pre-calculate the font heights that Windows needs to find the correct
--font. See example for how it can be used.
--
--/i id is either a control's ID or a sequence containing a control's DC. /n
--/i points is either a single font point value, or a sequence containing
-- a set of point values to convert. /n
--/i pLogRes is a flag - w32True or w32False. If w32True then the logical device
--resolution is used otherwise the physical device resolution is used.
--
--/b Note that if the /i points is supplied as a sequence, the the /b return
-- value is also a sequence of the same length.
--
--Examples:
--/code
--      sequence lFontHeights
--      -- Calc font heights to be used.
--      -- This returns a set of 4 height values.
--      lFontHeights = convPointsToLogical(mainpanel, {10,12,15,26}, w32True)
--      . . .
--      -- Set the font using one of the precalc heights.
--      setFont(mainpanel, "Arial", {lFontHeights[kHeading1]}, Normal)
--/endcode
global function convPointsToLogical(object pDC, object pHeight, integer pLogRes)
    sequence lHeight
    atom lDC
    atom lSavedDC
    atom lDpiY
    atom lPoint

    -- save the current device context because I'm about to
    -- possibly mess it up.

    if atom(pHeight) then
        lHeight = {pHeight}
    else
        lHeight = pHeight
    end if

    if atom(pDC) then
        -- Then a control ID was passed
        lDC = getDC(pDC)
    else
        -- Else a real dc was passed
        lDC = pDC[1]
    end if

    lSavedDC = w32Func( xSaveDC, {lDC} )
    if lSavedDC = 0 then
        abortErr( Err_ECFSAVEDCFAIL )
    end if

    -- these are NT specific. they should have no effect in Win95
    VOID = w32Func( xSetGraphicsMode, {lDC, GM_ADVANCED} )
    VOID = w32Func( xModifyWorldTransform, {lDC, NULL, MWT_IDENTITY} )

    VOID = w32Func( xSetViewportOrgEx, {lDC, 0, 0, NULL} )
    VOID = w32Func( xSetWindowOrgEx,   {lDC, 0, 0, NULL} )


    if ( pLogRes ) then
        lDpiY = w32Func( xGetDeviceCaps, {lDC, LOGPIXELSY} )

    else
        lDpiY = (25.4 * w32Func( xGetDeviceCaps, {lDC, VERTRES} ) /
                        w32Func( xGetDeviceCaps, {lDC, VERTSIZE} ) )

    end if

    -- w32allot
    lPoint  = w32acquire_mem( 0, SIZEOF_POINT )
    for i = 1 to length(lHeight) do
        w32store( lPoint,ptY, floor(lHeight[i] * lDpiY / 72.0) )
        VOID = w32Func( xDPtoLP, {lDC, lPoint, 1} )
        lHeight[i] = -floor(w32abs( w32fetch( lPoint,ptY ))  + 0.5)
    end for
    w32release_mem(lPoint)

    -- restore the device context
    if not w32Func( xRestoreDC, {lDC, lSavedDC} ) then
        abortErr( Err_ECFRESTOREDC )
    end if

    if atom(pDC) then
        releaseDC( pDC )
    end if


    if atom(pHeight) then
        return lHeight[1]
    else
        return lHeight
    end if

end function

--/topic Fonts
--/func EzCreateFont( integer id, atom pDC, sequence faceName, integer iDeciPtHeight, integer iDeciPtWidth, object iAttributes, integer fLogRes, atom logfont )
--/desc Creates a Font resource
--/ret The new font resource.
-- This is a low-level routine that is not normally required to be called
-- directly. It is primarily for advanced users. /n
--The parameters are: /n
--/code
-- /i id           : The control whose Device Context will be used. /n
-- /i pDC          : The device context. If zero, the routine will
--                   get and release the device context itself. /n
-- /i faceName     : font name /n
-- /i iHeight      : font size, * 10 (i.e.: 125 = 12.5 points /n
-- /i iWidth       : /b Note this is no longer supported. /n
-- /i iAttributes  : flags for attributes, see Bold, etc. /n
-- /i fLogRes      : if true, uses logical resolution instead of screen res. /n
-- /i logfont      : if non-zero, a pointer to user-supplied LOGFONT structure. /n
--/endcode
--
global function EzCreateFont( integer id, atom pDC, sequence pFaceName,
                                object pHeight, atom pDeciPtWidth,
                                object pAttributes, integer pLogRes,
                                atom pLogFont )
    atom    hdc
    atom    hFont
    atom    lf
    atom    savedDC
    atom    lHeight,
            lWidth,
            lEscapement,
            lOrientation,
            lCharSet,
            lOutPrecision,
            lClipPrecision,
            lQuality,
            lPitchAndFamily,
            lStdAttribs

    sequence lFontKey
    integer lPosn

    if pLogFont != 0 then
        return w32Func( xCreateFontIndirect, {pLogFont} )
    end if

    if sequence(pHeight) then
        -- User supplied the logical device height
        lHeight = pHeight[1]

    else
        -- Need to convert point size into logical device height.
        if pDC = 0 then
            hdc = getDC(id)
        else
            hdc = pDC
        end if

        lHeight = convPointsToLogical({hdc}, pHeight/10.0, pLogRes)

        if pDC = 0 then
            releaseDC( id )
        end if

    end if

    lFontKey =  {
                    'E',
                    lHeight,
                    pAttributes,
                    vFontWeight,
                    pFaceName
                }
    lPosn = find(lFontKey, vFontKeys)
    if lPosn = 0 then

        lf  = w32acquire_mem( 0, SIZEOF_LOGFONT )
        w32store( lf, lfHeight,         lHeight)
        w32store( lf, lfFaceName,       pFaceName )

        if sequence(pAttributes) then
            lStdAttribs   = pAttributes[1]
            w32store( lf, lfWidth,          pAttributes[2] )
            w32store( lf, lfEscapement,     pAttributes[3] )
            w32store( lf, lfOrientation,    pAttributes[4] )
            w32store( lf, lfCharSet,        pAttributes[5] )
            w32store( lf, lfOutPrecision,   pAttributes[6] )
            w32store( lf, lfClipPrecision,  pAttributes[7] )
            w32store( lf, lfQuality,        pAttributes[8] )
            w32store( lf, lfPitchAndFamily, pAttributes[9] )
        else
            lStdAttribs   = pAttributes
        end if

        w32store( lf, lfWeight,         ((and_bits( lStdAttribs, Bold)    ) != 0) * vFontWeight )
        w32store( lf, lfItalic,         (and_bits( lStdAttribs, Italic)   ) != 0 )
        w32store( lf, lfUnderline,      (and_bits( lStdAttribs, Underline)) != 0 )
        w32store( lf, lfStrikeOut,      (and_bits( lStdAttribs, Strikeout)) != 0 )

        -- create the font
        hFont = w32Func( xCreateFontIndirect, {lf} )

        vFontKeys = append(vFontKeys, lFontKey)
        vFontHandles &= hFont
        w32release_mem(lf)
    else
        hFont = vFontHandles[lPosn]
    end if
-- **NOTE** This is not supported from v0.59.2
--    if (pDeciPtWidth != 0 ) then
--
--        -- replace the current font
--       replaceObject( id, kFontObject, hdc, hFont, ForProgram )
--
--        -- text metric
--        tm  = w32acquire_mem( mset, SIZEOF_TEXTMETRIC )
--
--        -- get the text metrics on the font
--        if not w32Func( xGetTextMetrics, {hdc, tm} ) then
--            abortErr( Err_ECFGETTEXTMETRICS )
--        end if
--
--        -- calculate the new size
--        w32store( lf, lfWidth, floor( w32fetch(tm,tmAveCharWidth) *
--                                   w32abs( w32fetch(pt,ptX) ) /
--                                   w32abs( w32fetch(pt,ptY) ) + 0.5
--                                )
--             )
--
--        -- build the font
--        hFont = w32Func( xCreateFontIndirect, {lf} )
--
--    end if




    -- return handle to font
    return hFont

end function


-----------------------------------------------------------------------------
--/topic Fonts
--/func assignFont( integer id)
--/desc Gets the device context for /i id with the current font installed.
--/ret ATOM: A Device Context (hDC)
-- This is different to the /getDC() function, which only returns the DC with
-- the default font installed. This one assigns the 'current' font to the DC.
--
--/b Note that /i id can have the form {id, DC} which allows you to pass an
-- existing DC, to which you can assign a font to. The DC passed is returned
-- by this routine. However, if /i DC is zero, a new DC is created.
--
--Example:
--/code
--    atom dc
--    dc = assignFont(myPixMap)
--    w32Proc( xTextOut, {dc, x, y, textaddr, textlen} )
--    releaseDC(dc)
--/endcode
global function assignFont( object id)

    -- set font into the hdc, using the attributes of the font
    --  this is shared by wPuts, getFontSize and getTextExtent

    atom fontID
    object result
    atom hdc

    if sequence(id) then
        hdc = id[2]
        id = id[1]
    else
        hdc = 0
    end if

    if hdc = 0 then
        hdc = getDC(id)
    end if

    -- need to create a font based on the attributes?
    if length( ctrl_Font[id][FontName] ) > 0 then
        fontID = EzCreateFont( id, hdc,              -- create font
	            ctrl_Font[id][FontName],      -- font name
	            w32iff(sequence(ctrl_Font[id][FontSize]),
	             ctrl_Font[id][FontSize],
	             ctrl_Font[id][FontSize]*10),   -- points
	            0,
	            ctrl_Font[id][FontAttrib],    -- attributes
	            vFontResolution , 0)
    elsif id = Printer then
        -- set to hard-coded values for default printer font.
        fontID = EzCreateFont( id, hdc, "Times New Roman", 100, 0, 0,
                vFontResolution , 0)

    else
        -- get the stock system font object
        fontID = DefaultFontID
    end if

    -- replace the font
    replaceObject( id, kFontObject, hdc, fontID, ForPaint )

    -- use the pen color?

    if w32Func(xSetTextColor, {hdc, UseColor(ctrl_Font[id][FontColor])} ) = CLR_INVALID then
        -- unable to set color
        warnErr( Err_SETTEXTCOLOR )
    end if

    -- set transparent or opaque
    if not w32Func(xSetBkMode, {hdc, ctrl_Pen[id][PenBkMode]} ) then
        -- unable to set mode
        warnErr( Err_SETBKMODE )
    end if

    if not w32Func(xSetBkColor , {hdc, UseColor(ctrl_Pen[id][PenBkColor])} ) then
        -- unable to set mode
        warnErr( Err_SETBKCOLOR )
    end if

    return hdc
end function


-----------------------------------------------------------------------------
--/topic Fonts
--/proc wPuts( object window, object text )
--/desc Equivalent to Euphoria's /i puts() function.
-- The /i window parameter determines what /Window will be written to. /n
-- It can be either a control id or a sequence in the form {id, X, Y} to move
-- the pen to X,Y before writing the text.
--
-- This is usually used inside an onPaint event handler.
--
-- If /i text is actually a number, it will be converted to text first. The
-- /i text parameters can also be used to specify a formatting string. To do
-- so place the format string as the first element and the second element then
-- should contain a list of parameters for the format string.
--
-- It is also possible to supply a RAM address if the text is pre-stored in
-- memory rather than a sequence. To do this, you must format the second
-- parameter as {{RAMaddress, length}}
--
-- Example:
--/code
--      -- put text in a window
--      /wPuts( MyWindow, "Hello, World!" )
--      /wPuts( TotalAmountFld, 1234.56 )
--      /wPuts( {MyWindow, 17, 5}, {"Name: %s", {firstName}} )
--
--      /wPuts( MyWindow, {{hSavedText, 45}} )
--/endcode

global procedure wPuts( object id, object s )
    atom hdc
    integer sLen

    -- Move pen first if asked.
    if sequence(id) then
        call_proc(r_setPenPos,{id[1], id[2], id[3]})
        id = id[1]
    end if

    -- Check for formatting
    if atom(s) then
        s = sprintf("%g", s)
        sLen = length( s )
    elsif length(s) = 2 and sequence(s[1]) then
        s = sprintf(s[1], s[2])
        sLen = length( s )
    elsif length(s) = 1 and
          sequence(s[1]) and
          length(s[1]) = 2 and
          atom(s[1][1]) and
          atom(s[1][2]) then
        sLen = length(s[1][2]) -- Length of RAM text
        s = s[1][1] -- RAM address of text.
    else
        sLen = length( s )
    end if

    -- set the font
    hdc = assignFont( id)

    -- align the text
    VOID = w32Func( xSetTextAlign, { hdc, ctrl_Text_Alignment[id] } )

    -- display the text in the buffer
    w32Proc( xTextOut, { hdc,
         ctrl_X_Pos[id],
         ctrl_Y_Pos[id],
         s,
         sLen} )

    -- release the device context

    releaseDC( id )

end procedure

--/topic Text
--/proc textOut( atom HDC, sequence TextDef )
--/desc Writes text to a control.
--This is a special version of /wPuts that can be faster under certain
-- circumstances. /n
-- /i HDC is the Device Context of a control and not its /b Id. This can
-- be obtained by /getDC() or /assignFont(). And must be released after
-- use. /n
-- /i TextDef is a sequence of up to 7 elements. Elements 4 thru 7 are
-- optional and can be 'omitted' by using an empty sequence for them. /n
-- The elements are ... /n
--/i pTextDefn[1]  = text string to display.
--/i pTextDefn[2]  = x (horizontal pixel position)
--/i pTextDefn[3]  = y (vertical pixel position)
--/i pTextDefn[4]  = Foregroud color
--/i pTextDefn[5]  = Background color
--/i pTextDefn[6]  = Mode (OPAQUE or TRANSPARENT)
--/i pTextDefn[7]  = Vertical Alignment with respect to character height.
-- (AlignTop, AlignBottom, AlignBaseline) /n
--
-- Example:
--/code
--      atom hdc
--      hdc = assignFont(Mypixmap)
--      H = getTextHeight(Mypixmap, "|")
--      W = 4
--      textOut(hdc,{"   Name:", W, 0 * H, Black, White, OPAQUE})
--      textOut(hdc,{"Address:", W, 1 * H})
--      textOut(hdc,{"    Age:", W, 2 * H})
--      textOut(hdc,{" Weight:", W, 3 * H})
--
--      W = getTextWidth(Mypixmap, "_") * 9
--      textOut(hdc,{NameFld, W, 0 * H, Blue, BrightWhite})
--      textOut(hdc,{AddressFld, W, 1 * H})
--      textOut(hdc,{sprintf("%d",AgeFld), W, 2 * H})
--      textOut(hdc,{sprintf("%5.2f", WeightFld), W, 3 * H})
--      releaseDC(Mypixmap)
--/endcode

global procedure textOut( atom hdc, sequence pTextDefn)


    pTextDefn &= repeat({},7)

    if atom(pTextDefn[6]) then
        VOID = w32Func(xSetBkMode , {hdc, pTextDefn[6]})
    end if

    if atom(pTextDefn[4]) then
        VOID = w32Func(xSetTextColor, {hdc, UseColor(pTextDefn[4])} )
    end if

    if atom(pTextDefn[5]) then
        VOID = w32Func(xSetBkColor , {hdc, UseColor(pTextDefn[5])})
    end if

    if atom(pTextDefn[7]) then
        VOID = w32Func( xSetTextAlign, { hdc, pTextDefn[7] } )
    end if

    -- display the text in the buffer
    w32Proc( xTextOut, { hdc,
         pTextDefn[2],
         pTextDefn[3],
         pTextDefn[1],
         length( pTextDefn[1] )
} )


end procedure

-----------------------------------------------------------------------------
--/topic Fonts
--/proc wPrintf( window, format, data )
--/desc Equivalent to Euphoria's /i printf() routine.
-- /i window specifies the /Window to receive the text. /n
-- /i window can either be a single window id, or a sequence in the form
-- { id, x, y } where /i x and /y is the pen position to write at. /n
-- This is usually used inside an onPaint event handler. /n
-- Note that this does not handle NEWLINE characters, use /drawText for that.
--
--Example:
--/code
--      -- show value of a
--      /wPrintf( MyWindow, "the value of a is %d", {a} )
--
--      -- Now print at pen position (5,25).
--      /wPrintf( {MyWindow, 5, 25}, "Code %s", {theCode} )
--/endcode

global procedure wPrintf( object id, sequence s1, object o )

    -- use wPuts to display message
    wPuts( id, sprintf( s1, o ) )

end procedure

integer vShowChars
vShowChars = 0
--/topic Fonts
--/proc showChars(integer pFlag)
--/desc Determines if /wPrint displays characters or numbers
-- If /i pFlag is zero, then the /wPrint routine acts like Euphoria's
-- print command and displays normal characters as numbers in a sequence.
-- If /i pFlag is non-zero, the /wPrint command displays these characters
-- as quoted characters. /n
-- The initial setting is zero.
--
--Example
--/code
--        showChars(0)
--        wPrint(mywin, "abc") -- displays {97,98,99}
--        showChars(1)
--        wPrint(mywin, "abc") -- displays {'a','b','c'}
--/endcode

global procedure showChars(integer pFlag)
    vShowChars = (pFlag != 0)
end procedure

-----------------------------------------------------------------------------
function print_format( object o )

    -- returns object formatted for wPrint
    sequence s

    if integer( o ) then
    -- number
    if   vShowChars != 0
     and find(o, "`~!@#$%^&*()_+-={}|[]\\:\";'<>?,./" &
	       "1234567890" &
	       "abcdefghijklmnopqrstuvwxyz" &
	       "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
           ) then
        return sprintf("'%s'", o)
    else
        return sprintf( "%d", o )
    end if
    elsif atom( o ) then
    return sprintf( "%f", o )
    else
    -- list
    s = "{"
    for i = 1 to length( o ) do
        s = s & print_format( o[i] )
        if i < length( o ) then
	    s = s & ","
        end if
    end for
    s = s & "}"
    return s
    end if

end function


-----------------------------------------------------------------------------
--/topic Fonts
--/proc wPrint( window, object )
--/desc Equivalent to Euphoria's /i print() routine.
-- /i window specifies the /Window to receive the data.
--
-- For example:
--/code
--      -- dump s to the window
--      /wPrint( MyWindow, s )
--/endcode

global procedure wPrint( integer id, object o )

    -- win32 version of Euphoria's print statement
    -- use wPuts to display message
    wPuts( id, print_format( o ) )

end procedure


--/topic Utilities
--/func struct_CHARFORMAT(dwMask,dwEffects,yHeight,yOffset,crTextColor,bCharSet,bPitchAndFamily,szFaceName)
--/desc Builds a CHARFORMAT structure and returns its address.
--/ret The address of a valid CHARFORMAT structure.
global function struct_CHARFORMAT( atom dwMask, atom dwEffects,
    atom yHeight, atom yOffset, atom crTextColor, atom bCharSet,
    atom bPitchAndFamily, sequence szFaceName )

    atom cf

    cf = w32acquire_mem( 0, SIZEOF_CHARFORMAT )

    w32store( cf, CHARFORMAT_cbSize, SIZEOF_CHARFORMAT )
    w32store( cf, CHARFORMAT_dwMask, dwMask )
    w32store( cf, CHARFORMAT_dwEffects, dwEffects )
    w32store( cf, CHARFORMAT_yHeight, yHeight )
    w32store( cf, CHARFORMAT_yOffset, yOffset )
    w32store( cf, CHARFORMAT_crTextColor, UseColor(crTextColor) )
    w32store( cf, CHARFORMAT_bCharSet, bCharSet )
    w32store( cf, CHARFORMAT_bPitchAndFamily, bPitchAndFamily )
    w32store( cf, CHARFORMAT_szFaceName, szFaceName)

    return cf

end function

--/topic Utilities
--/func fetch_CHARFORMAT(atom CHARFORMAT)
--/desc Extracts the data from a CHARFORMAT structure.
--/ret A sequence containing the data fields.

global function fetch_CHARFORMAT( atom CHARFORMAT )
    sequence char
    char = {
      w32fetch( CHARFORMAT, CHARFORMAT_cbSize ),
      w32fetch( CHARFORMAT, CHARFORMAT_dwMask ),
      w32fetch( CHARFORMAT, CHARFORMAT_dwEffects),
      w32fetch( CHARFORMAT, CHARFORMAT_yHeight ),
      w32fetch( CHARFORMAT, CHARFORMAT_yOffset ),
      w32fetch( CHARFORMAT, CHARFORMAT_crTextColor ),
      w32fetch( CHARFORMAT, CHARFORMAT_bCharSet ),
      w32fetch( CHARFORMAT, CHARFORMAT_bPitchAndFamily ),
      w32fetch( CHARFORMAT, CHARFORMAT_szFaceName )
      }

    return char
end function

global function struct_PARAFORMAT(atom dwMask, integer wNumbering,
    atom dxStartIndent, atom dxRightIndent, atom dxOffset,
    integer wAlignment, sequence rgxTabs)
    atom pf

    pf = w32acquire_mem( 0, SIZEOF_PARAFORMAT )

    w32store( pf, PARAFORMAT_cbSize, SIZEOF_PARAFORMAT )
    w32store( pf, PARAFORMAT_dwMask, dwMask )
    w32store( pf, PARAFORMAT_wNumbering, wNumbering )
    w32store( pf, PARAFORMAT_dxStartIndent, dxStartIndent )
    w32store( pf, PARAFORMAT_dxRightIndent, dxRightIndent )
    w32store( pf, PARAFORMAT_dxOffset, dxOffset )
    w32store( pf, PARAFORMAT_wAlignment, wAlignment )
    w32store( pf, PARAFORMAT_cTabCount, length( rgxTabs ) )
    w32store( pf, PARAFORMAT_rgxTabs, rgxTabs )
    return pf

end function


-----------------------------------------------------------------------------
--/topic Fonts
--/proc setFont( object id, sequence fontname, object size, object attributes )
--/desc Set the font for a control or window.
--
-- /i id can be either a single control's id, or a sequence list of ids.
--
-- /i fontname is the name of a font, eg. "Arial" /n
-- For RichEdit controls this parameter can also specify the color of the font.
-- In this case it takes to form {color, name}, eg.  {Red, "Arial"}
--
-- The /i attributes flag can be a atom that combines the following:
--
-- /li /b Normal
-- /li /b Bold
-- /li /b Italic
-- /li /b Underline
-- /li /b Strikeout
--
-- or a sequence of nine elements. This form is used when using non-TrueType
-- fonts or using some of the advanced features of the Windows font engine. /n
--
--/li [1] Attributes (eg Bold+Italic)
--/li [2] Average Char Width
--/li [3] Escapement  (How much it slopes in 10-degree increments)
--/li [4] Orientation (Should be set to the same as Escapement)
--/li [5] CharSet  (eg. ANSI_CHARSET, SYMBOL_CHARSET)
--/li [6] OutPrecision
--/li [7] ClipPrecision
--/li [8] Quality
--/li [9] PitchAndFamily
--
-- For RichEdit controls only, the /i attrib parameter can also prepend "ALL"
-- to the attrib sequence so that all the text is set to the font, otherwise
-- the change of font just applies to the insertion point.
--
-- For example:
--
--/code
--      -- change the font in MyWindow
--      setFont( MyWindow, "Arial", 10, Bold+Italic )
--      /wPuts( MyWindow, "This is Arial 10 point bold italic." )
--
--      setFont( MyWindow, "System", 14, {Bold,0,0,0,ANSI_CHARSET,0,0,0,0} )
--
--      setFont( MyWindow, "Symbol", 10, {0,0,0,0,SYMBOL_CHARSET,0,0,0,0} )
--
--      change all the text to courier.
--      setFont( MyRichEdit, "Courier New", 12, {"ALL",Normal} )
--
--      -- Set a group of fields to all the same font.
--      setFont( {fld1, fld3, fld2, fld7}, "Arial", 10, Normal)
--/endcode

global procedure setFont( object id, sequence faceName, object points, object attrib )
    -- set the current font attributes
    -- Window fonts are set as attributes for later assignment
    atom
        hFont,
        color,
        effects,
        font_effect

    sequence
        lResult,
        fontname,
        tracked,
        lres
    integer
        lPos

    if atom(points) then
        points = floor(points + 0.5)
    end if

    if sequence(id) then
        for i = 1 to length(id) do
            setFont(id[i], faceName, points, attrib)
        end for
        return
    end if

    -- Note that the faceName is {color, "faceName"} for RichEdit
    if ctrl_Type[id] = RichEdit then
        -- Do some sanity checks on this parameter.
        color = ctrl_Font[id][FontColor]
        fontname = ctrl_Font[id][FontName]
        if length(faceName) = 0 then
            faceName = {color,fontname}

        elsif length(faceName) = 1 then
            if sequence(faceName[1]) then
	        faceName = {color, faceName[1]}
            else
	        faceName = {faceName[1], fontname}
            end if

        elsif length(faceName) = 2 then
            if sequence(faceName[1]) then
    	        if atom(faceName[2]) then
    	            faceName = {faceName[2], faceName[1]}
    	        else --Ooops I've got two sequences
    	            faceName = {color, faceName[2]}
    	        end if
            else
    	        if atom(faceName[2]) then -- I've got to atoms
    	            faceName = {faceName[1], fontname}
    	        end if
            end if
        elsif length(faceName) > 2  then
            faceName = {color, faceName}
        end if

        color = faceName[1]
        faceName = faceName[2]
        ctrl_Font[id][FontColor] = color

        font_effect = SCF_SELECTION
        if sequence(attrib) then
            if length(attrib) = 0 then
                attrib = Normal
            else
                if sequence(attrib[1]) then
                    if equal(attrib[1], "ALL") then
                        font_effect = SCF_ALL
                    else
                        font_effect = SCF_SELECTION
                    end if
                    attrib = attrib[2..length(attrib)]
                end if
                if length(attrib) = 0 then
                    attrib = Normal
                elsif length(attrib) = 1 then
                    attrib = attrib[1]
                end if
            end if
        end if

    end if

    ctrl_Font[id][FontName]   = faceName
    ctrl_Font[id][FontSize]   = points
    ctrl_Font[id][FontAttrib] = attrib

    if ctrl_Type[ id ] = RichEdit then
        effects = 0

        lResult = findTrackedObject( id, {faceName,points,attrib,color})
        if length(lResult) = 0 then
            if atom(attrib) then
                if and_bits( attrib, Bold ) then
                    effects = or_bits( effects, CFE_BOLD )
                end if

                if and_bits( attrib, Italic ) then
                    effects = or_bits( effects, CFE_ITALIC )
                end if
            else
                if and_bits( attrib[1], Bold ) then
                    effects = or_bits( effects, CFE_BOLD )
                end if

                if and_bits( attrib[1], Italic ) then
                    effects = or_bits( effects, CFE_ITALIC )
                end if
            end if
           hFont = struct_CHARFORMAT( CFM_ALL , effects, points * 20, 0, color,
	               0, 0, faceName )

           -- track it
           trackObject( {id,kFontObject}, {hFont,{faceName,points,attrib,color}}, ForProgram )
        else
           hFont = lResult[1]
        end if

        VOID = sendMessage( id, EM_SETCHARFORMAT, font_effect, hFont )

    elsif find(id,{ Printer, Screen } )
         or
      find(ctrl_Family[id], {WINDOW, PIXMAP, MENU, MENUITEM, POPUP})  then
        -- defer creation until print event
    else
        -- create now

        hFont = EzCreateFont( id, 0, faceName,
                    w32iff(sequence(points), points,points * 10), 0, attrib,
                    vFontResolution, 0 )

        -- update immediately
        VOID = sendMessage( id, WM_SETFONT, hFont, w32True )

    end if

end procedure
r_setFont = routine_id("setFont")

-----------------------------------------------------------------------------
--/topic Fonts
--/proc setDefaultFont( id )
--/desc Set the font to default system font.
--
-- Example:
--
--/code
--      -- restore MyWindow to the default font
--      /setDefaultFont( MyWindow )
--/endcode

global procedure setDefaultFont( integer id )

    -- Window fonts are set as attributes for later assignment

    -- empty name indicates default font
    ctrl_Font[id][FontName]   = ""

    if ctrl_Family[id] = WINDOW
    or ctrl_Family[id] = PIXMAP then
        -- defer creation until print event

    else
        -- update immediately
        VOID = sendMessage( id, WM_SETFONT, DefaultFontID, w32True )

    end if

end procedure

--/topic System Attributes
--/func setCreateFont( sequence faceName, atom points, object attrib, atom color )
--/desc sets the font used for controls when they are created.
--/ret SEQUENCE: The previous values for the creation font.
--When controls are created, they need to have a font associated with them. By
-- default Win32lib initially uses "ms sans serif, 8 point, Normal. You
-- can use this function to set a different font for new controls rather than
-- change the font after they are created.
--
--Example
--/code
--      sequence oldFont
--      -- Set a special font to use.
--      oldFont = setCreateFont("Times New Roman", 14, Normal, Black)
--      -- Create some controls
--      fldA = create(Editbox, ...
--      fldB = create(Editbox, ...
--      fldC = create(List, ...
--      -- Restore fot to initial one.
--      VOID = setCreateFont(oldFont[1], oldFont[2], oldFont[3], oldFont[4])
--/endcode
global function setCreateFont( sequence faceName, atom points, object attrib, atom color )
    sequence lOldFont
    lOldFont = FontDefaults

    FontDefaults = { faceName, floor(points+0.5), attrib, color }

    return lOldFont
end function


--/topic RichEdit Control
--/proc setAlignment( id, alignment )
--/desc Align text in a /RichEdit Control
-- Sets Alignment of the paragraph which includes the selection in a
-- /RichEdit control.
-- /i alignment should be one of the following values:
-- /li /b AlignLeft
-- /li /b AlignRight
-- /li /b AlignCenter
global procedure setAlignment( integer id, integer align )
    atom PF

    if align = AlignLeft then
        align = PFA_LEFT
    elsif align = AlignRight then
        align = PFA_RIGHT
    else
        align = PFA_CENTER
    end if

    PF = struct_PARAFORMAT( PFM_ALIGNMENT, 0, 0, 0, 0, align, {} )
    VOID = sendMessage( id, EM_SETPARAFORMAT, 0, PF )

    w32release_mem(PF)

end procedure

--/topic RichEdit Control
--/proc setBullet( id )
-- Toggles the bulleting of the paragraph which includes the selection in a
-- /RichEdit control.
global procedure setBullet( integer id )
    atom PF

    PF = struct_PARAFORMAT( 0, 0, 0, 0, 0, 0, {} )

    VOID = sendMessage( id, EM_GETPARAFORMAT, 0, PF)
    w32store( PF, PARAFORMAT_wNumbering, not w32fetch( PF, PARAFORMAT_wNumbering ) )
    w32store( PF, PARAFORMAT_dwMask, PFM_NUMBERING )
    VOID = sendMessage( id, EM_SETPARAFORMAT, 0, PF )

    w32release_mem(PF)

end procedure

--/topic RichEdit Control
--/proc setIndent( id, start, right, offset )
--/desc Change indenting in a /RichEdit Control
-- Sets indenting.  If you don't want to change any of the indent modes,
-- pass it's parameter as a sequence.  All values should be in pixels.
global procedure setIndent( integer id, object start, object right, object offset )
    atom PF, mask

    mask = 0

    if atom( start ) then
    mask = w32or_all({ mask, PFM_STARTINDENT } )
    else
    start = 0
    end if

    if atom( right ) then
    mask = or_bits( mask, PFM_RIGHTINDENT )
    else
    right = 0
    end if

    if atom( offset ) then
    mask = w32or_all( {mask, PFM_OFFSET} )
    else
    offset = 0
    end if

    PF = struct_PARAFORMAT( mask, 0, start, right, offset, 0, {} )

    VOID = sendMessage( id, EM_SETPARAFORMAT, 0, PF )

    w32release_mem(PF)

end procedure

--/topic List Control
--/proc setTabs( id, tabs )
--/desc Set/change tab stops in a /List or /SortedList Control.
-- /i tabs should be a sequence of integers. Each one is a tabstop
-- position measured in 1/4 character widths.

--/topic RichEdit Control
--/proc setTabs( id, tabs )
--/desc Change tab stops in a /RichEdit Control.
-- /i tabs should be a sequence of absolute positions for the tab stops
-- in 1/1000 of an inch.
global procedure setTabs(integer id, sequence tabs )
    atom PF
    atom NumberOfTabStops
    atom TabArrayAddress -- address of integer array of TAB stops
    atom pokeAt
    atom ret
    sequence bytes

    if ctrl_Type[id] = RichEdit then
        PF = struct_PARAFORMAT( PFM_TABSTOPS, 0, 0, 0, 0, 0, tabs )

        VOID = sendMessage( id, EM_SETPARAFORMAT, 0, PF )

        w32release_mem(PF)
    elsif find(ctrl_Type[id],{List, SortedList}) then
        -- Build and array of integers in memory to pass to windows
        -- w32allot bytes for each tab stop element to build a 32 bit tab array
        TabArrayAddress = w32acquire_mem(0, length( tabs ) * 4 )
        -- poke the values into the tab array address
        poke4( TabArrayAddress, tabs)
        -- send a windows message to the list box to set tabstops
        VOID = sendMessage( id, LB_SETTABSTOPS,
                            length(tabs),
                            TabArrayAddress)

        w32release_mem(TabArrayAddress)

    end if

end procedure

--/topic Attributes
--/func setErasePolicy(integer id, integer Flag)
--/desc Sets and gets the Background Erasing policy for the control /i id
--/ret INTEGER: The current policy value.
--/i id is a control id. /n
--If /i Flag is negative (eg. -1) then this routine just returns the current
-- policy value. If it is zero it sets the policy that the window's background
-- is automatically cleared to the default color whenever it needs erasing. If
-- it is positive (eg. 1) then the application must take responsibility of
-- erasing the background during a Paint event.
--
--Example:
--/code
--      integer oldval
--      oldval = setErasePolicy( TickerWin, 1)
--/endcode
global function setErasePolicy(integer id, integer pFlag)
    integer lCurrentValue

    lCurrentValue = ctrl_Erase[id]
    if pFlag >= 0 then
        ctrl_Erase[id] = (pFlag != 0)
    end if

    return lCurrentValue
end function

global function struct_EDITSTREAM( atom dwCookie, atom dwError, atom pfnCallback )
    atom ES

    ES = w32acquire_mem(0,  SIZEOF_EDITSTREAM )

    w32store( ES, EDITSTREAM_dwCookie, dwCookie )
    w32store( ES, EDITSTREAM_dwError, dwError )
    w32store( ES, EDITSTREAM_pfnCallback, pfnCallback )

    return ES
end function

global function struct_CHARRANGE( atom min, atom max )
    atom CR

    CR = w32acquire_mem(0,  SIZEOF_CHARRANGE )

    w32store( CR, CHARRANGE_cpMin, min )
    w32store( CR, CHARRANGE_cpMax, max )

    return CR
end function

global function struct_FINDTEXTEX( atom min1, atom max1, sequence text,
    atom min2, atom max2 )

    atom FT, ptr

    FT = w32acquire_mem(0,  SIZEOF_FINDTEXTEX )
    w32store( FT, FINDTEXTEX_chrgcpMin, min1 )
    w32store( FT, FINDTEXTEX_chrgTextcpMin, min2 )
    w32store( FT, FINDTEXTEX_chrgcpMax, max1 )
    w32store( FT, FINDTEXTEX_chrgTextcpMin, max2 )
    w32store( FT, FINDTEXTEX_lpstrText, text )

    return FT

end function

global constant
findDown = FR_DOWN,
findWholeWord = FR_WHOLEWORD,
findMatchCase = FR_MATCHCASE

--/topic RichEdit Control
--/func findText( id, text, range, flags )
--/desc Find text in a /RichEdit Control.
--/ret Index where text begins, or zero if not found
-- /i range should be a sequence containing the range of text you'd
-- like to search within the /RichEdit, or an atom, if you want to search
-- through all of the text.
-- /i flags can be a combination of the folowing:
-- /li /b findWholeWord
-- /li /b findMatchCase
-- /li /b findDown = Current to DocEnd, else Current to DocStart
--
--/code
--   atom fnd, frompoint
--   integer cnt
--   sequence word
--      -- Count all occurances of a word.
--      word = "procedure"
--      cnt = 0
--      frompoint = 0
--      fnd = -1
--      while fnd != 0 do
--          fnd = findText(myRichFld, word, {frompoint,-1},
--                                  findDown + findMatchCase + findWholeWord)
--          if fnd then
--               cnt += 1
--               frompoint = fnd
--          end if
--      end while
--
--/endcode
global function findText( integer id, sequence text, object range,
    integer flags )
    atom FT, index

    if atom(range) then
    range = { 0, -1 }
    end if

    FT = struct_FINDTEXTEX( range[1], range[2], text, 0, 0 )

    index = sendMessage( id, EM_FINDTEXTEX, flags, FT ) + 1
    -- convert to one-based index

    w32release_mem(FT)

    return index

end function

global function struct_FINDREPLACE( atom owner, atom flags, sequence fwhat,
    sequence rwhat )
    atom fr, pf, pr


    fr = w32acquire_mem( 0, SIZEOF_FINDREPLACE )

    if length(fwhat) > 255 then
    fwhat = fwhat[1 .. 255]
    end if

    if length(rwhat) > 255 then
    rwhat = rwhat[1 .. 255]
    end if

    fwhat = fwhat & repeat(0, 255 - length( fwhat ) )
    pf = w32acquire_mem(fr, fwhat )

    rwhat = rwhat & repeat( 0, 255 - length( rwhat ) )
    pr = w32acquire_mem(fr, rwhat )

    w32store( fr, FINDREPLACE_lStructSize, SIZEOF_FINDREPLACE )
    w32store( fr, FINDREPLACE_hwndOwner, owner )
    w32store( fr, FINDREPLACE_Flags, flags )

    w32store( fr, FINDREPLACE_lpstrFindWhat, pf )
    w32store( fr, FINDREPLACE_wFindWhatLen, 255 )

    w32store( fr, FINDREPLACE_lpstrReplaceWith, pr )
    w32store( fr, FINDREPLACE_wReplaceWithLen, 255 )

    return fr

end function

--/topic Dialogs
--/proc getFindText( id )
--/desc Opens the "Find" Dialog
-- /i id should be the id of the control in which the Find Dialog will
-- search.  The Find dialog is a modeless dialog, which means that it
-- will remain open and on top, until the user closes it.
global procedure getFindText( object id )
    atom fr, dlg

    if atom(id) then
        fr = struct_FINDREPLACE( getHandle( id ), 0, "", "" )
        dlg = w32Func( FindTextA, { fr } )
    else
        -- TODO: Implement callback hook
    end if
end procedure

--/topic Dialogs
--/proc getReplaceText( id )
--/desc Opens the "Replace" Dialog
-- /i id should be the id of the control in which the Replace Dialog will
-- search.  The Replace dialog is a modeless dialog, which means that it
-- will remain open and on top, until the user closes it.
global procedure getReplaceText( object id )
    atom fr, dlg
    if atom(id) then
        fr = struct_FINDREPLACE( getHandle( id ), 0, "", "" )
        dlg = w32Func( ReplaceTextA, { fr } )
    else
        -- TODO: Implement callback hook
    end if
end procedure



sequence vStreamCallbackBuffer
vStreamCallbackBuffer = {}
integer vStreamCBPosn
vStreamCBPosn = 1

function getStreamCallback(atom dwCookie, atom pbBuff, atom cb,
    atom pcb )
    -- Get the characters from the buffer
    vStreamCallbackBuffer &= peek( {pbBuff, cb} )
    -- Let the control know how many I pulled out.
    poke4( pcb, cb )
    -- Return 'no error'
    return  0
end function
constant gscb = call_back( routine_id( "getStreamCallback" ) )

function putStreamCallback(atom dwCookie, atom pbBuff, atom cb,
    atom pcb )

    atom lCBLen, lStart, lEnd, lRemaining


    lStart = vStreamCBPosn
    lRemaining = length(vStreamCallbackBuffer) - lStart + 1

    if lRemaining < 1 then
        -- Tell Windows that nothing is left.
        poke4( pcb, 0 )
        return 0
    end if

    if cb > lRemaining then
        lCBLen = lRemaining
    else
        lCBLen = cb
    end if
    poke4( pcb, lCBLen )
    lEnd = lStart + lCBLen - 1

    -- Avoid creating a slice if using the entire buffer.
    if lEnd = length(vStreamCallbackBuffer) and lStart = 1 then
        poke( pbBuff, vStreamCallbackBuffer)
    else
        poke( pbBuff, vStreamCallbackBuffer[lStart .. lEnd] )
    end if
    if lEnd = length(vStreamCallbackBuffer) then
        vStreamCallbackBuffer = ""
    else
        vStreamCBPosn = lEnd + 1
    end if

    return 0
end function
constant pscb = call_back( routine_id( "putStreamCallback" ) )

-----------------------------------------------------------------------------
--/topic RichEdit Control
--/func getStream( integer id, integer flags )
--/desc Convert the data in a RichEdit control to a sequence.
--/ret SEQUENCE: The contents of the RichEdit control.
-- Use flag /b StreamText to return plain text, or /b StreamRTF to return
-- rich text. This can be combined to /b StreamSelection to only return
-- any selected content from the RichEdit.
--
-- Example:
--
--/code
--           -- Create a RichEdit control
--           RE = /create( /RichEdit, "", Win , 20, 20, 360, 200, ES_NOHIDESEL)
--           . . .
--           -- Save the text into a file from a RichEdit control
--           richout = open("MyRich.txt", "w")
--           -- Get the selected text from the control.
--           printf(richout, "%s", { /getStream( RE, StreamText + StreamSelection) } )
--
--           close( richout )
--
--/endcode
--
global function getStream( integer id, integer flags )
    atom EDITSTREAM, uFormat
    sequence streamout

    uFormat = and_bits(StreamMask, flags)

    vStreamCallbackBuffer = ""
    EDITSTREAM = struct_EDITSTREAM( 0, 0, gscb )

    VOID = sendMessage( id, EM_STREAMOUT, uFormat, EDITSTREAM )

    w32release_mem( EDITSTREAM )
    streamout = vStreamCallbackBuffer
    vStreamCallbackBuffer = {}

    return streamout
end function

-----------------------------------------------------------------------------
--/topic RichEdit Control
--/proc putStream( integer id, integer flag, sequence text )
--/desc Load text into a RichEdit control from a text sequence.
-- Use /i flag /b StreamText to indicate that /i contains plain text,
-- or /b StreamRTF to indicate that /i text contains rich text.
-- This can be combined with StreamSelection so that only any selected
-- text in the control is replaced with /i text data.
--
-- Example:
--
--/code
--           sequence rich
--           integer RE, fn, c
--           . . .
--           -- Create a RichEdit control
--           RE = /create( /RichEdit, "", Win , 20, 20, 360, 200, ES_NOHIDESEL)
--
--           -- Load the text into the RichEdit control
--           fn = open("rich.rtf", "r")
--           if fn != -1 then
--               rich = {}
--               c = getc( fn )
--               while c != -1 do
--                   rich &= c
--                   c = getc( fn )
--               end while
--
--               /putStream( RE, StreamRTF, rich )
--
--               close( fn )
--           end if
--
--/endcode

global procedure putStream( integer id, integer flags, sequence streamin )
    atom uFormat
    atom EDITSTREAM
    integer lLen
    atom lResult

    if not length(streamin) then
        return
    end if

    lLen  = length(streamin)
    uFormat = and_bits(StreamMask, flags)

    vStreamCallbackBuffer = streamin
    vStreamCBPosn = 1

    EDITSTREAM = struct_EDITSTREAM( 0, 0, pscb )

    VOID = sendMessage( id, EM_STREAMIN, uFormat, EDITSTREAM )
    lResult = w32fetch(EDITSTREAM, EDITSTREAM_dwError)
    w32release_mem( EDITSTREAM )

end procedure

global function struct_TEXTRANGE( atom min, atom max )
    atom TR, range

    range = max - min + 1

    TR = w32acquire_mem(0,  SIZEOF_TEXTRANGE )

    w32store( TR, TEXTRANGE_chrgcpMin, min )
    w32store( TR, TEXTRANGE_chrgcpMax, max )
    w32store( TR, TEXTRANGE_lpstrText, repeat( 0, range ) )

    return TR
end function


-- 18 total params!
global function struct_REBARBANDINFO(
    atom fMask,
    atom fStyle,
    atom clrFore,
    atom clrBack,
    object lpText,
    atom iImage,
    atom hwndChild,
    atom cxMinChild,
    atom cyMinChild,
    atom cx,
    atom hbmBack,
    atom wID,
    atom cyChild,
    atom cyMaxChild,
    atom cyIntegral,
    atom cxIdeal,
    atom lParam,
    atom cxHeader )

    atom rb, lpstr, cch

    rb = w32acquire_mem(0,  SIZEOF_REBARBANDINFO )

    if sequence(lpText) then
        cch = length( lpText )
        if cch then
            lpstr = w32acquire_mem(rb, lpText )
        else
            lpstr = 0
        end if
    else
        lpstr = 0
        cch = 0
    end if
    w32store( rb, REBARBANDINFO_cbSize, SIZEOF_REBARBANDINFO )
    w32store( rb, REBARBANDINFO_fMask, fMask )
    w32store( rb, REBARBANDINFO_fStyle, fStyle )
    w32store( rb, REBARBANDINFO_clrFore, clrFore )
    w32store( rb, REBARBANDINFO_clrBack, clrBack )
    w32store( rb, REBARBANDINFO_lpText, lpstr )
    w32store( rb, REBARBANDINFO_cch, cch )
    w32store( rb, REBARBANDINFO_iImage, iImage )
    w32store( rb, REBARBANDINFO_hwndChild, hwndChild )
    w32store( rb, REBARBANDINFO_cxMinChild, cxMinChild )
    w32store( rb, REBARBANDINFO_cyMinChild, cyMinChild )
    w32store( rb, REBARBANDINFO_cx, cx )
    w32store( rb, REBARBANDINFO_hbmBack, hbmBack )
    w32store( rb, REBARBANDINFO_wID, wID )
    w32store( rb, REBARBANDINFO_cyChild, cyChild )
    w32store( rb, REBARBANDINFO_cyMaxChild, cyMaxChild )
    w32store( rb, REBARBANDINFO_cyIntegral, cyIntegral )
    w32store( rb, REBARBANDINFO_cxIdeal, cxIdeal )
    w32store( rb, REBARBANDINFO_lParam, lParam )
    w32store( rb, REBARBANDINFO_cxHeader, cxHeader )

    return rb
end function

--/topic Attributes
--/func setReBarAutoSizing( integer Flag)
--/desc Sets/Gets the automatic resizing facility for ReBar controls.
--/ret INTEGER: Current Value
--/i Flag is either /b w32True to enable Win32Lib to automatically take care
--of moving controls around relative to the height of the ReBar control, or
--/b w32False to disable this facility.
--
-- The current value for this facility is returned. Initially this facility
-- is disabled.
--
--Example:
--/code
--      integer CurVal
--      -- Enable automatic handling of rebar height changes.
--      CurVal = setReBarAutoSizing( w32True )
--/endcode

global function setReBarAutoSizing( integer pFlag)
    integer lOldFlag

    lOldFlag = AutoReBarSizing
    AutoReBarSizing = (pFlag != 0)

    return lOldFlag
end function

-----------------------------------------------------------------------------
function queryFont( integer id, atom pRequest, sequence pArgs )

    -- this runs a query about font attributes. Because the query
    -- can run against controls which have no obtainable DC, the
    -- queries are performed on the mainWindow. The exception is
    -- the Printer, which uses it's own DC.
    --
    -- The DC is automatically prepended to the /i pArgs list.
    --
    -- Since the mainWindow is used, it has to be restored to it's
    -- prior state when the query is complete.

    integer lUseId
    atom lHDC, lResult
    sequence lSavedFont

    lSavedFont = {}

    -- Attempt to get a DC for this control.
    lHDC = getDC({id, "ignorenull"})

    -- If I can't then use the Screen's DC
    if lHDC = 0 then

        lUseId = Screen
        -- Swap font defn
        lSavedFont = ctrl_Font[lUseId]
        ctrl_Font[lUseId] = ctrl_Font[id]
    else
        lUseId = id
    end if

    -- set the font and get control's dc
    lHDC = assignFont( {lUseId, lHDC})

    -- perform the requested function
    lResult = w32Func( pRequest, lHDC & pArgs )

    -- release the DC
    releaseDC( lUseId )

    -- used the main window?
    if length(lSavedFont) != 0 then
        -- restore the font attributes
        ctrl_Font[lUseId] = lSavedFont
    end if

    return lResult

end function

-----------------------------------------------------------------------------
--/topic Fonts
--/func getFontMetric( id, field )
--/desc Gets font metric field value for /i id's current font.
--/ret field's value
-- The /i field can be one of:
--/li    tmHeight
--/li    tmAscent
--/li    tmDescent
--/li    tmInternalLeading
--/li    tmExternalLeading
--/li    tmAveCharWidth
--/li    tmMaxCharWidth
--/li    tmWeight
--/li    tmOverhang
--/li    tmDigitizedAspectX
--/li    tmDigitizedAspectY
--/li    tmFirstChar
--/li    tmLastChar
--/li    tmDefaultChar
--/li    tmBreakChar
--/li    tmItalic
--/li    tmUnderlined
--/li    tmStruckOut
--/li    tmPitchAndFamily
--/li    tmCharSet
--/li    ntmFlags
--/li    ntmSizeEM
--/li    ntmCellHeight
--/li    ntmAveWidth
--
-- Example:
--
--/code
--          -- get the descent for the default font
--          integer descent
--
--          /setDefaultFont( MyWindow )
--          descent = /getFontMetric( MyWindow, tmDescent )
--          /wPrintf( MyWindow, "The default font's descent is %", descent )
--/endcode

global function getFontMetric( integer id, sequence field )

    -- get metrics for current font

    atom result
    atom tm

    -- text metric structure
    tm  = w32acquire_mem(0,  SIZEOF_TEXTMETRIC )

    -- get the metrics of the font (queryFont will prepend the DC)
    if not queryFont( id, xGetTextMetrics, {tm} ) then
        warnErr( Err_GETFONTMETRIC )
    end if

    -- fetch field
    result = w32fetch(tm, field)

    -- release
    w32release_mem( tm )

    return result

end function


-----------------------------------------------------------------------------
--/topic Fonts
--/func getFontSize( id )
--/desc Gets font metrics for /i id's current font.
--/ret { width, height } of average character.
--
-- Example:
--
--/code
--          -- show the metrics of the default font
--          sequence size
--
--          /setDefaultFont( MyWindow )
--          size = /getFontSize( MyWindow )
--          /wPrintf( MyWindow, "The default font is %d by %d", size )
--/endcode

global function getFontSize( integer id )

    -- get metrics for current font

    integer width, height, maxwidth
    atom tm

    -- text metric structure
    tm  = w32acquire_mem(0, SIZEOF_TEXTMETRIC )

    -- get the metrics of the font (queryFont will prepend the DC)
    if not queryFont( id, xGetTextMetrics, {tm} ) then
        warnErr( Err_GETFONTSIZE )
    end if

    -- assign values
    width   = w32fetch(tm,tmAveCharWidth)
    maxwidth   = w32fetch(tm,tmMaxCharWidth)
    height  = w32fetch(tm,tmHeight) +
                w32fetch(tm,tmInternalLeading) +
                w32fetch(tm,tmExternalLeading)

    -- release
    w32release_mem( tm )

    -- return results
    return { width, height, maxwidth }

end function


-----------------------------------------------------------------------------
--/topic Fonts
--/func getTextHeight( integer Id, sequence text )
--/desc Gets the height of the /i text using the current font for the /i id
--/ret ATOM: Height of the text.
global function getTextHeight( integer id, sequence text )

    -- get metrics for current font
    atom size, string, mset, height

    -- Grab some memory from the system
    mset = w32new_memset()
    size  = w32acquire_mem( mset, SIZEOF_SIZE )
    text = w32removeItem('&', text)
    string = w32acquire_mem( mset, text )

    -- get the metrics of the font (queryFont will prepend the DC)
    if not queryFont( id, xGetTextExtentPoint,
    	            {string, length(text), size} ) then
            abortErr( Err_GETTEXTEXTENT )
    end if

    height  = w32fetch(size,sizY)

    -- give back the memory
    w32release_mem( mset )

    -- return results
    return height

end function

-----------------------------------------------------------------------------
--/topic Fonts
--/func getTextWidth( integer Id, sequence text )
--/desc Gets the width of the /i text using the current font for the /i id
--/ret ATOM: Width of the text.
global function getTextWidth( integer id, sequence text )

    -- get metrics for current font
    atom size, string, mset, width

    -- Grab some memory from the system
    mset = w32new_memset()
    size  = w32acquire_mem( mset, SIZEOF_SIZE )
    text = w32removeItem('&', text)
    string = w32acquire_mem( mset, text )

    -- get the metrics of the font (queryFont will prepend the DC)
    if not queryFont( id, xGetTextExtentPoint,
    	            {string, length(text), size} ) then
            abortErr( Err_GETTEXTEXTENT )
    end if

    width   = w32fetch(size,sizX )

    -- give back the memory
    w32release_mem( mset )

    -- return results
    return width

end function
r_getTextWidth = routine_id("getTextWidth")


-----------------------------------------------------------------------------
--/topic Fonts
--/func getTextExtent( integer Id, sequence textset )
--/desc Gets the metrics of the /i textset strings, using /i Id's current font.
--/ret SEQUENCE: maxwidth, maxheight, minwidth, minheight, totalwidth, totalheight
--The /i textset parameter can either be a normal text string or a sequence of
-- strings. /n
-- /b Note: The first or only /b'&' character in each string will not be included
-- in the metrics.
--
-- Example #1: Show the size of a text string.
--/code
--          sequence text, extent
--
--          -- the string to measure
--          text = "Hi, there!"
--
--          -- measure the string
--          extent = /getTextExtent( MyWindow, text )
--
--          -- show results
--          /wPrintf( MyWindow, "The string %s is %d by %d pixels",
--                                   {string, extent[1], extent[2]} )
--/endcode
--
-- Example #2: Calculate the size of some buttons
--/code
--          sequence btntext, extent, btns
--          integer btnheight, btnwidth
--          sequence x
--          integer y
--
--          -- the strings to measure
--          btntext = {"&Print", "&Cancel", "&Ok", "&Help"}
--
--          -- measure the string
--          extent = /getTextExtent( MyWindow, btntext )
--
--          -- calc button dimensions
--          btnheight = extent[2] + 10 -- adjust for borders
--          btnwidth  = extent[1] + 8  -- adjust for borders
--
--          -- Draw the buttons
--          btns = {}
--          x = 5
--          y = 10
--          for i = 1 to length(btntext) do
--              btns &= create(PushButton, MyWindow, btntext[i],
--                          x, y, btnwidth, btnheight, 0)
--              y += btnheight + 1
--          end for
--
--/endcode

global function getTextExtent( integer id, sequence text )

    -- get metrics for current font

    integer width, height
    integer maxwidth, maxheight
    integer minwidth, minheight
    integer totwidth, totheight
    atom size, lStrAddr, mset

    if length(text) = 0 or atom(text[1]) then
        text = {text}
    end if
    maxheight = 0
    maxwidth = 0
    minheight = 0
    minwidth = 0
    totheight = 0
    totwidth = 0

    -- Grab some memory from the system
    mset = w32new_memset()
    size  = w32acquire_mem( mset, SIZEOF_SIZE )
    for i = 1 to length(text) do
        text[i] = w32removeItem('&', text[i])
        lStrAddr = w32acquire_mem( mset, text[i] )

        -- get the metrics of the font (queryFont will prepend the DC)
        if not queryFont( id, xGetTextExtentPoint,
    	            {lStrAddr, length(text[i]), size} ) then
            abortErr( Err_GETTEXTEXTENT )
        end if

        -- assign values
        width   = w32fetch(size,sizX )
        height  = w32fetch(size,sizY)

        -- determine maximums
        if i = 1 or width > maxwidth then
            maxwidth = width
        end if
        if i = 1 or height > maxheight then
            maxheight = height
        end if
        -- determine minimums
        if i = 1 or width < minwidth then
            minwidth = width
        end if
        if i = 1 or height < minheight then
            minheight = height
        end if
        -- determine totals
        totwidth += width
        totheight += height

    end for
    -- give back the memory
    w32release_mem( mset )

    -- return results
    return { maxwidth, maxheight, minwidth, minheight, totwidth, totheight }

end function

-----------------------------------------------------------------------------
--/topic Fonts
--/proc getCharExtent( integer Id)
--/desc Gets the average character width and height for the /i Id's current font.
--/ret SEQUENCE: avgwidth, avgheight
--/b Note 1: The averages are not integers. You may have to floor() them. /n
--/b Note 2: These are averages! Be wary of this when using them to calculate
-- field sizes for proportional fonts.
--
-- Example
--/code
--          sequence extent
--          integer fldWidth
--
--          extent = /getCharExtent( MyWindow )
--
--          -- Calculate the amount of space need to display the text.
--          fldWidth = floor(extent[1] * length(text))
--/endcode
--
-- Example #2: Calculate the size of some buttons
--/code
--          sequence btntext, extent, btns
--          integer btnheight, btnwidth
--          sequence x
--          integer y
--
--          -- the strings to measure
--          btntext = {"&Print", "&Cancel", "&Ok", "&Help"}
--
--          -- measure the string
--          extent = /getTextExtent( MyWindow, btntext )
--
--          -- calc button dimensions
--          btnheight = extent[2] + 10 -- adjust for borders
--          btnwidth  = extent[1] + 8  -- adjust for borders
--
--          -- Draw the buttons
--          btns = {}
--          x = 5
--          y = 10
--          for i = 1 to length(btntext) do
--              btns &= create(PushButton, MyWindow, btntext[i],
--                          x, y, btnwidth, btnheight, 0)
--              y += btnheight + 1
--          end for
--
--/endcode

global function getCharExtent( integer id)
    sequence lExtent, lResult

    lExtent = getTextExtent(id, {"W"," ._-|@0123456789" &
	            "abcdefghijklmnopqrstuvwxyz" &
	            "ABCDEFGHIJKLMNOPQRSTUVWXYZ"})
    lResult = {(lExtent[1] / 68 + lExtent[3]) / 2,
           (lExtent[2]      + lExtent[4]) / 2
          }

    return lResult
end function

-----------------------------------------------------------------------------
--/topic Fonts
--/proc setTextAlign( id, style )
--/desc Set the font alignment to use when printing text.
--
-- The default option is AlignTop. Options include:
--
-- /li /b AlignTop: Text is displayed below {x,y}
-- /li /b AlignBottom: Text is displayed above {x,y}
-- /li /b AlignBaseline: Text is displayed on baseline {x,y}
--
-- Example:
--
--/code
--          -- draw a line
--          drawLine( Win, 10, 100, 100, 100 )
--
--          -- top alignment (default)
--          setTextAlign( Win, AlignTop )
--          setPenPos( Win, 10, 100 )
--          wPuts( Win, "AlignTop" )
--
--          -- bottom alignment
--          setTextAlign( Win, AlignBottom )
--          setPenPos( Win, 10, 100 )
--          wPuts( Win, "AlignBottom" )
--
--/endcode

global procedure setTextAlign( integer id, integer flag )
    ctrl_Text_Alignment[id] = flag
end procedure

-----------------------------------------------------------------------------
--/topic Graphics
--/func split_rgb( object pColor)
--/desc Convert a color into a {red, green, blue}.
--/ret Sequence: 3-element {RED, GREEN, BLUE}
-- Converts the color value into its component colors.
--
-- Example:
-- /code
--      -- get the colors got a pixel
--      RGB = split_rgb( getPixel(myBMP, 4,7) )
--      RGB = split_rgb( "BrightCyan" )
--      RGB = split_rgb( COLOR_BUTTONFACE )
--      RGB = split_rgb( Magenta )
-- /endcode
atom gColors gColors = w32acquire_mem(vPermMemSet, 4)
global function split_rgb( object pColor )
    poke4(gColors, colorValue(pColor))
    return peek({gColors,3})
end function

global function adjustBrightness(atom pColor, atom pAdjustment)
    sequence lRGB

    lRGB = split_rgb(pColor)
    lRGB = floor( lRGB * pAdjustment )
    for i = 1 to 3 do
        if lRGB[i] > 255 then
            lRGB[i] = 255
        elsif lRGB[i] < 0 then
            lRGB[i] = 0
        end if
    end for
    return rgb(lRGB[1], lRGB[2], lRGB[3])

end function
-----------------------------------------------------------------------------
--/topic Graphics
--/proc repaintWindow( window )
--/desc Force /i window to be entirely repainted.
-- This repaints the entire window in it's background color, effectively
-- erasing everything in it. It then triggers an /onPaint event
-- for that window, requesting that the entire window be repainted.
--
-- Example:
--
--/code
--      -- force MyWindow to be repainted
--      /repaintWindow( myWindow )
--/endcode

global procedure repaintWindow( integer id )
    -- redraws *everything*
    atom hwnd

    -- get handle
    if id <= 0 or id > length(ctrl_Handle) then
        hwnd = 0
    else
        hwnd = ctrl_Handle[id]
    end if

    -- invalidate all of the current window, and clear it
    VOID = w32Func( xInvalidateRect, {hwnd, NULL, 1} )

    -- trigger an immediate paint message
    VOID = w32Func(xSendMessage,{ hwnd, WM_PAINT, 0, 0 })

end procedure

-----------------------------------------------------------------------------
--/topic Graphics
--/proc repaintFG( window )
--/desc Force /i window to be repainted but without clearing it first.
-- This triggers an /onPaint event
-- for that window, requesting that the entire window be repainted.
--
-- It is different to /repaintWindow() in that the window is not cleared
-- to its background color first.
--
-- Example:
--
--/code
--      -- force MyWindow to be repainted
--      /repaintFG( myWindow )
--/endcode
global procedure repaintFG( integer id )
    -- redraws *everything*
    atom hwnd

    -- get handle
    if id <= 0 or id > length(ctrl_Handle) then
        hwnd = 0
    else
        hwnd = ctrl_Handle[id]
    end if

    -- invalidate all of the current window, and clear it
    VOID = w32Func( xInvalidateRect, {hwnd, NULL, 0} )

    -- trigger an immediate paint message
    VOID = w32Func(xSendMessage,{ hwnd, WM_PAINT, 0, 0 })


end procedure


-----------------------------------------------------------------------------
--/topic Graphics
--/proc repaintRect( window, x1, y1, x2, y2 )
--/desc Force /i window to be partially repainted.
-- This sends repaints at the specified portion of the /i window with
-- the background color, erasing that portion of it. It then triggers
-- an /onPaint event for that window, passing the erased area as
-- parameters.
--
-- Example:
--
--/code
--      -- repaint only a portion of MyWindow
--      /repaintRect( myWindow, 1, 1, 10, 10 )
--/endcode

global procedure repaintRect( integer id, integer x1, integer y1,
	    	    integer x2, integer y2 )

    -- invalidates only a portion of the window
    atom hWnd
    atom rect

    -- Allocate rectangle
    rect = w32acquire_mem( 0, SIZEOF_RECT )
    poke4(rect, {x1,y1,x2,y2})

    hWnd = getHandle( id )

    -- invalidate all of the current window, and clear it
    if not w32Func( xInvalidateRect, {hWnd, rect, 1} ) then
        warnErr( Err_REPAINTRECT )
    end if

    -- Free the rectangle structure
    w32release_mem( rect )

    -- trigger an immediate paint message
    VOID = w32Func(xSendMessage,{hWnd, WM_PAINT, 0, 0 })


end procedure



------------------------------------------------------
--/topic Attributes
--/proc clearWindow( integer id)
--/desc Sets /i id to its background color
-- This is used to wipe a Window or Pixmap
-- Example:
--
--/code
--          /clearWindow( MyWindow )
--          /clearWindow( MyPixmap )
--/endcode

global procedure clearWindow( integer id)
    sequence lRect
    sequence lSavedBrushColor

    if not equal(ctrl_Bg_Color, w32WinDefColor) then
        lRect = call_func(r_getRect,{id})
        lSavedBrushColor = ctrl_Pen[id][PenBrushColor]
        -- Use Back color as temporary brush color.
        ctrl_Pen[id][PenBrushColor] = {ctrl_Bg_Color[id]}
        call_proc(r_drawRectangle,{id, w32True, 0, 0, lRect[3], lRect[4]})
        ctrl_Pen[id][PenBrushColor] = lSavedBrushColor
    end if

    return

end procedure


------------------------------------------------------
--/topic Attributes
--/proc setWindowBackColor( object id, object Color )
--/desc Sets /i id to /i color.
-- This is used to change the background color of a window or control.
--
-- /i id can be a single control id or a list of ids.
--
-- /i Color can either be an atom with a rgb value or a three-element sequence
-- formated as {red, green, blue} values (0-255). /n
-- You can also use /getSysColor to get a default system color. /b
-- This will trigger an /onPaint event.
--
-- Note, this will not effect push buttons.
--
-- Example:
--
--/code
--          -- Set the window background color to bright white
--          /setWindowBackColor( MyWindow, BrightWhite )
--          -- Set a list's background color to salmon pink
--          /setWindowBackColor( List1, {255, 128, 128} )
--          -- Set an edit field to look like a button color.
--          /setWindowBackColor( Edit1, getSysColor(COLOR_BTNFACE) )
--          -- Set a group of controls
--          /setWindowBackColor( {ctl1, ctl2, ctl3}, Cyan)
--/endcode

global procedure setWindowBackColor( object id, object rgbColor )

    -- set the background color of a window or control
    -- use rgb() to calculate a color

    atom lNewBrush, lOldBrush, dc, old
    sequence lRect
    integer lId


    if not sequence(id) then
        id = {id}
    end if

    for i = 1 to length(id) do
        lId = id[i]
        -- save color
        ctrl_Bg_Color[ lId ] = rgbColor

        if ctrl_Type[lId] = Pixmap then
            clearWindow(lId)

        else

            if not equal(rgbColor, w32WinDefColor) then
                -- create a new brush
                lNewBrush = w32Func( xCreateSolidBrush, {colorValue(rgbColor)} )

                -- set that as the background color
                lOldBrush = ctrl_Bg_Brush[lId]
                ctrl_Bg_Brush[lId] = lNewBrush

                -- delete the prior brush
                deleteObject( lOldBrush )

                -- If this is a window, then change the Class background too.
                if ctrl_Type[lId] = Window then
                    VOID = w32Func(xSetClassLong, {getHandle(lId), GCL_HBRBACKGROUND, lNewBrush})
                end if

            end if
            -- redraw the screen
            repaintWindow( lId )
        end if
    end for
end procedure


-----------------------------------------------------------------------------
-- CREATING CONTROLS
--
-----------------------------------------------------------------------------

procedure createMenu( integer id, sequence mText, integer owner )

    -- used to assign a menu or popup menu to a window
    -- the structure is already created by create()
    object attachTo
    atom pstr, result
    atom mstyle
    atom mid
    integer class

    class = ctrl_Family[ id ]

    -- if menu and there is no menu for this window, create one
    if  class = MENU and
        ctrl_Family[owner] = WINDOW and
        ctrl_Menu[ owner ]= 0  then
        -- create a menu
        ctrl_Menu[ owner ] = w32Func( xCreateMenu, {} )
        if ctrl_Menu[ owner ] = 0 then
            warnErr( Err_CREATEMENU )
        end if
        -- attach the menu to the window
        if not w32Func( xSetMenu, { getHandle ( owner ), ctrl_Menu[ owner ] } ) then
            warnErr( Err_SETMENU )
        end if

    end if

    -- create popup menu for this item
    ctrl_Handle[ id ] = w32Func( xCreatePopupMenu, {} )
    ctrl_Handle_type[ id ] = kht_Menu
    if ctrl_Handle[ id ] = NULL then
        warnErr( Err_CREATEPOPUP )
    end if
-- +++++++++setID for this hWnd ? ++++++++++++++++

    -- attach a menu item if it's not a popup
    if class = MENU then
        -- where does this attach to?
        if ctrl_Family[owner] = MENU or
           ctrl_Family[owner] = MENUITEM then
            attachTo = getHandle( owner )

        elsif ctrl_Family[owner] = WINDOW then
            attachTo = ctrl_Menu[owner]
        else
            attachTo = 0
        end if

        mstyle = find('!', mText)
        if mstyle != 0 then
            mText = mText[1..mstyle-1] & mText[mstyle+1..length(mText)]
            mstyle = 0
            mid = id
        else
            mstyle = MF_POPUP
            mid = getHandle(id)
        end if

        -- Record the creation parameters.
        ctrl_Menu[id] = {attachTo, mstyle, mid, MENU}

        result = w32Func( xAppendMenu, {
	            attachTo,
	            mstyle,
	            mid,
	            mText} )
        if not result then
            warnErr( Err_APPENDMENU )
        end if
    end if

    vRecent[w32RecentMenu] = id


end procedure


-----------------------------------------------------------------------------
procedure createMenuItem( integer id, sequence mText, integer owner, object styleFlags )

    integer flag
    atom pstr
    atom lMenuHandle

    -- store owner's handle
    ctrl_Handle[ id ] = getHandle( owner )
    ctrl_Handle_type[ id ] = ctrl_Handle_type[ owner ]

    -- string, or seperator?
    if equal( mText, "-" )  or length(mText) = 0 then
        flag = MF_SEPARATOR

    else
        flag = w32or_all(MF_STRING & styleFlags)
    end if

    -- create a menu item
    pstr = w32acquire_mem(0, mText )
    lMenuHandle = getHandle( owner )
    ctrl_Menu[id] = {lMenuHandle, flag, id, MENUITEM}
    if not w32Func( xAppendMenu, {
	    lMenuHandle,         -- menu to attach to
	    flag,                       -- string or seperator
	    id,                         -- id
	    pstr} )    -- text
    then
        warnErr( Err_APPENDMENUITEM )
    end if

    w32release_mem(pstr)

end procedure

--/topic Menus
--/func getMenuPosn(integer id)
--/desc Get the zero-based relative position of a menu item.
--/ret INTEGER: Zero-Based Position of th emenu item
--/i id is the id of a menu item.
--
--Example
--/code
--  integer pos
--  pos = getMenuPosn(miSave)
--/endcode

global function getMenuPosn(integer pID)
    atom lWnd

    lWnd = getHandle(pID)

    for i = 0 to w32Func(xGetMenuItemCount, {lWnd}) - 1 do
        if w32Func(xGetMenuItemID,{lWnd, i}) = pID then
            return i
        end if
    end for

    return -1

end function

-----------------------------------------------------------------------------
--/topic System Attributes
--/func setAppName(sequence Name)
--/desc Sets the text used as a class name prefix for new Windows.
--/ret Zero if the same application name is not already running
--/b "This needs to be run before the first Window is created in your application."
--The initial value is /i "Win32Lib AppWindow"
--
--A non-zero return code is actually the Windows hWnd value for the other
-- instance of the application.
--
--
--Example
--/code
--     if setAppName("Super Database") != 0 then
--         warnErr("Application is already running")
--     end if
--/endcode

global function setAppName(sequence pName)
    atom rc, ExWin, ExClass


    if length(pName) > 0 then
        vAppName = pName
    end if


    ExWin = w32acquire_mem(0, sprintf("%s 1", {vAppName}))

    rc= w32Func( xFindWindow, { ExWin, 0 } )

    w32release_mem(ExWin)

    return rc
end function

--/topic System Attributes
--/func getAppName()
--/desc Gets the application's name.
--/ret SEQUENCE: The application's name as set by /setAppName
global function getAppName()
    return vAppName
end function


--/topic System Attributes
--/func findWindow(sequence ClassName, sequence WindowTitle)
--/desc Looks to see if the named window exists in the system.
--/ret SEQUENCE: {0,0} if not found otherwise {id, hWnd} if found.
--
--/i ClassName can be zero or a string containing the registered
-- classname of the window you are looking for. /n
--/i WindowTitle can be zero or a string containing the sought after
-- window's caption text.
--
--/b "Note:" You must supply at least one non-zero parameter.
--
--Example
--/code
--      sequence h
--      h = findWindow(0, "Super Database")
--      if equal(h, {0,0}) then
--          -- not found
--      else
--          if h[1] > 0 then
--              -- A control in my running app
--          else
--              -- A window belonging to another app
--          end if
--      end if
--/endcode

global function findWindow(object pClassName, object pWindowCaption)
    atom rc
    atom id

    if equal(pClassName,0) and equal(pWindowCaption,0) then
        return {0,0}
    end if

    rc = w32Func( xFindWindow, { pClassName, pWindowCaption } )
    if rc = 0 then
        return {0,0}
    end if

    id = getId(rc)
    if not validId(id) then
        id = 0
    end if
    return {id, rc}
end function

integer regCount regCount = 1
-----------------------------------------------------------------------------
global procedure registerClass( object szClassName )

    -- register the application class
    atom wndClassEx
    atom lAppIcon
    sequence lClassStyle
    integer lExtraWinSpace

    if atom(szClassName) then
        lClassStyle = vWindowClassStyle
        lExtraWinSpace = 0
    else
        if length(szClassName) = 3 then
            lExtraWinSpace = szClassName[3]
        else
            lExtraWinSpace = 0
        end if
        lClassStyle = szClassName[2]
        szClassName = szClassName[1]
    end if

    lAppIcon = w32Func( xLoadIcon, { instance(), "exw"})
    if lAppIcon = 0 then
       lAppIcon = w32Func( xLoadIcon, { NULL, IDI_APPLICATION })
    end if

    -- get some memory for the window class structure
    wndClassEx = w32acquire_mem(0, SIZEOF_WNDCLASSEX)

    -- build the structure
    w32store( wndClassEx, winExSize, SIZEOF_WNDCLASSEX)
    w32store( wndClassEx, winExStyle, w32or_all(lClassStyle))
    w32store( wndClassEx, winExProc, WndProcAddress)
    w32store( wndClassEx, winExClsExtra, 0)
    w32store( wndClassEx, winExExtra, 0)
    w32store( wndClassEx, winExInstance, instance())
    w32store( wndClassEx, winExIcon, lAppIcon)
    w32store( wndClassEx, winExCursor, NULL)
    w32store( wndClassEx, winExBackground, (-WindowColor-1) + 1 )
    w32store( wndClassEx, winExMenuName, NULL)
    w32store( wndClassEx, winExClassName, szClassName )
    w32store( wndClassEx, winExIconSm, lAppIcon)

    if w32Func( xRegisterClassEx, { wndClassEx } ) = 0 then
        abortErr( Err_REGCLASS )
    end if

    -- Free structure
    w32release_mem( wndClassEx )

end procedure

--/topic System Attributes
--/func getClassName(integer id)
--/desc Gets the Windows Class name for the control.
--/ret SEQUENCE: The class name string
--
--Example
--/code
--      sequence lName
--      lName = getClassName( fld1 )
--/endcode
global function getClassName(integer id)
    sequence lResult
    atom lMem
    integer lSize

    lSize = 256
    lMem = w32acquire_mem(0, lSize)
    lSize = w32Func(xGetClassName,{getHandle(id), lMem, lSize})
    lResult = peek({lMem, lSize})
    w32release_mem(lMem)
    return lResult
end function

-----------------------------------------------------------------------------
--/topic Fonts
--/proc setTextColor( integer window, object color )
--/desc Set the text color to use when drawing text in /i window.
-- To set the color of the graphics pen, use /setPenColor.
--
-- Example:
--/code
--          -- draw text in red in TheWindow
--          /setTextColor( TheWindow, Red )
--          /wPuts( TheWindow, "This text is in red" )
--          /setTextColor( TheWindow, "Cyan" )
--          /wPuts( TheWindow, "This text is in cyan" )
--/endcode


global procedure setTextColor( integer id, object color )

    -- set the text color for the window
    ctrl_Font[id][FontColor] = color

end procedure


-----------------------------------------------------------------------------
global procedure createWindow( integer id, sequence caption,
	        atom owner, atom x, atom y, atom xSize, atom ySize,
	        object styleFlags, object exFlags )
    atom szClassName
    atom hWnd, hParent, result
    atom lFlags, lExFlags, pstr

    -- need to register each window, so each has seperate background
    -- color attributes, etc.
    szClassName = w32acquire_mem( 0, sprintf( "%s %d", {vAppName, regCount} ) )
    regCount += 1
    ctrl_ClassAddr [id] = szClassName

    registerClass( szClassName )

    -- if flags specified, combine them with the defaults
    if atom( styleFlags ) then
         -- combine with user's values
        lFlags = or_bits( classStyle[ ctrl_Type[id]] , styleFlags )
    else
        -- replace with user's values
        lFlags = w32or_all(styleFlags)
    end if

    -- extended flags
    if atom(exFlags) then
        lExFlags = or_bits( classStyleEx[ ctrl_Type[id] ], exFlags )
    else
        lExFlags = w32or_all( exFlags )
    end if

    if owner then
        hParent = getHandle( owner )
    else
        hParent = NULL
    end if

    pstr = w32acquire_mem(szClassName, caption)
    hWnd = w32Func( xCreateWindow, {
	        lExFlags,               -- extended style
	        szClassName,            -- window class name
	        pstr,  -- window caption
	        lFlags,                 -- window style
	        x,                      -- initial x position
	        y,                      -- initial y position
	        xSize,                  -- initial x size
	        ySize,                  -- initial y size
	        hParent,                -- parent window handle
	        NULL,                   -- window menu handle
	        instance(),             -- program instance handle
	        NULL } )                -- creation parameters

    if hWnd = 0 then
        abortErr( Err_CREATEWINDOW )
    end if


    -- save attributes
    vRecent[w32RecentWindow] = id
    setId( hWnd, id )
    ctrl_Handle[ id ] = hWnd
    ctrl_Handle_type[ id ] = kht_Window
    ctrl_Parent[ id ] = owner

    -- set the text and background colors

--    setTextColor( id,  w32Color_WINDOWTEXT  )
--    call_proc(r_setBackColor,{ id,  w32Color_WINDOW  })
    setWindowBackColor( id, ctrl_Bg_Color[id])


    -- set default font
    setDefaultFont(id)
    setFont(id, FontDefaults[1],FontDefaults[2],FontDefaults[3])

    if owner != 0 then
        if  and_bits(WS_VISIBLE, lFlags) then
            call_proc(r_openWindow, {id, Normal})
        end if

        if and_bits( WS_TABSTOP, lFlags ) then
            -- add to the owner's focus_order list
            ctrl_Focus_order[owner] &= id
        end if
    end if


end procedure

-----------------------------------------------------------------------------

--/topic Attributes
--/proc makeFront(object id)
--/desc Brings to control to the front
--/i id can either be a control's id value or take the form {hWnd}.
--
--Example:
--/code
--      atom hwnd_MsgWindow
--      hwnd_MsgWindow = getHandle(MsgWindow)
--      . . .
--      -- Using a control id
--      makeFront( GroupX )
--      -- Using a hWnd
--      makeFront( {hwnd_MsgWindow} )
--/endcode

--------------------------------------------
global procedure makeFront(object id)
--------------------------------------------
    atom hWnd

    if sequence (id) then
        hWnd = id[1]
    else
        if id = 0 then
            id = mainWindow
        end if
        hWnd = getHandle(id)
    end if
    VOID = w32Func(xSetForegroundWindow, {hWnd})

end procedure

-----------------------------------------------------------------------------
procedure createPixmap( integer id, atom pWidth, atom pHeight )

    atom hdc, handle

    ctrl_Handle_type[ id ] = kht_Bitmap

    -- need to initialize pixmap?
    if pWidth > 0 and pHeight > 0 then

        pWidth = floor(pWidth)
        pHeight = floor(pHeight)

        -- get the dc of the screen
        hdc = getDC( Screen )

        -- create a window sized bitmap compatible with the screen
        handle = w32Func( xCreateCompatibleBitmap, { hdc, pWidth, pHeight } )
        -- release the dc
        releaseDC( Screen )

        if handle = NULL then
            warnErr( Err_CREATEPIXMAP )
        end if


        -- store the handle
        ctrl_Handle[ id ] = handle

        -- track the bitmap as a resource
        trackObject( {id,kBitmapObject}, handle, ForProgram )

        -- Fill it with its background color
        if equal(ctrl_Bg_Color[id], w32WinDefColor) then
            ctrl_Pen[id][PenColor] = Black
        else
            ctrl_Pen[id][PenColor] = ctrl_Bg_Color[id]
        end if
        call_proc(r_drawRectangle,{id, w32True, 0, 0, pWidth, pHeight})

    end if


end procedure

-----------------------------------------------------------------------------
procedure createTabItem( integer id, sequence caption, integer pOwner )

    -- insert a tab into a tab control
    integer tabNumber
    atom hTabData, hTabItem

    if ctrl_Type[pOwner] != TabControl then
        abortErr( Err_CREATETABITEM2 )
    end if

    -- add id to owner's tab list
    ctrl_Tabitems[ pOwner ] &= id

    -- get tab index
    tabNumber = length( ctrl_Tabitems[ pOwner ] )

    -- Allocate a tab structure
    hTabData = w32acquire_mem( 0, SIZEOF_TC_ITEM )

    -- set the items
    w32store( hTabData, TC_ITEM_mask,       TCIF_TEXT )
    w32store( hTabData, TC_ITEM_iImage,     -1 )
    w32store( hTabData, TC_ITEM_pszText,    caption )
    w32store( hTabData, TC_ITEM_cchTextMax, length(caption) )

    -- insert into tab list
    hTabItem = sendMessage( pOwner, TCM_INSERTITEM, tabNumber, hTabData )
    if hTabItem = -1 then
        abortErr( Err_CREATETABITEM )
    end if

    -- store the handle
    ctrl_Handle[ id ]  = ctrl_Handle[ pOwner ] --hTabItem
    ctrl_Handle_type[ id ] = kht_TabItem

    -- Free the structure
    w32release_mem( hTabData )

    vRecent[w32RecentWindow] = id

end procedure



--/topic Attributes
--/func isTopLevelWindow(integer id)
--/desc Used to determine if the /i id is a Window that acts independantly of other windows.
--/ret INTEGER: w32True or w32False
--
--Example:
--/code
--      if isTopLevelWindow(xx) then
--          moveWindow(  . . . )
--      end if
--/endcode

global function isTopLevelWindow(integer id)

    if ctrl_Family[id] = WINDOW and
       and_bits(WS_CHILD, w32Func(xGetWindowLong, {getHWND(id), GWL_STYLE})) = 0 then
        return w32True
    end if

    return w32False
end function

--/topic Attributes
--/func findParentWindow(integer id)
--/desc Used to get the Window id of the control specified by /i id
--/ret The id of the Window or zero if this /i id is not in a window.
----------------------------------------------------------
global function findParentWindow(integer id)
----------------------------------------------------------
    -- find the parent window
    if ctrl_Parent[ id ] = 0 then
        -- This is already the top level.
        return id
    end if
    -- loop until I hit top of the tree or a Window control.
    while id and (isTopLevelWindow(id) = w32False) do
        -- move up
        id = ctrl_Parent[ id ]
    end while
    return id
end function


--/topic System Attributes
--/func getActiveWindow()
--/desc Returns the /b id of the control that the user is working on.
--/ret INTEGER: The id of the window or 0 if the app does not have an active window.
--You can use this to find out if the application is currently the active one.
--
--Example:
--/code
--      integer ActiveID
--      ActiveID = getActiveWindow()
--      if ActiveID = 0 then
--          -- No window for this app is active
--      else
--          -- I have an active window.
--      end if
--/endcode
global function getActiveWindow()
    atom lId

	lId = getId(w32Func(xGetForegroundWindow, {}) )
	if not validId(lId) then
	    lId = 0
	end if

	return lId
end function

--/topic Attributes
--/func findParent(object id)
--/desc Used to find the owning control for the specified /i id.
--/ret The id of the control that owns the one specified.
-- This can be used for TreeView items as well by using the syntax for /i id
-- as { TV, TVItemId }
--
-- If the /i id has no parent, this function returns 0. /n
-- If the /i id is invalid, this function returns -1. /n

global function findParent(object id)
    integer lOwner

    if sequence(id) then
        if ctrl_Type[id[1]] = TreeView then
            if id[2] > 0 and id[2] <= length(tvitem_data) then
                lOwner = tvitem_parent[ id[2] ]
            else
                lOwner = -1
            end if
        else
            lOwner = -1
        end if
    else
        lOwner = ctrl_Parent[ id ]
    end if

    return lOwner
end function
r_findParent = routine_id("findParent")


--/topic Attributes
--/func getParent(object id)
--/desc an alias for /findParent
--/ret The id of the control that owns the one specified.

global function getParent(object id)
    return findParent(id)
end function


--/topic Attributes
--/func findChildren(integer id)
--/desc Used to find all the children controls contained in the specified /i id.
--/ret SEQUENCE: Zero or more subsequences {id, controlType}.
-- Each subsequence returned has the control id and the control's type, for
--all the controls owned by /i id. /n
-- It returns an empty sequence if the /i id has no children.
--
--/see /getChildren
--
--Example
--/code
--    sequence children
--    -- Get a list of all the controls owned by this window
--    children = findChildren(myWin)
--
--    -- Set the caption for each of the PushButtons.
--    for i = 1 to length(children) do
--       if find(children[i][2],{PushButton,DefPushButton}) then
--          setText(children[i][1], sprintf("Button%d", i))
--       end if
--    end for
--/endcode

global function findChildren(integer id)
    sequence lChildren

    lChildren = {}
    if ctrl_Type[id] = TabItem then

        for i = 1 to length(ctrl_Group[id]) do
            lChildren &= {{ctrl_Group[id][i], ctrl_Type[ctrl_Group[id][i]]}}
        end for

    elsif ctrl_Type[id] = TabControl then
        -- Can only allow tabitems to be children
        for i = 1 to length(ctrl_Parent) do
            if ctrl_Parent[ i ] = id and ctrl_Type[i] = TabItem then
                lChildren &= {{i, ctrl_Type[i]}}
            end if
        end for

    else
        for i = 1 to length(ctrl_Parent) do
            if ctrl_Parent[ i ] = id then
                lChildren &= {{i, ctrl_Type[i]}}
            end if
        end for
    end if
    return lChildren
end function
r_findChildren = routine_id("findChildren")

--/topic Attributes
--/func getChildren(integer id)
--/desc Used to get all the child controls contained in the specified /i id.
--/ret SEQUENCE: Contains two subsequences {{idlist}, {controlTypes}}.
-- The first subsequences is a list of all the child controls' ids. /n
-- The second subsequence is a list of their corresponding control type codes. /n
-- It returns an empty subsequences if the /i id has no children.
--
--/see /findChildren
--
--Example
--/code
--    sequence children
--    -- Get a list of all the controls owned by this window
--    children = getChildren(myWin)
--
--    -- Set the caption for each of the PushButtons.
--    for i = 1 to length(children) do
--       if find(children[2][i],{PushButton,DefPushButton}) then
--          setText(children[1][i], sprintf("Button%d", i))
--       end if
--    end for
--/endcode
global function getChildren(integer id)
    sequence lChildren

    lChildren = {{},{}}
    if ctrl_Type[id] = TabItem then

        for i = 1 to length(ctrl_Group[id]) do
            lChildren[1] &= ctrl_Group[id][i]
            lChildren[2] &= ctrl_Type[ctrl_Group[id][i]]
        end for

    elsif ctrl_Type[id] = TabControl then
        -- Can only allow tabitems to be children
        for i = 1 to length(ctrl_Parent) do
            if ctrl_Parent[ i ] = id and ctrl_Type[i] = TabItem then
                lChildren[1] &= i
                lChildren[2] &= ctrl_Type[i]
            end if
        end for

    else
        for i = 1 to length(ctrl_Parent) do
            if ctrl_Parent[ i ] = id then
                lChildren[1] &= i
                lChildren[2] &= ctrl_Type[i]
            end if
        end for
    end if

    return lChildren
end function

---/topic Attributes
---/func setParent(integer id, integer newparent)
---/ret INTEGER: True if successful otherwise False
---/desc Changes (or sets) the parent of a control.
---
---Example:
---/code
---/endcode

global function setParent(integer id, integer pNewParent)
--==--==--==--== NOT WORKING YET --==--==--==--
    integer lRC
    atom lOldParent

    if validId(pNewParent) = w32False then
        return w32False
    end if

    if validId(id) = w32False then
        return w32False
    end if

    -- Need to adjust the various internal structures too!

    lOldParent = w32Func( xSetParent, {getHandle(id), getHandle(pNewParent)})
    --For compatibility reasons, SetParent does not modify the WS_CHILD or WS_POPUP
    -- window styles of the window whose parent is being changed. Therefore, if
    --hWndNewParent is NULL, you should also clear the WS_CHILD bit and set the
    --WS_POPUP style after calling SetParent. Conversely, if hWndNewParent is
    -- not NULL and the window was previously a child of the desktop, you should
    --clear the WS_POPUP style and set the WS_CHILD style before calling SetParent.


    if lOldParent = 0 then
        return w32False
    else
        return w32True
    end if

end function


--/topic Attributes
--/proc registerHotKey( integer id, object caption )
--/desc Allows you to associate a ALT-key combination to set focus to a control.
-- Any control or Window can have any number of hotkeys registered. /n
-- /i id is the control/window id returned by /create() /n
-- /i caption is either a single keycode, or a string containing a '&' character. /n
-- If using a keycode, you must use the keycode names in w32Keys.e. If using a string,
-- the uppercase version of the character following the '&' is used. /b Note that this
-- is happens automatically when you /create() a control with some caption text. Also,
-- the default pushbutton, if any, is automatically registered with VK_RETURN.
--
-- Typical use of this procedure is when a control is created without a caption.
--
-- example:
--/code
--       -- Attached the '+' keys to the addBtn control.
--       registerHotKey( addBtn, VK_ADD)
--       registerHotKey( addBtn, VK_OEM_PLUS)
--/endcode

-----------------------------------------------------------------------------
global procedure registerHotKey( integer id, object caption )

    -- register the hotkey with the parent window
integer at, parent, key

   -- find the parent window
   parent = findParentWindow(id)
   if parent = 0 then
      return
   end if

    -- is this a default key?
    if ctrl_Type[ id ] = DefPushButton then
        -- associate the return key with the control
        ctrl_Hotkey_Keys[parent] &= VK_RETURN
        ctrl_Hotkey_Ids[parent]  &= id
    end if

   if sequence(caption) then
      -- is there a hotkey in the caption?
      at = find( '&', caption )
      if at = 0
        or
     at = length( caption )
      then
     return -- no hotkey symbol
      else
     key = upper(caption[at+1]) -- convert the key to upper case
      end if
   else
      key = caption
   end if
    -- register the key with the parent
    ctrl_Hotkey_Keys[parent] &= key
    ctrl_Hotkey_Ids[parent]  &= id

end procedure

-- ListView wrappers

--/topic ListView Control
--/func struct_LVCOLUMN(atom mask, atom fmt, atom cx, object text, object Column )
--/desc Allocates RAM for a LVCOLUMN structure and initialises it.
--/ret ATOM: Address of a LVCOLUMN structure.
-- /i text can be a 3-element sequence in the form { headingtext, width, alignment }
-- where /i headingtext is the text for the column heading, /i width is the
-- column width in pixels, and /i alignment is a code for Left, Center, or
-- Right aligned text ('~<', '^', '>' respectively). /n
-- In this form, if /i width or /i alignment is -1, it is ignored and the
-- existing settings for the column are not changed. If /i headingtext is
-- "" it is ignored. This means that to blank out a column's heading you
-- must specify a space character as the heading text value.
--
-- /i Column is either ... /n
--/li an integer column number for the new column /n
--/li a two-element sequence {column#, image#}. This form lets you specify
-- the column number and the image list id for the column's image.
--/li a three-element sequence {column#, image#, order}. This form lets you
-- specify the column number, the image list id for the column's image (zero
-- for no image, and the order value.
--
global function struct_LVCOLUMN(atom mask, atom fmt, atom cx,
                                object text, object Column )
    atom LV_COLUMN
    atom lMask, lFmt, lCX
    atom lColImage
    atom lColOrder

    lMask = 0
    lFmt = 0
    lCX = 0

    lColImage = 0
    lColOrder = 0

    if sequence(Column) then
        if length(Column) = 2 then
            lColImage = Column[2]
        elsif length(Column) >= 3 then
            lColImage = Column[2]
            lColOrder = Column[3]
        elsif length(Column) = 0 then
            Column = {1}
        end if
        Column = Column[1]
    end if

    if sequence(text) then

        if length(text) = 3 and sequence(text[1]) then
            if text[2] >= 0 then
                lCX = text[2]
            end if

            if text[3] = '<' or text[3] = LVCFMT_LEFT then
                lMask = or_bits(lMask, LVCF_FMT)
                lFmt = LVCFMT_LEFT
            elsif text[3] = '^' or text[3] = LVCFMT_CENTER  then
                lMask = or_bits(lMask, LVCF_FMT)
                lFmt = LVCFMT_CENTER
            elsif text[3] = '>' or text[3] = LVCFMT_RIGHT  then
                lMask = or_bits(lMask, LVCF_FMT)
                lFmt = LVCFMT_RIGHT
            end if

            text = text[1]
        end if

        if length(text) > 0 then
            lMask = or_bits(lMask, LVCF_TEXT)
        else
            text = 0
        end if
    end if

    LV_COLUMN = w32acquire_mem(0,  SIZEOF_LVCOLUMN )

    lCX += cx
    if lCX > 0 then
        lMask = or_bits(lMask, LVCF_WIDTH)
    end if

    if lColImage > 0 then
        lMask = or_bits(lMask, LVCF_IMAGE)
    end if

    if lColOrder > 0 then
        lMask = or_bits(lMask, LVCF_ORDER)
    end if

    if fmt != 0 then
        lMask = or_bits(lMask, LVCF_FMT)
    end if

    w32store( LV_COLUMN, LVCOLUMN_mask, or_bits(mask,lMask))
    w32store( LV_COLUMN, LVCOLUMN_fmt, or_bits(fmt,lFmt))
    w32store( LV_COLUMN, LVCOLUMN_cx, lCX)
    w32store( LV_COLUMN, LVCOLUMN_pszText, text )
    if sequence(text) then
        w32store( LV_COLUMN, LVCOLUMN_cchTextMax, length( text ))
    end if
    w32store( LV_COLUMN, LVCOLUMN_iSubItem, Column - 1 )
    w32store( LV_COLUMN, LVCOLUMN_iImage,   lColImage -1 )
    w32store( LV_COLUMN, LVCOLUMN_iOrder,   lColOrder - 1 )

    return LV_COLUMN
end function

--/topic ListView Control
--/proc setColumn( integer id, integer column, sequence text )
--/desc Changes the column header text, or width, or alignment.
--See /struct_LVCOLUMN for a description of what format /i text can take.
--
--Example:
--/code
--     -- Set the width of the third column to 230
--     setColumn(myListView, 3, {"",230,-1} )
--/endcode
global procedure setColumn( integer id, integer column, object text )
    atom LV_COLUMN

    LV_COLUMN = struct_LVCOLUMN( 0, 0, 0, text, 0)

    VOID = sendMessage( id, LVM_SETCOLUMN, column - 1 , LV_COLUMN )

    w32release_mem(LV_COLUMN)

end procedure

--/topic ListView Control
--/proc getColumnHeadings( integer id )
--/desc Gets a list of headings for each column in a list view.
--The headings are returned in the same left-to-right order as they are
-- currently displayed. Note because the user can sometimes change the
-- order of the columns, the 'column number' may not always be the same
-- as the order that they appear in.
--
-- The returned sequence contains one entry per heading. Each entry contains
-- two-elements: the first is the true column number and the second is
-- the heading text. The true column number can be used to get the
-- values from the column. See example below ...
--
--Example:
--/code
--      -- Output the columns in the right order
--      lheads = getColumnHeadings(myListView)
--      puts(fh, '\n')
--      for i = 1 to length(lheads) do
--          printf(fh, "%-25s", {lheads[i][2]})
--      end for
--      printf(fh, "\n%s\n", {repeat('-', 75)})
--      for i = 1 to getLVCount(myListView) do
--          for j = 1 to length(lheads) do
--              lData = getLVItemText(myListView, i, lheads[j][1])
--              printf(fh, "%-25s", lData)
--          end for
--          puts(fh, '\n')
--      end for
--/endcode
global function getColumnHeadings( integer id)
    atom LV_COLUMN
    sequence lHeads
    integer column
    atom textbuf
    sequence coldef

    textbuf = w32acquire_mem(0, 4000)
    LV_COLUMN = struct_LVCOLUMN( LVCF_TEXT+LVCF_ORDER+LVCF_SUBITEM, 0, 0, 0, 0)

    poke4(LV_COLUMN+LVCOLUMN_pszText[1], textbuf)
    poke4(LV_COLUMN+LVCOLUMN_cchTextMax[1], 4000)
    lHeads = {}
    column = 1

    VOID = w32True
    while VOID = w32True do
        VOID = sendMessage( id, LVM_GETCOLUMN, column - 1 , LV_COLUMN )
        if VOID then
            coldef = {w32fetch(LV_COLUMN, LVCOLUMN_iOrder),
                      w32fetch(LV_COLUMN, LVCOLUMN_iSubItem)+1,
                      w32peek_string(textbuf)
                      }
            lHeads = append(lHeads, coldef)
            column += 1
        end if
    end while
    lHeads = sort(lHeads)
    for i = 1 to length(lHeads) do
        lHeads[i] = lHeads[i][2..3]
    end for

    w32release_mem(LV_COLUMN)
    w32release_mem(textbuf)

    return lHeads
end function

--/topic ListView Control
--/proc setColumnHeadings( integer id, sequence text )
--/desc Sets the heading text for the columns in a /ListView Control.
--The /i text parameter is a sequence list of column formatting options,
--one per column. Each column formatting option is either a simple text
--heading, or a 3-element sequence: {heading-text, column-width, alignment-code}.
--The alignment code is a single character (integer) and can be one of '~<',
--'^', or '>' meaning left, center, and right alignment respectively. /n
--When calling this routine, sometimes you might need to leave the current
-- setting for heading text, width or alignment alone. To leave the text
-- alone, use an empty string. To leave the width alone, use -1. To leave
-- the alignment alone, use -1.
--
--Example:
--/code
--       -- Set the heading text for each column.
--       setColumnHeadings(myLV, {"Title","Author","Publisher","When"})
--       -- Change the width of the second column
--       setColumnHeadings(myLV, { {}, {"",200,-1} })
--       -- Another way to change the width of the second column
--       setColumn(myLV, 2, { {"",200,-1} })
--/endcode
global procedure setColumnHeadings( integer id, sequence text )
    sequence lHeadings
    integer lTab

    if length(text) > 0 then
        if not sequence(text[1]) then
            lHeadings = {}
            lTab = find('\t', text)
            while lTab != 0 do
                lHeadings = append(lHeadings, text[1..lTab-1])
                text = text[lTab+1..length(text)]
                lTab = find('\t', text)
            end while
            if length(text) > 0 then
                lHeadings = append(lHeadings, text)
            end if
            text = lHeadings
        end if
        for i = 1 to length(text) do
            setColumn(id, i, text[i])
        end for
    end if
end procedure

--/topic ListView Control
--/proc insertLVColumn(id,index,mask,fmt,cx,text, ColumnNumber )
--/desc Inserts a new column into a listview control.
--
global procedure insertLVColumn( atom id, integer index,
                atom mask, atom fmt, atom cx, object text, object pColumn )

    atom LV_COLUMN

    LV_COLUMN = struct_LVCOLUMN( LVCF_SUBITEM, fmt, cx, text, pColumn )

    if sequence(pColumn) then
        pColumn = pColumn[1]
    end if
    VOID = sendMessage( id, LVM_INSERTCOLUMN, pColumn - 1, LV_COLUMN)

    w32release_mem( LV_COLUMN )

end procedure

--/topic ListView Control
--/proc deleteLVColumn(id,index,mask,fmt,cx,text, ColumnNumber )
--/desc Removes a column from a listview control.
--
--Example:
--/code
--      -- Delete the third column
--      deleteLVColumn( myListView, 3 )
--/endcode
global procedure deleteLVColumn( atom id, integer pColumn )
    VOID = sendMessage(id, LVM_DELETECOLUMN, pColumn-1, 0)
end procedure

--/topic ListView Control
--/func struct_LVITEM(mask,item,iSubItem,state,stateMask,text,image,lparam)
--/desc Builds a LVITEM structure in RAM
--/ret ATOM: The address of the structure.
global function struct_LVITEM(atom mask, atom row,
        atom iSubItem, atom state, atom stateMask,
        object text, atom image, atom lparam )

    atom LV_ITEM

    LV_ITEM = w32acquire_mem(0,  SIZEOF_LVITEM )

    w32store( LV_ITEM, LVITEM_mask, mask )
    w32store( LV_ITEM, LVITEM_iItem, row-1)
    w32store( LV_ITEM, LVITEM_iSubItem, iSubItem-1 )
    w32store( LV_ITEM, LVITEM_state, state )
    w32store( LV_ITEM, LVITEM_stateMask, stateMask )

    if sequence( text ) then
        w32store( LV_ITEM, LVITEM_pszText, text )
        w32store( LV_ITEM, LVITEM_cchTextMax, length(text) )
    else
        w32store( LV_ITEM, LVITEM_pszText, text )
    end if

    w32store( LV_ITEM, LVITEM_iImage, image )
    w32store( LV_ITEM, LVITEM_lParam, lparam )

    return LV_ITEM

end function

--/topic ListView Control
--/func insertLVItem(id,mask,row,column,state,stateMask,text,image,lparam)
--/desc Low-Level version of /addLVItem
--/ret SEQUENCE: {index, itemid}
global function insertLVItem(atom id, atom mask, atom row,
        atom iSubItem, atom state, atom stateMask,
        object text, atom image, atom lparam )

    atom LV_ITEM, lIdx

    if not validId(id) or ctrl_Type[id] != ListView then
        return {-1, -1}
    end if

    -- Get next item ID to use
    vNextLVItemID += 1

    -- Check for 'end of list' position
    if row < 0 then
        row = 1 + sendMessage(id, LVM_GETITEMCOUNT, 0, 0)
    end if

    LV_ITEM = struct_LVITEM(mask, row, iSubItem, state, stateMask,
	            text, image, vNextLVItemID)

    lIdx = sendMessage( id, LVM_INSERTITEM, 0, LV_ITEM )

    w32release_mem(LV_ITEM)

    return {lIdx + 1, vNextLVItemID}
end function


--/topic ListView Control
--/proc setLVItem(id, mask, Row, Column, state, stateMask, text, image, lparam)
--/desc Enables you to set a number of the properties of a ListView item in one call.
--<ul>
--/li /i id is the ListView's Id as returned by /createEx()
--/li /i mask determines which what properties are being changed. This is any combination of
-- the values /b"LVIF_TEXT, LVIF_IMAGE, LVIF_PARAM," and /b LVIF_STATE. For each one of these included,
-- the respective parameter /i "text, image, lparam," and /i state is required.
--/li Row is the row number in the list
--/li Column is the column number the parameters affect.
--</ul>
--
--Example:
--/code
--      setLVItem (myListView, w32or_all({LVIF_TEXT, LVIF_IMAGE}), 2,1,
--                    0, 0, "The Great Gatsby", bookImage, 0)
--/endcode
global procedure setLVItem(atom id, atom mask, atom pRow,
        atom pColumn, atom state, atom stateMask,
        object text, atom image, atom lparam )

    atom LV_ITEM

    LV_ITEM = struct_LVITEM(mask, pRow, pColumn, state, stateMask,
	            text, image, lparam)

    VOID = sendMessage( id, LVM_SETITEM, 0, LV_ITEM )
    w32release_mem(LV_ITEM)

end procedure
r_setLVItem = routine_id("setLVItem")

--/topic ListView Control
--/proc setLVItemText(integer LV, integer position, integer subitem, object text)
global procedure setLVItemText( integer LV, integer pRow, integer pColumn, object text )
atom LV_ITEM , ptext

    if not sequence(text) then
        text = sprintf("%g", text)
    end if
    LV_ITEM = struct_LVITEM(LVIF_TEXT, pRow, pColumn, 0, 0, text, 0, 0)

    VOID = sendMessage( LV, LVM_SETITEMTEXT, pRow-1, LV_ITEM )

    w32release_mem(LV_ITEM)

end procedure

--/topic ListView Control
--/proc setImageList( integer id, atom IL, atom size )
global procedure setImageList( integer id, atom IL, atom size )
    atom  message

    IL = getHandle(IL)

    if ctrl_Type[id] = ListView then
        message = LVM_SETIMAGELIST
    else
        message = TVM_SETIMAGELIST
    end if

    VOID = sendMessage( id, message, size, IL )
end procedure

procedure AddIconToImageList( integer pRtn, integer pIL, object pIcon )
    VOID = w32Func( pRtn,  getHandle(pIL) & pIcon)
end procedure

procedure ILAddIcon( atom himl, atom hicon )
    AddIconToImageList ( ImageList_AddIcon , himl, hicon)
end procedure

procedure ILAdd( atom himl, atom hbmImage, atom hbmMask )
    AddIconToImageList ( ImageList_Add, himl , {hbmImage, hbmMask } )
end procedure

procedure ILAddMasked( atom himl, atom hbmImage )
    AddIconToImageList( ImageList_AddMasked, himl, {hbmImage, transColor } )
end procedure

--/topic Image Lists
--/func addIcon( hIcon )
--/desc Adds icons to win32lib's imagelists
--/ret Index to image
-- This function is used to add images for /ListView, /TreeView,
-- /ComboBoxEx and /FlatToolBar controls.  There are two ways to
-- use /addIcon:
-- /li /b hIcon is an icon handle
--      used for /ListView, /TreeView, /ComboBoxEx
-- /li /b hIcon is a sequence of 3 icon handles
--      used for /FlatToolBar
-- The icons passed for the /FlatToolBar should be the images to be used
-- for the default, hot and disabled images, respectively.
--
-- /b "Note:" If /i hIcon is zero, it is ignored and zero is returned.
--
--/Example
--/code
--  object ret, dd
--  dd = dir("c:\\windows\\*.exe")
--  for i = 1 to length(dd) do
--          ret = addIcon(extractIcon("c:\\windows\\" & dd[i][D_NAME]))
--          ret = addLVItem(lv, ret, {dd[i][D_NAME], "xxx"})
--  end for
--/endcode
global function addIcon( object hIcon )
    integer iIcon
    sequence list

    if equal(hIcon, 0) then
        return 0
    end if

    if atom(hIcon) then
        list = ilicon_list
    else
        list = FTB_images
    end if

    iIcon = find(hIcon, list)

    if iIcon then
        return iIcon
    end if

    iIcon = length( list )


    if atom( hIcon ) then

        if ILlarge = 0 then
                ILlarge = call_func(r_createEx, {ImageList, "", 0, 0,0,SM_CXICON,0,
    	            ILC_COLOR8,0})
                ILsmall = call_func(r_createEx, {ImageList, "", 0, 0,0,SM_CXSMICON,0,
    	            ILC_COLOR8,0})
    	end if
        ILAddIcon( ILlarge, hIcon )
        ILAddIcon( ILsmall, hIcon )

        list &= hIcon
        ilicon_list = list

    else
        if himlFTBDefault = 0 then
            -- Need to create imagelists

            himlFTBDefault = call_func(r_createEx, {ImageList, "", 0, 0,0,SM_CXICON,0,
    	        ILC_COLOR8,0})
            himlFTBHot = call_func(r_createEx, {ImageList, "", 0, 0,0,SM_CXICON,0,
    	        ILC_COLOR8,0})
            himlFTBDisabled = call_func(r_createEx, {ImageList, "", 0, 0,0,SM_CXICON,0,
    	        ILC_COLOR8,0})

        end if
        ILAddIcon( himlFTBDefault, hIcon[1] )
        ILAddIcon( himlFTBHot, hIcon[2] )
        ILAddIcon( himlFTBDisabled, hIcon[3] )

        list &= {hIcon}
        FTB_images = list

    end if


    return iIcon + 1
end function

global constant
    w32TB_BUTTONSIZE = 1,
    w32TB_BITMAPSIZE = 2,
    w32TB_HEIGHT = 3

--/Topic Controls
--/proc setToolBarSize(integer id, object Property, object Values)
--/desc Set one or more size properties of a ToolBar or FlatToolBar.
--This is really only needed for Win95 as later versions do this automatically. /n
--/i id is the Id of the tool bar. /n
--/i Property is a list of properties to affect. These can be any combination of
-- /b "w32TB_BUTTONSIZE, w32TB_BITMAPSIZE," and /b w32TB_HEIGHT. /n
--/i Values is a list of the new value(s) to set. /n
-- There must be the same number of values as properties. /n
--/b Note for the button size and bitmap size, the values must be expressed as
-- a 2-element sequence containing {width, height}. For the height value, this
-- must be a single integer. /n
--
-- There is no way to set the width of a toolbar as it always matches it's window's width.
--
--Example:
--/code
--      setToolBarSize( myToolbar, {w32TB_HEIGHT, w32TB_BUTTONSIZE},
--                                 {    38,        {24, 26} })
--/endcode

global procedure setToolBarSize(integer id, object pProperty, object pValues)
    atom lXY
    integer lIdx
    sequence lParentSize

    if atom(pProperty) then
        pProperty = {pProperty}
    end if
    if atom(pValues) then
        pValues = {pValues}
    end if

    if length(pProperty) != length(pValues) then
        return
    end if

    lIdx = find(w32TB_BUTTONSIZE, pProperty)
    if lIdx != 0 and sequence(pValues[lIdx]) and length(pValues[lIdx]) = 2 then

        lXY = w32pack_word( pValues[lIdx][1], pValues[lIdx][2] )
        VOID = sendMessage(id, TB_SETBUTTONSIZE, 0, lXY)
    end if

    lIdx = find(w32TB_BITMAPSIZE, pProperty)
    if lIdx != 0 and sequence(pValues[lIdx]) and length(pValues[lIdx]) = 2 then

        lXY = w32pack_word( pValues[lIdx][1], pValues[lIdx][2] )
        VOID = sendMessage(id, TB_SETBITMAPSIZE, 0, lXY)
    end if


    lIdx = find(w32TB_HEIGHT, pProperty)
    if lIdx != 0 and integer(pValues[lIdx]) then
        lParentSize = call_func(r_getCtlSize,{ctrl_Parent[id]} )

        VOID = w32Func( xMoveWindow,
    	        { getHandle(id), 0, 0, lParentSize[1], pValues[lIdx], 1 } )
    end if

end procedure

--/topic ListView Control
--/func setLVInsert(integer pFlag )
--/desc Sets the default position for ListView inserts.
--/ret The flag setting before this change.
--If /i pFLag is zero, /addLVItem() adds new items to the top of the list,
-- else new items are added at the end. The default is to add items to the
-- top of lists.
--
--Example:
--/code
--     integer lvInsert
--     -- Make listviews add to end of lists.
--     lvInsert = setLVInsert( 1 )
--/endcode
global function setLVInsert(integer pFlag )
    atom lOld

    lOld = lvInsertWhere
    lvInsertWhere = w32iff(pFlag = 0, 1, -1)

    return lOld
end function

--/topic ListView Control
--/func addLVItem( object id, atom iIcon, sequence text )
--/desc Add an item to a /ListView
--/ret The new item's ID.
-- /i id: This is either the id of /ListView or a two-element sequence that
-- specifies the ListView id and the position in the list to insert the new
-- item. /b 1 is the first position, /b 2 is the second position, etc... and
-- /i -1 is the last position. /n
-- /i iIcon: index of image from /addIcon, /addEuBmp, /addXpm, or /addDIB /n
-- /i text: sequence of strings or numbers to be displayed in listview columns. The
-- number of columns is set by the number of strings in this parameter. /n
--
-- Note: Each item placed into a listview is given a unique ID. The ID is unique
-- for the application, not just the ListView the item is in. Also, the ID is
-- not the same as the position of the item in the ListView.
--
--Example:
--/code
--        sequence idx idx = {}
--        setColumnHeadings(myLV, {"Given Name","Family Name","Playing Position", "Number"})
--        idx &= addLVItem(myLV, iconCaptain, {"Brett","Ratten", "Center", 7})
--        idx &= addLVItem(myLV, iconPlayer, {"Scott","Camporeale", "Wing", 16})
--        idx &= addLVItem(myLV, iconPlayer, {"Jim","Plunkett", "Rover", 44})
--        -- Insert an item at position 2.
--        idx &= addLVItem({myLV,2}, iconPlayer, {"Andrew","McKay", "Back Pocket", 5})
--/endcode
global function addLVItem(object id, atom iIcon, sequence text )

    atom iItem
    integer lWhere
    sequence lNewItem


    iIcon -= 1
    if sequence(id) then
        lWhere = id[2]
        id = id[1]
    else
        lWhere = lvInsertWhere
    end if


    -- Sanity check
    if not sequence(text) then
        text = sprintf("%g", text)
    end if
    if length(text) = 0 or not sequence(text[1]) then
        text = {text}
    end if

    lNewItem = insertLVItem( id, lvitem_MASK, lWhere, 1,0,0,
                             text[1], iIcon, 0)

    for i = 2 to length(text) do
        setLVItemText( id, lNewItem[1], i, text[i])
    end for

    return lNewItem[2]
end function

--/topic ListView Control
--/func getLVItem( integer id, atom LV_ITEM)
--/ret ATOM: 0 if routine was successful.
--/desc Gets various attributes of a listview item.
-- /i LV_ITEM is the address of a LVITEM structure that you have to correctly
-- fill out before you call this routine.
--
--Example:
--/code
--     atom lOK
--     atom lvitem
--     lvitem = w32acquire_mem(0, SIZEOF_LVITEM)
--     w32store(lvitem, LVITEM_iItem, 1)
--     w32store(lvitem, LVITEM_mask, LVIF_TEXT)
--     lOK = getLVItem(myLV, lvitem)
--     . . .
--     w32release_mem(lvitem)
--/endcode
global function getLVItem( integer id, atom LV_ITEM)
    return sendMessage( id, LVM_GETITEM, 0, LV_ITEM )
end function

--/topic ListView Control
--/func getLVItemText( integer id, integer item, object column)
--/desc Gets the text associated with a listview item.
--/ret Sequence: The text for an item.
--/i id is the ListView control, /n
--/i row is the list view row in question, /n
--/i column is either the number of the column whose text you want,
-- or -1 if you want the text from all columns, in which case a sequence of
-- strings is returned, or a sequence of column numbers.
--
--Example:
--/code
--       sequence theText
--       -- Get the text from column 1 in row 2.
--       theText = getLVItemText(myLV, 2, 1)
--       -- Get the text from columns 3 and 2 in row 1.
--       theText = getLVItemText(myLV, 1, {3,2} )
--/endcode
global function getLVItemText( integer id, integer row, object column)
    sequence text
    atom lvitem, taddr, lrc
    object taddr_real
    integer lidx
    atom lMemSet

    if not validId(id) or row < 1 then
        return sprintf("Invalid getLVItemText call: ID=%d, ROW=%d", {id, row})
    end if

    if atom(column) then
        if column >= 1 then
            column = {column}
        else
            column = -1
        end if
    elsif sequence(column) and length(column) = 0 then
        column = -1
    end if

    text = {}
    lidx = 1

    lMemSet = w32new_memset()
    lvitem = w32acquire_mem(lMemSet, SIZEOF_LVITEM)
    taddr = w32acquire_mem(lMemSet, 4000)

    w32store(lvitem, LVITEM_iItem, row-1)
    w32store(lvitem, LVITEM_mask, LVIF_TEXT)
    w32store(lvitem, LVITEM_pszText, taddr)
    w32store(lvitem, LVITEM_cchTextMax, 3999)

    while w32True do
        if atom(column) then
            w32store(lvitem, LVITEM_iSubItem, column+lidx)
        else
            w32store(lvitem, LVITEM_iSubItem, column[lidx] - 1)
        end if

        lrc = sendMessage(id, LVM_GETITEM, 0, lvitem)
        if lrc then
            taddr_real = w32fetch(lvitem, LVITEM_pszText)
            if sequence(taddr_real) then
                text = append(text,taddr_real)
            else
                lrc = 0
            end if
        elsif atom(column) then
            text = append(text, "")
        end if

        lidx += 1

        if atom(column) then
            if lrc = 0 then
                exit
            end if
        else
            if lidx > length(column) then
                exit
            end if
        end if
    end while


    if sequence(column) and length(column) = 1 and length(text) > 0 then
        text = text[1]
    end if

    w32release_mem(lMemSet)
    return text
end function
r_getLVItemText = routine_id("getLVItemText")

--/topic ListView Control
--/func getLVAllText( integer id, integer row )
--/desc Gets the text associated with every column in a listview row.
--/ret Sequence: A sequence of text strings.
--/i id is the ListView control, /n
--/i row is the list view row in question, /n
--
--Example:
--/code
--       sequence theText
--       -- Get the text from row 1.
--       theText = getLVAllText(myLV, 1 )
--/endcode
global function getLVAllText( integer id, integer pRow )
    return getLVItemText(id, pRow, -1)
end function

--/topic ListView Control
--/func getLVCount( integer id )
--/desc Gets the number of rows in a list view.
--/ret INTEGER: The count of rows.
--
--Example:
--/code
--      integer cnt
--      cnt = getLVCount(myLV)
--/endcode
global function getLVCount( integer id )
    return sendMessage( id, LVM_GETITEMCOUNT, 0, 0)
end function


--/topic ListView Control
--/func getLVChecked( integer id, integer index )
--/desc Gets whether or not an row has its checkbox ticked.
--/ret INTEGER: w32False if not checked, otherwise w32True.
--
--Example:
--/code
--      integer cnt
--      -- See if row #2 is checked.
--      cnt = getLVChecked(myLV, 2)
--/endcode

global function getLVChecked( integer id, integer row )
    atom lFlags
    lFlags = sendMessage( id, LVM_GETITEMSTATE, row-1, LVIS_STATEIMAGEMASK )
    lFlags = and_bits(lFlags , LV_IS_CHECKED)
    return (lFlags != 0)
end function

--/topic ListView Control
--/func getLVAllChecked( integer id)
--/desc Returns a list of those rows that are Checked.
--/ret SEQUENCE: A list of rows.
--
--Example:
--/code
--      sequence items
--      items = getLVAllChecked(myLV)
--/endcode
global function getLVAllChecked(integer id)
    integer totalCount
    sequence lItems
    atom lFlags
    atom hWnd

    totalCount = getLVCount(id)
    lItems = {}
    hWnd = getHandle(id)
    for i = 0 to totalCount-1 do
        lFlags = w32Func(xSendMessage,{ hWnd, LVM_GETITEMSTATE,
                            i, LVIS_STATEIMAGEMASK })
        lFlags = and_bits(lFlags , LV_IS_CHECKED)
        if lFlags != 0 then
            lItems &= i
        end if
    end for

    return lItems+1
end function

--/topic ListView Control
--/proc setLVChecked( integer id, integer Row, atom checked )
--/desc Sets the checked state for a /ListView Item
-- /i id is the win32lib id for the list view. /n
-- /i Row is the listview item to check/uncheck. /n
-- /i checked is the checked/unchecked state (~<>0=checked,0=unchecked). /n
global procedure setLVChecked( integer id, integer pRow, atom checked )
    atom LV_ITEM, state, mask

    mask = LVIF_STATE
    if checked then
        state = (2 * power(2, 12))
    else
        state = (1 * power(2, 12))
    end if

    LV_ITEM = struct_LVITEM( LVIF_STATE, pRow, 0, state, LVIS_STATEIMAGEMASK, 0, 0, 0 )

    VOID = sendMessage( id, LVM_SETITEM, pRow-1, LV_ITEM )

    w32release_mem(LV_ITEM)
end procedure

--/topic Graphics
--/func extractIcon( sequence Filename )
--/desc Gets the an icon from the file (DLL, EXE or ICO) specified.
--/ret ATOM: Handle to the icon or NULL if none found.
--/i Filename is either ... /n
-- ** the name of a file /n
-- ** a 2-element sequence containing a filename and a 1-based index of which icon to extract.
-- ** a 3-element sequence containing a filename, a 1-based index of which icon to extract,
-- and a code indicating which size icon to return: 0 --> small, 1 --> large,  2 --> both. When
-- you ask to return both, a 2-element sequence is returned that contains {small, large}.
--
--Example:
--/code
--      atom hIcon
--      sequence lIcons
--      -- Get the first icon
--      hIcon = extractIcon( "C:\\WINDOWS\\WINFILE.EXE")
--      -- Get the second icon
--      hIcon = extractIcon( {"C:\\WINDOWS\\WINFILE.EXE", 2} )
--      -- Get the fourth icon, large size
--      hIcon = extractIcon( {"C:\\WINDOWS\\WINFILE.EXE", 4, 1} )
--      -- Get the fifth icon, both sizes
--      lIcons = extractIcon( {"C:\\WINDOWS\\SYSTEM32\SHELL32.DLL", 5, 2} )
--      lBig = lIcons[2]
--      lSmall = lIcons[1]
--/endcode
global function extractIcon( sequence Filename )
    object icon
    integer lIdx
    atom lBufferL
    atom lBufferS
    integer lType

    lIdx = 0
    lType = 0
    if length(Filename) > 0 then
        if sequence(Filename[1]) then
            if length(Filename) >= 3 then
                lType = Filename[3]
            else
                lType = 0
            end if
            lIdx = Filename[2]-1
            Filename = Filename[1]
        end if
    end if
    lBufferL = w32acquire_mem(0, 8)
    lBufferS = lBufferL + 4
    Filename = w32FindFile(Filename)
    VOID = w32Func( xExtractIconEx, {Filename, lIdx, lBufferL, lBufferS, 1} )

    if lType = 0 then
        icon = peek4u(lBufferS)
    elsif lType = 1 then
        icon = peek4u(lBufferL)
    else
        icon = peek4u({lBufferL,2})
    end if

    w32release_mem(lBufferL)
    return icon
end function

--/topic ListView Control
--/func getLVSelectedCount( integer id )
--/desc Gets the number of selected items in a list view.
--/ret INTEGER: The count of selected items.
--
--Example:
--/code
--      integer cnt
--      cnt = getLVSelectedCount(myLV)
--/endcode
global function getLVSelectedCount( integer id )
    return sendMessage(id, LVM_GETSELECTEDCOUNT, 0, 0)
end function

--/topic ListView Control
--/func struct_LVFINDINFO(atom flags, sequence text, atom lparam,atom x, atom y, atom direction)
global function struct_LVFINDINFO(atom flags, sequence text, atom lparam,
	    	      atom x, atom y, atom direction)
    atom LV_FINDINFO

    LV_FINDINFO = w32acquire_mem(0,  SIZEOF_LVFINDINFO )

    w32store( LV_FINDINFO, LVFINDINFO_flags, flags )
    w32store( LV_FINDINFO, LVFINDINFO_psz, text )
    w32store( LV_FINDINFO, LVFINDINFO_lParam, lparam )
    w32store( LV_FINDINFO, LVFINDINFO_ptX, x )
    w32store( LV_FINDINFO, LVFINDINFO_ptY, y )
    w32store( LV_FINDINFO, LVFINDINFO_vkDirection, direction )

    return LV_FINDINFO

end function

--/topic ListView Control
--/func getLVItemlParam( integer id, integer iItem )
--/ret ATOM: The user-defined data associated with this /i iItem.
--/desc Gets the user-defined data for this specific row in the list.
--This data is set by /setLVItemlParam and can be any 32-bit integer.
--
--Example
--/code
--       atom lVal
--       -- Get the data for the second row in the list.
--       lVal = getLVItemlParam(myLV, 2)
--/endcode
global function getLVItemlParam( integer id, integer pRow )
    atom LV_ITEM, lParam

    LV_ITEM = struct_LVITEM( LVIF_PARAM, pRow, 0, 0, 0, 0, 0, 0 )
    VOID = sendMessage( id,  LVM_GETITEM, 0, LV_ITEM )
    lParam = w32fetch( LV_ITEM, LVITEM_lParam )

    w32release_mem( LV_ITEM )
    return lParam
end function

--/topic ListView Control
--/proc setLVItemlParam( integer id, integer iItem )
--/desc Sets the user-defined data for this specific row in the list.
--This data is got by /getLVItemlParam and can be any 32-bit integer.
--
--Example
--/code
--       -- Set the data for the second row in the list.
--       setLVItemlParam(myLV, 2, 17)
--/endcode
global procedure setLVItemlParam( integer id, integer pRow, atom lParam )
    atom LV_ITEM

    LV_ITEM = struct_LVITEM( LVIF_PARAM, pRow, 0, 0, 0, 0, 0, lParam )
    VOID = sendMessage( id,  LVM_SETITEM, 0, LV_ITEM )
    w32release_mem( LV_ITEM )
end procedure

--/topic ListView Control
--/func getLVSelected( object id )
--/desc get a list of the selected items' indexes
--/return SEQUENCE: A List of items.
-- This can return either a simple list of item index values or
-- a list of 2-element sequences where the first element is
-- the index of the selected item and the second elements is
-- the id of the selected item.
--
-- Remember that each item in a list view has a unique item id.
-- The index is the item's current position within the listview.
--
-- To return just a list of item indexes, /i id is the ListView control id. /n
-- To return a list of {index, item id} sequences, then /i id must be
-- a sequence in the form {LVid, style}. /i LVid is the listview's
-- control id and /i style is either /b 1 for the sequence list
-- return value style, or /b 0 for the simple list return value style.
--
--Example:
--/code
--          sequence indexes
--          -- Get a list of selected items' id.
--          idxs = getLVSelected( myListView)
--
--          -- Get a list of selected items AND their indexes.
--          idxs = getLVSelected( {myListView, 1} )
--/endcode
global function getLVSelected( object id )
    integer count, start, check
    sequence selections
    atom LVITEM, LVITEM2, mset, lParam
    integer lReturnStyle

    selections = {}
    lReturnStyle = 0

    if sequence(id) then
        if length(id) = 2 then
            lReturnStyle = w32iff(id[2]=0, 0, 1)
            id = id[1]
        else
            return {}
        end if
    end if

    count = getLVSelectedCount( id )
    if not count then
        return selections
    end if

    mset = w32new_memset()
    LVITEM  = w32acquire_mem(mset, SIZEOF_LVITEM)
    w32store(LVITEM, LVITEM_mask, LVIF_STATE)
    w32store(LVITEM, LVITEM_stateMask, LVIS_SELECTED)

    LVITEM2 = w32acquire_mem(mset, SIZEOF_LVITEM)
    w32store(LVITEM2, LVITEM_mask, LVIF_PARAM)

    start = 0
    while count do
        w32store(LVITEM, LVITEM_iItem, start)
        if sendMessage( id, LVM_GETITEM, 0, LVITEM) then
            if w32fetch(LVITEM, LVITEM_state) then
                if lReturnStyle = 1 then
                    w32store(LVITEM2, LVITEM_iItem, start)
                    VOID = sendMessage( id,  LVM_GETITEM, 0, LVITEM2 )
                    lParam = w32fetch( LVITEM2, LVITEM_lParam )
                    selections &= {{start+1, lParam}}
                else
                    selections &= start+1
                end if
                count -= 1
            end if
        end if
        start += 1
    end while

    w32release_mem(mset)
    return selections
end function

--/topic ListView Control
--/func getLVSelectedText( integer id )
--/desc Gets the column-1 text for each selected item in the listview.
--/ret SEQUENCE: Each element returned is a text sequence.
-- Note that an empty sequence returned means that there is no selected
-- items.
--
--Example:
--/code
--      sequence strings
--      strings = getLVSelectedText(myListView)
--      for i = 1 to length(strings) do
--          puts(1, strings[i] & '\n')
--      end for
--/endcode
global function getLVSelectedText( object id )
    sequence text
    sequence lRowList

    if sequence(id) then
        if sequence(id[2]) then
            lRowList = id[2]
        else
            lRowList = {id[2]}
        end if
        id = id[1]
    else
        lRowList = {1}
    end if

    text = getLVSelected( id )


    for i = 1 to length(text) do
        text[i] = getLVItemText( id, text[i], lRowList)
    end for

    return text

end function




-- TreeView wrappers

global function struct_TVINSERTSTRUCT( atom hParent, atom hInsertAfter,
	    	           atom hItem )
    atom struct
    sequence item

    struct = w32acquire_mem(0,  SIZEOF_TVINSERTSTRUCT )

    w32store( struct, TVINSERTSTRUCT_hParent, hParent )
    w32store( struct, TVINSERTSTRUCT_hInsertAfter, hInsertAfter )

    item = peek( {hItem, SIZEOF_TVITEM} )
    poke( struct + TVINSERTSTRUCTITEM_mask[1], item )

    return struct
end function

global function struct_TVITEM( atom mask, atom hItem, atom state,
	    atom stateMask, object text, atom iImage,
	    atom iSelectedImage, atom cChildren, atom lParam )
    atom struct


    struct = w32acquire_mem(0,  SIZEOF_TVITEM )

    w32store( struct, TVITEM_mask, mask )
    w32store( struct, TVITEM_hItem, hItem )
    w32store( struct, TVITEM_state, state )
    w32store( struct, TVITEM_stateMask, stateMask )

    if sequence(text) then
        w32store( struct, TVITEM_cchTextMax, length( text ) )
    end if
    w32store( struct, TVITEM_pszText, text )
    w32store( struct, TVITEM_iImage, iImage )
    w32store( struct, TVITEM_iSelectedImage, iSelectedImage )
    w32store( struct, TVITEM_cChildren, cChildren )
    w32store( struct, TVITEM_lParam, lParam )

    return struct
end function

global function struct_TVHITTESTINFO( integer x, integer y, integer flags,
        atom hItem )
    atom ht

    ht = w32acquire_mem(0,  SIZEOF_TVHITTESTINFO )

    w32store( ht, TVHITTESTINFO_ptX, x )
    w32store( ht, TVHITTESTINFO_ptY, y )
    w32store( ht, TVHITTESTINFO_flags, flags )
    w32store( ht, TVHITTESTINFO_hItem, hItem )

    return ht
end function


procedure setTVParent( integer iItem, integer cChildren )
    atom TV_ITEM
    integer id

    tvitem_data[iItem][ktv_HasChildren] = cChildren

    if tvitem_owner[iItem] != -1 then
        TV_ITEM = struct_TVITEM( TVIF_CHILDREN, tvitem_handle[iItem],
    	           0,0,0,0,0, cChildren,0)

        VOID = sendMessage(tvitem_owner[iItem], TVM_SETITEM, 0, TV_ITEM )

        w32release_mem( TV_ITEM )
    end if

end procedure

--/topic TreeView Control
--/func getTVParent( id )
--/desc Get the parent id of a /TreeView item.
--/ret id of parent item, or 0 if item is at root, or -1 if /i id is invalid.
-- Note well. /i id is a TreeView ITEM and not the TreeView control.
global function getTVParent( integer id )
    if id > 0 and id <= length(tvitem_data) then
        return tvitem_parent[ id ]
    else
        return -1
    end if
end function

--/topic TreeView Control
--/func addTVItem( integer id, atom iImage, atom iSelectedImage, sequence text, integer iParent )
--/desc Add an item to a /TreeView
--/ret Index to item.
-- /li /b id: /TreeView to add to
-- /li /b iImage: Index to default image
-- /li /b iSelectedImage: Index to image for when item is selected
-- /li /b text: String of text to be displayed for item
-- /li /b iParent: index of parent item.  Should be 0 if item is at root.
-- See /addIcon, /addEuBmp, /addXpm, /addDIB for information on
-- using images with /TreeViews.

global function addTVItem( integer id, atom iImage, atom iSelectedImage,
	    sequence text, integer iParent )

    atom TV_ITEM, TV_INSERTSTRUCT, hNewItem, lParam, hItem, hParent
    atom mset

    -- need to get hParent, since we only have our own id number to
    -- go by.  We can search based on lParam.
    mset = w32new_memset()

    lParam = find(-1, tvitem_owner )
    if not lParam then
        tvitem_data &= {ktv_Blank}
        tvitem_owner &= id
        tvitem_parent &= iParent
        tvitem_handle &= 0
        lParam = length( tvitem_data )
    end if

    if iParent > 0 then
        hParent = tvitem_handle[ iParent ]
    else
        hParent = 0
    end if

    TV_ITEM = struct_TVITEM( tvitem_MASK, 0, 0, 0, LPSTR_TEXTCALLBACK,
	    iImage-1, iSelectedImage-1, 0, lParam )
    w32manage_mem(mset, TV_ITEM)

    TV_INSERTSTRUCT = struct_TVINSERTSTRUCT( hParent, TVI_LAST,
	        TV_ITEM )
    w32manage_mem(mset, TV_INSERTSTRUCT)

    hNewItem = sendMessage( id, TVM_INSERTITEM, 0, TV_INSERTSTRUCT )

    tvitem_data[lParam] = ktv_Blank
    tvitem_data[lParam][ktv_NormImage] = iImage
    tvitem_data[lParam][ktv_SelectImage] = iSelectedImage
    tvitem_data[lParam][ktv_TextAddr] = w32acquire_mem(0, text )
    tvitem_data[lParam][ktv_TextSize] = length(text)
    tvitem_data[lParam][ktv_HasChildren] = w32False

    tvitem_owner[lParam] = id
    tvitem_parent[lParam] = iParent
    tvitem_handle[lParam] = hNewItem


    if (iParent > 0 ) and not tvitem_data[iParent][ktv_HasChildren] then
        setTVParent( iParent, 1 )
    end if

    -- give back the memory to the system.
    w32release_mem(mset)

    return lParam

end function

--/topic TreeView Control
--/func getTVIndex( atom id )
--/desc Find which is the selected item in a treeview.
--/ret 0 if none selected, otherwise the Treeview item id that is selected.
--
--/code
--        integer theItem
--        theItem = getTVIndex(theTreeview)
--        if theItem != 0 then
--           -- found a selected item
--        end if
--/endcode
global function getTVIndex( atom id )
    atom count, state, item, lParam, TV_ITEM

    TV_ITEM = struct_TVITEM( 0, 0,
	        0, TVIS_SELECTED, "", 0, 0, 0, 0)

    count = sendMessage( id, TVM_GETCOUNT, 0, 0 )

    lParam = 0
    item = sendMessage( id, TVM_GETNEXTITEM, 0, TVGN_ROOT )
    w32store( TV_ITEM, TVITEM_hItem, item )
    VOID = sendMessage( id, TVM_GETITEM, 0, TV_ITEM )
    for i = 1 to count do
        state = w32fetch( TV_ITEM, TVITEM_state )

        if and_bits(state, TVIS_SELECTED) then
            lParam = w32fetch( TV_ITEM, TVITEM_lParam)
            exit
        end if

        item = sendMessage( id, TVM_GETNEXTITEM, TVGN_NEXTVISIBLE, item )
        w32store( TV_ITEM, TVITEM_hItem, item )
        VOID = sendMessage( id, TVM_GETITEM, 0, TV_ITEM )
    end for

    w32release_mem( TV_ITEM )

    return lParam

end function

--/topic TreeView Control
--/func getTVText( integer iItem )
--/desc Gets the text associated with a TreeView item.
--/ret SEQUENCE: The item's text.
--
--/code
--       sequence text
--       integer anItem
--       anItem = addTVItem(theTreeView, img1, img2, "Hello", 0)
--       . . .
--       text = getTVText( anItem )
--/endcode
global function getTVText( integer iItem )
    if iItem > 0 and iItem <= length(tvitem_data) then
        return w32peek_string( tvitem_data[iItem][ktv_TextAddr] )
    else
        return ""
    end if

end function

--/topic TreeView Control
--/func getTVSelectedText( integer id )
--/desc Gets the text associated with the selected item in a TreeView.
--/ret SEQUENCE: The selected item's text.
--
--/code
--       sequence text
--       text = getTVSelectedText( theTreeView )
--/endcode
global function getTVSelectedText( integer id )
    return getTVText( getTVIndex( id ) )
end function

--/topic TreeView Control
--/proc setTVText( integer iItem, sequence NewText )
--/desc Sets the text associated with a TreeView item.
--
--/code
--       integer anItem
--       anItem = addTVItem(theTreeView, img1, img2, "Hello", 0)
--       . . .
--        setTVText( anItem, "G'Day" )
--/endcode
global procedure setTVText( integer iItem, sequence pNewText )

    if iItem > 0 and iItem <= length(tvitem_data) then
        w32release_mem(tvitem_data[iItem][ktv_TextAddr])
        tvitem_data[iItem][ktv_TextAddr] = w32acquire_mem(0, pNewText )
        tvitem_data[iItem][ktv_TextSize] = length(pNewText)
    end if

end procedure


--/topic TreeView Control
--/proc setTVImages( integer iItem, atom NewImage, atom NewSelected )
--/desc Sets the images associated with a TreeView item.
-- /i NewImage is the image used for an unselected item, and /i NewSelected
-- is the image used when the item is selected. /n
-- If either /i NewImage or /i NewSelected is -1, the respective image
-- is not changed.
--
--/code
--       integer anItem
--       anItem = addTVItem(theTreeView, img1, img2, "Hello", 0)
--       . . .
--        setTVImages( anItem, img3, -1 )
--/endcode
global procedure setTVImages( integer pItem, atom pNewImage, atom pSelected)
    atom lTVITEM
    atom lMask

    if pItem <= 0 or pItem > length(tvitem_data) then
        return
    end if

    lTVITEM = w32acquire_mem(0, SIZEOF_TVITEM)
    lMask = TVIF_HANDLE
    if pNewImage > 0 then
        lMask = TVIF_IMAGE
        w32store(lTVITEM, TVITEM_iImage, pNewImage-1)
    end if
    if pSelected > 0 then
        lMask = or_bits(lMask, TVIF_SELECTEDIMAGE)
        w32store(lTVITEM, TVITEM_iSelectedImage, pSelected-1)
    end if

    if lMask = TVIF_HANDLE then
        return
    end if

    w32store(lTVITEM, TVITEM_mask, lMask)
    w32store(lTVITEM, TVITEM_hItem, tvitem_handle[pItem])

    VOID = sendMessage(tvitem_owner[pItem], TVM_SETITEM, 0, lTVITEM)

    w32release_mem(lTVITEM)
end procedure

--/topic TreeView Control
--/proc expandItem( id )
--/desc Show the children of a single /TreeView Item
-- /i id is the integer returned from /addTVItem when the item was created.
global procedure expandItem( integer item )
    if item > 0 and item <= length(tvitem_data) then
        VOID = sendMessage( tvitem_owner[item],
                                TVM_EXPAND, TVE_EXPAND, tvitem_handle[item] )
    end if
end procedure

--/topic TreeView Control
--/proc collapseItem( id )
--/desc Hides the children of a single /TreeView Item
-- /i id is the integer returned from /addTVItem when the item was created.
global procedure collapseItem( integer item )
    if item > 0 and item <= length(tvitem_data) then
        VOID = sendMessage( tvitem_owner[item],
                                TVM_EXPAND, TVE_COLLAPSE, tvitem_handle[item] )
    end if
end procedure

--/topic TreeView Control
--/proc toggleItem( id )
--/desc Shows or Hides the children of a single /TreeView Item
-- /i id is the integer returned from /addTVItem when the item was created. /n
-- If the item has its children hidden, this shows them. /n
-- If the item has its children shown, this hides them. /n
global procedure toggleItem( integer item )
    if item > 0 and item <= length(tvitem_data) then
        VOID = sendMessage( tvitem_owner[item],
                                TVM_EXPAND, TVE_TOGGLE, tvitem_handle[item] )
    end if
end procedure

-----------------------------------------------------------------------------
--/topic Attributes
--/proc defineUserProperty( object pControl, object pPropId, object pData)
--/desc Defines a user defined property for this control /i id.
--/i pControl specifies either a single control id or a list of control ids /n
--/i pPropId specifies a unique 'name' for the property. /n
--/i pData is the data used to initialize the property. This value is also used
-- by /resetUserProperty.
--
--This is used to create a property or attribute of a control that is not
-- standard. You  can use this property however you like. The most common
-- usage is to store information for specific controls that are not
-- normally tracked.
--
--Example:
--/code
--      -- Create a property called 'OrigValue' for three controls.
--      defineUserProperty({fldName, fldAddr, fldPhone},
--                          "OrigValue", "")
--/endcode
global procedure defineUserProperty( object pControl, object pPropId, object pData)
    integer lPropIdx
    if sequence(pControl) then
        for i = 1 to length(pControl) do
            defineUserProperty(pControl[i], pPropId, pData)
        end for
        return
    end if

    if not validId(pControl) then
        return
    end if

    -- See if this has already been defined for the control.
    if integer(pPropId) then

        lPropIdx = pPropId
        if lPropIdx > length(ctrl_IntData[pControl][tagPropData]) then
            ctrl_IntData[pControl][tagPropInit] = append(ctrl_IntData[pControl][tagPropInit],
                                            repeat(lPropIdx - length(ctrl_IntData[pControl][tagPropInit]), 0))
            ctrl_IntData[pControl][tagPropData] = append(ctrl_IntData[pControl][tagPropData],
                                            repeat(lPropIdx - length(ctrl_IntData[pControl][tagPropData]), 0))
            ctrl_IntData[pControl][tagPropInit][lPropIdx] = pData
        end if
        ctrl_IntData[pControl][tagPropData][lPropIdx] = pData

    else
        lPropIdx = find(pPropId, ctrl_UserData[pControl][tagPropId])

        -- If not, then add it a new property.
        if lPropIdx = 0 then
            ctrl_UserData[pControl][tagPropId] = append(ctrl_UserData[pControl][tagPropId], pPropId)
            ctrl_UserData[pControl][tagPropInit] = append(ctrl_UserData[pControl][tagPropInit], pData)
            ctrl_UserData[pControl][tagPropData] = append(ctrl_UserData[pControl][tagPropData], pData)
        else
            -- else change the property's initial data value.
            ctrl_UserData[pControl][tagPropInit][lPropIdx] = pData
        end if

    end if
end procedure
r_defineUserProperty = routine_id("defineUserProperty")

-----------------------------------------------------------------------------
--/topic Attributes
--/proc setUserProperty( object id, object PropId, object Data)
--/desc Stores data into a user defined property for this control /i id.
--/i pControl specifies either a single control id or a list of control ids /n
--/i PropId specifies a property defined by an early call to /defineUserProperty /n
--/i Data is any data you wish to store in that property. /n
--
--/b Note: If the property named in /i PropId hasn't been defined yet for
-- /i id, this routine will automatically define it, using /i Data as the
-- default value for it.
--
--Example:
--/code
--      -- Set the original values for these fields.
--      setUserProperty(fldName, "OrigValue", lRecord[cName])
--      setUserProperty(fldAddr, "OrigValue", lRecord[cAddr])
--      setUserProperty(fldPhone, "OrigValue", lRecord[cPhone])
--/endcode
global procedure setUserProperty( object pControl, object pPropId, object pData)
    integer lPropIdx

    if sequence(pControl) then
        for i = 1 to length(pControl) do
            setUserProperty(pControl[i], pPropId, pData)
        end for
        return
    end if

    if not validId(pControl) then
        return
    end if

    -- See if this has already been defined for the control.
    if integer(pPropId) then

        if pPropId > length(ctrl_IntData[pControl][tagPropInit]) then
            defineUserProperty(pControl, pPropId, pData)
        else
            ctrl_IntData[pControl][tagPropData][pPropId] = pData
        end if
    else
        lPropIdx = find(pPropId, ctrl_UserData[pControl][tagPropId])

        -- If yes, set the new value
        if lPropIdx = 0 then
            defineUserProperty(pControl, pPropId, pData)
        else
            ctrl_UserData[pControl][tagPropData][lPropIdx] = pData
        end if
    end if

end procedure
r_setUserProperty = routine_id("setUserProperty")

-----------------------------------------------------------------------------
--/topic Attributes
--/proc resetUserProperty( object pControl, object pPropId)
--/desc Initializes a user defined property for this control /i id.
--/i pControl specifies either a single control id or a list of control ids /n
--/i pPropId specifies a property defined by an early call to /defineUserProperty.
-- The property is reset to the initial value originally supplied
-- when defined with /defineUserProperty.
--
--Example:
--/code
--      -- Set the original values back to their initial value.
--      resetUserProperty({fldName,fldAddr, fldPhone}, "OrigValue")
--/endcode
global procedure resetUserProperty( object pControl, object pPropId)
    integer lPropIdx

    if sequence(pControl) then
        for i = 1 to length(pControl) do
            resetUserProperty(pControl[i], pPropId)
        end for
        return
    end if

    if not validId(pControl) then
        return
    end if

    -- See if this has already been defined for the control.
    if integer(pPropId) then

        if pPropId <= length(ctrl_IntData[pControl][tagPropData]) then
            ctrl_IntData[pControl][tagPropData][pPropId] =
                ctrl_IntData[pControl][tagPropInit][pPropId]
        end if
    else
        lPropIdx = find(pPropId, ctrl_UserData[pControl][tagPropId])

        -- If yes, set the value to the initialisation value
        if lPropIdx != 0 then
            ctrl_UserData[pControl][tagPropData][lPropIdx] =
                ctrl_UserData[pControl][tagPropInit][lPropIdx]
        end if
    end if
end procedure


-----------------------------------------------------------------------------
--/topic Attributes
--/func getUserProperty( object pControl, object pPropId)
--/desc Retrieves data from a user defined property for this control /i id.
--ret Sequence: The contents of the user defined property.
-- /i pControl specifies the id of the control. This can be either a
-- single id, or a list of ids in a sequence. /n
-- /i pPropId specifies a
-- property defined by an early call to /defineUserProperty. /n
-- The data isreturned as the first, and only, element in a sequence.
-- If an empty sequence is returned, it means that the specified
-- property has not been defined for this control. /n
-- If /i id is a sequence, then the returned sequence contains two
-- subsequences. The first is alist of the returned property values and
-- the second is a list of w32True/w32False values; one per control listed
-- in /id. A w32True indicates that the respective control has this property
-- set and w32False indicates that it has not been set.
--
--Examples:
--
--/code
--      sequence lValues
--      lValues = getUserProperty(fldX, "Animation")
--      if length(lValues) = 0 then
--          -- No value, so use a default.
--          lValues = {20}
--      end if
--      -- NB: The property value is always in element [1]!
--      doAnimation( lValues[1] )
--/endcode
--
-- This next example shows how to get the property values from a list of controls
--/code
--      sequence lValues
--      sequence lFlds
--
--      lFlds = {fldA, fldB, fldC}
--      lValues = getUserProperty( lFlds, "TimeOut")
--      for i = 1 to length(lValues) do
--          if lValues[2][i] = w32False then
--              -- Provide a default value then.
--              lValues[1][i] = 5
--          end if
--          -- Process the property value which is in lValues[1][i]
--          doSomethingClever( lFlds[i], lValues[1][i])
--      end for
--/endcode
global function getUserProperty( object pControl, object pPropId)
    sequence lData
    integer lPropIdx
    integer lMultiple

    lData = {{},{}}
    if atom(pControl) then
        pControl = {pControl}
        lMultiple = w32False
    else
        lMultiple = w32True
    end if

    for i = 1 to length(pControl) do
        if validId(pControl[i]) then

            -- See if this has already been defined for the control.
            if integer(pPropId) then

                if pPropId <= length(ctrl_IntData[pControl[i]][tagPropData]) then
                    lData[1] = append(lData[1], ctrl_IntData[pControl[i]][tagPropData][pPropId])
                    lData[2] &= w32True
                else
                    lData[1] &= w32False
                    lData[2] &= w32False
                end if
            else
                lPropIdx = find(pPropId, ctrl_UserData[pControl[i]][tagPropId])

                -- If yes, return the value
                if lPropIdx != 0 then
                    lData[1] = append(lData[1], ctrl_UserData[pControl[i]][tagPropData][lPropIdx])
                    lData[2] &= w32True
                else
                    lData[1] &= w32False
                    lData[2] &= w32False
                end if
            end if
        end if
    end for

    if lMultiple = w32False then
        if length(lData[2]) > 0 and lData[2][1] = w32True then
            lData = lData[1]
        else
            lData = {}
        end if
    end if
    return lData
end function
r_getUserProperty = routine_id("getUserProperty")

--/topic Attributes
--/proc deleteUserProperty( object pControl, object pPropId)
--/desc Deletes a user defined property for this control /i id.
-- /i pControl specifies the id of the control. This can be either a
-- single id, or a list of ids in a sequence. /n
-- /i pPropId specifies a
-- property defined by an early call to /defineUserProperty. /n
--
--Examples:
--
--/code
--      deleteUserProperty(fldX, "Animation")
--      deleteUserProperty( {fldA, fldB, fldC}, "TimeOut")
--/endcode

global procedure deleteUserProperty( object pControl, object pPropId)
    integer lIdx

    if atom(pControl) then
        pControl = {pControl}
    end if

    for i = 1 to length(pControl) do
        if not integer(pPropId) then
            lIdx = find(pPropId, ctrl_UserData[pControl[i]][tagPropId])
            if lIdx != 0 then
                ctrl_UserData[pControl[i]][tagPropId] = w32removeIndex(lIdx, ctrl_UserData[pControl[i]][tagPropId])
                ctrl_UserData[pControl[i]][tagPropData] = w32removeIndex(lIdx, ctrl_UserData[pControl[i]][tagPropData])
            end if
        end if
    end for

end procedure
r_deleteUserProperty = routine_id("deleteUserProperty")

--/topic Controls
--/proc closeWindow( window )
--/desc Close /i window.
-- If /i window is not a main window, /i window will be hidden
-- and the /onClose event will be triggered.
--
-- If /i window is the /b "main window" (see /WinMain) or zero, then the
-- application will be shut down and the /onClose event will
--
-- If /i window is not a valid id, then no action is taken.
--
-- Example:
--
--/code
--          -- close TheDialog
--          /closeWindow( TheDialog )
--/endcode

global procedure closeWindow( integer id )
    if id = 0 then
        id = mainWindow
    end if
    if validId(id) then
        -- close the window
        VOID = sendMessage( id, WM_CLOSE, 0, 0 )
    end if

end procedure
r_closeWindow = routine_id("closeWindow")

global procedure autoclose(integer self, integer event, sequence parms)

    closeWindow(findParentWindow(self))
end procedure
r_autoclose = routine_id("autoclose")

integer vEmptySlots
vEmptySlots = 16

--/topic Controls
--/proc setControlBlocks(integer pQty)
--/desc Sets the number of new memory areas created for new controls
--Whenever a new control is created, it requires some memory to be allocated
--to manage it, and because this can be a performance hit win32lib has the
-- ability to created multiple new control blocks in one operation. This
-- means that when a new control is being created, and there is no available
-- control blocks, it will create /i pQty control blocks so that the next
-- new control doesn't have to allocate memory. Initially win32lib will
-- allocate 16 new control memory blocks. /n
-- /b Note: /i pQty must be 1 or more, otherwise 16 will be used.
--
--Example
--/code
--          -- lots of Controls will be created in this app
--          -- so allocate all the control blocks in one go.
--          setControlBlocks(147)
--          -- The first new create() will actually allocate the memory.
--          constant myWin = /create(Window, ...)
--/endcode

---------------------------------------------------------
global procedure setControlBlocks(integer pQty)
---------------------------------------------------------
    if pQty >= 1 then
        vEmptySlots = pQty
    else
        vEmptySlots = 16
    end if
end procedure


--/topic MouseTraps
--/info
--Defined sub-regions of a window that can generate /w32HMouseTrap events.
--These are used to make it easy to detect mouse activity in specific
-- sub-regions of a window or other control.


--/topic MouseTraps
--/func createMouseTrap(integer pWindow, object pRect)
--/desc Defines a mousetrap area
--/ret INTEGER: A mousetrap ID.
--This defines an subregion of /i pWindow, bounded by /i pRect that can generate
-- /w32HMouseTrap events. /n
--/i pWindow is a top-level Window control. It must not have any parent. /n
--/i pRect is either a four-element sequence in the form /n
-- {left, top, right, bottom} relative to /i pWindow, or the id of a
-- child control of /i pWindow. In the second case, the mousetrap covers the entire
-- area of the child control.
--
--Example:
--/code
--      integer mt
--      mt1 = createMouseTrap(myWin, {10,10,30,30})
--      mt2 = createMouseTrap(myWin, myBitMap)
--/endcode

---------------------------------------------------------
global function createMouseTrap(integer pWindow, object pRect)
---------------------------------------------------------
    integer lNewMouseTrap
    integer lRelId

    if atom(ctrl_Mousetrap[pWindow]) then
        ctrl_Mousetrap[pWindow] = repeat(-1, 10)
    end if

    lNewMouseTrap = find(-1, ctrl_Mousetrap[pWindow])
    if lNewMouseTrap = 0 then
        lNewMouseTrap = length(ctrl_Mousetrap[pWindow]) + 1
        ctrl_Mousetrap[pWindow] &= repeat(-1, 10)
    end if

    if atom(pRect) then
        lRelId = pRect
        pRect = call_func(r_getRect,{lRelId})
        pRect = pRect[1..4]
        if findParent(lRelId) != pWindow then
            -- Convert coordinates so they are relative to window.
            pRect[3..4] -= pRect[1..2]
            pRect[1..2] = clientToClient(lRelId, pWindow, pRect[1..2])
            pRect[3..4] = clientToClient(lRelId, pWindow, pRect[3..4])
        end if
    end if
    ctrl_Mousetrap[pWindow][lNewMouseTrap] = 0 & pRect & w32True & 0 & {{WM_LBUTTONDOWN}}

    return lNewMouseTrap
end function


--/topic MouseTraps
--/proc updateMouseTrap(integer pWindow, integer pMouseTrap, object pRect)
--/desc This changes the bounding rectangle for a mousetrap.
--/i pWindow is the window that owns the mousetrap. /n
--/i pMouseTrap is the id of the mouse trap to update. /n
--/i pRect is either a four-element sequence in the form /n
-- {left, top, right, bottom} relative to the /i pWindow control, or the id of a
-- child control of /i pWindow. In the second case, the mousetrap covers the entire
-- area of the child control. /n
--
--/b Note that if the specified mousetrap does not exist, it will be created
-- automatically.
--
--Example:
--/code
--      updateMouseTrap(myWin, 2, {20,17,156, 281})
--      updateMouseTrap(myWin, 1, myBitMap)
--/endcode
---------------------------------------------------------
global procedure updateMouseTrap(integer pWindow, integer pMouseTrap, object pRect)
---------------------------------------------------------
    if atom(ctrl_Mousetrap[pWindow]) then
        ctrl_Mousetrap[pWindow] = repeat(-1, 10)
    end if
    if pMouseTrap > length(ctrl_Mousetrap[pWindow]) then
        ctrl_Mousetrap[pWindow] = repeat(-1, pMouseTrap - length(ctrl_Mousetrap[pWindow]))
    end if

    if atom(pRect) then
        pRect = call_func(r_getRect,{pRect})
        pRect = pRect[1..4]
    end if
    if atom(ctrl_Mousetrap[pWindow][pMouseTrap]) then
        ctrl_Mousetrap[pWindow][pMouseTrap] = 0 & pRect & w32True & 0 & {{WM_LBUTTONDOWN}}
    else
        ctrl_Mousetrap[pWindow][pMouseTrap][2..5] = pRect
    end if
end procedure

--/topic MouseTraps
--/proc deleteMouseTrap(integer pWindow, integer pMouseTrap)
--/desc This removes the specified mousetrap area from the window.
--/i pWindow is the window that owns the mousetrap. /n
--/i pMouseTrap is the id of the mouse trap to remove. /n
--
--/b Note that if /i pMouseTrap is less than one, all mousetraps
-- for the window will be deleted.
--
--Example:
--/code
--      -- Remove mousetrap #3
--      deleteMouseTrap(MyWindow, 3)
--      -- Remove all mousetraps from the window.
--      deleteMouseTrap(DiagWin, -1)
--/endcode
---------------------------------------------------------
global procedure deleteMouseTrap(integer pWindow, integer pMouseTrap)
---------------------------------------------------------
    if pMouseTrap > 0 then
        ctrl_Mousetrap[pWindow][pMouseTrap] = -1
    else
        -- Remove all mousetraps.
        ctrl_Mousetrap[pWindow] = -1
    end if
end procedure

--/topic MouseTraps
--/proc enableMouseTrap(integer pWindow, object pMouseTrap, integer pState)
--/desc This alters the 'enabled' state of the specified mousetrap area in the window.
--/i pWindow is the window that owns the mousetrap. /n
--/i pMouseTrap is the id of the mouse trap to enable. /n
--/i pState is either w32True or w32False. A setting of w32False will prevent this mousetrap
-- from generating events.
--
--/b Note that /i pMouseTrap can also be a list of mousetrap Ids.
--
--Example:
--/code
--      -- Disable mousetrap #1
--      enableMouseTrap(myWin, 1, w32False)
--      -- Enable mousetraps #2, 8, 5, and 4.
--      enableMouseTrap(myWin, {2,8,5,4}, w32True)
--/endcode
---------------------------------------------------------
global procedure enableMouseTrap(integer pWindow, object pMouseTrap, integer pState)
---------------------------------------------------------
    if atom(pMouseTrap) then
        pMouseTrap = {pMouseTrap}
    end if
    for i = 1 to length(pMouseTrap) do
        ctrl_Mousetrap[pWindow][pMouseTrap[i]][6] = pState
    end for
end procedure

--/topic MouseTraps
--/proc filterMouseTrap(integer pWindow, object pMouseTrap, object pEvents)
--/desc This alters the 'filters' of the specified mousetrap area in the window.
--/i pWindow is the window that owns the mousetrap. /n
--/i pMouseTrap is the id of the mouse trap to filter. /n
--/i pEvents is a list of Windows mouse event codes. These are the only mouse events
-- that can cause this mousetrap area to react.
--
--/b Note that /i pMouseTrap can also be a list of mousetrap Ids.
--
--Example:
--/code
--      -- Check for Wheel movement
--      filterMouseTrap(myWin, 1, WM_WHEELMOUSE)
--      -- Check for Right Button events
--      filterMouseTrap(myWin, {2,8,5,4}, {WM_RBUTTONDOWN, WM_RBUTTONUP})
--/endcode
---------------------------------------------------------
global procedure filterMouseTrap(integer pWindow, object pMouseTrap, object pEvents)
---------------------------------------------------------
    if atom(pEvents) then
        pEvents = {pEvents}
    end if
    if atom(pMouseTrap) then
        pMouseTrap = {pMouseTrap}
    end if
    for i = 1 to length(pMouseTrap) do
        ctrl_Mousetrap[pWindow][pMouseTrap[i]][8] = pEvents
    end for
end procedure

--/topic MouseTraps
--/proc zorderMouseTrap(integer pWindow, object pMouseTrap, integer pOrder)
--/desc This alters the 'depth' of the specified mousetrap area in the window.
--/i pWindow is the window that owns the mousetrap. /n
--/i pMouseTrap is the id of the mouse trap to order. /n
--/i pOrder the absolute depth value. The higher the number, the further in the
-- background the mousetrap area is. Initially a mousetrap is created with a depth value
-- of zero. Negative numbers move the mousetrap closer to the foreground.
--
-- Use this if you have mousetrap areas that can overlap. When the w32HMouseTrap
-- event fires, you get a list of mousetrap areas sorted from closest (in foreground)
-- to furtherest (in background).
--
--Example:
--/code
--      -- move area #1 close to the front.
--      zorderMouseTrap(MyWindow, 1, -10)
--
--      -- Order things so that the man is in front of the
--      -- bush and the bush is in front of the wall.
--      zorderMouseTrap(MyWindow, Wall, 3)
--      zorderMouseTrap(MyWindow, Bush, 2)
--      zorderMouseTrap(MyWindow, Man, 1)
--
--/endcode
---------------------------------------------------------
global procedure zorderMouseTrap(integer pWindow, integer pMouseTrap, integer pOrder)
---------------------------------------------------------
    ctrl_Mousetrap[pWindow][pMouseTrap][1] = pOrder
end procedure

--/topic MouseTraps
--/proc setTagMouseTrap(integer pWindow, object pMouseTrap, object pData)
--/desc This alters the 'user data' of the specified mousetrap area in the window.
--/i pWindow is the window that owns the mousetrap. /n
--/i pMouseTrap is the id of the mouse trap to hold the data. /n
--/i pData is any data you wish to store with this mousetrap.
--
-- Win32lib never uses this data. It is a convenience for the coder to
-- save data specific for the user-defined mousetrap event processing.
--
-- You can use /getTagMouseTrap() to retrieve this data.
--
--Example:
--/code
--      -- Save a routine id to handle things.
--      setTagMouseTrap(MyWindow, 1, routine_id("MT1_Catch"))
--
--      -- Save some color data
--      setTagMouseTrap(MyWindow, 2, {Red, Cyan, BrightGreen})
--
--/endcode
---------------------------------------------------------
global procedure setTagMouseTrap(integer pWindow, integer pMouseTrap, object pData)
---------------------------------------------------------
    ctrl_Mousetrap[pWindow][pMouseTrap][7] = pData
end procedure

--/topic MouseTraps
--/func getTagMouseTrap(integer pWindow, object pMouseTrap)
--/desc This fetches the data stored by /setTagMouseTrap()
--/ret OBJECT: Whatever the user data has been set for the mousetrap.
--/i pWindow is the window that owns the mousetrap. /n
--/i pMouseTrap is the id of the mouse trap that holds the data. /n
--
-- You must use /setTagMouseTrap() to store this data.
--
--Example:
--/code
--      -- Save a routine id to handle things.
--      setTagMouseTrap(MyWindow, 1, routine_id("MT1_Catch"))
--      . . .
--      -- Fetch the routine id to use.
--      rtnid = getTagMouseTrap(MyWindow, 1)
--      call_proc(rtnid, . . .)
--
--/endcode
---------------------------------------------------------
global function getTagMouseTrap(integer pWindow, integer pMouseTrap)
---------------------------------------------------------
    return ctrl_Mousetrap[pWindow][pMouseTrap][7]
end function

--/topic MouseTraps
--/func getMouseTrap(integer pWindow, object pMouseTrap)
--/desc This fetches all the information about the specified mousetrap.
--/ret OBJECT: -1 if /i pMouseTrap is not valid, otherwise a MouseTrap sequence.
--/i pWindow is the window that owns the mousetrap. /n
--/i pMouseTrap is the id of the mouse trap. /n
--
-- Each mousetrap is a sequence of 8 elements: /n
--/li integer: /b zorder, the higher numbers are further in the background. The
-- initial value is zero when a mousetrap is created.
--/li integer: /b left, the leftmost position of the mousetrap area
--/li integer: /b top, the topmost position of the mousetrap area
--/li integer: /b right, the rightmost position of the mousetrap area
--/li integer: /b bottom, the bottommost position of the mousetrap area
--/li integer: /b enableFlag, either w32True if enabled else w32False.
--/li object: /b userdata, the data set by calling /setTagMouseTrap(). This is
--never used by win32lib and is intended for use by the user for anything.
--/li sequence: /b filters, a list of zero or more mouse event codes that are used
--to filter in this mousetrap. Initially this set to {WM_LBUTTONDOWN} when
--then mousetrap is created. It can be changed by calling /filterMouseTrap().
--
--Example:
--/code
--      -- Fetch the mousetrap info.
--      object MT
--      MT = getMouseTrap(MyWindow, 1)
--      if atom(MT) then
--          -- the mousetrap doesn't exist.
--      else
--          -- process it...
--      end if
--/endcode
---------------------------------------------------------
global function getMouseTrap(integer pWindow, integer pMouseTrap)
---------------------------------------------------------
    if atom(ctrl_Mousetrap[pWindow]) or (pMouseTrap > length(ctrl_Mousetrap[pWindow])) or pMouseTrap < 1 then
        return -1
    end if
    return ctrl_Mousetrap[pWindow][pMouseTrap]
end function

--/topic MouseTraps
--/func hitMouseTrap(integer pWindow, integer pEvent, integer pX, integer pY)
--/desc This returns all mousetraps for the window that are under the /i pX and /i pY position.
--/ret SEQUENCE: A list of zero or more mousetraps.
--/i pWindow is the window that owns the mousetrap. /n
--/i pEvent used to filter. Only mousetraps looking for this event can be returned./n
--/i pX, /i pY are  coordinates. Only mousetraps that are under this position can be returned.
--
--/b Note that disabled mousetraps are ignored.
--
-- The returned list is sorted from closest to furtherest away, based on the z-order settings
-- of the mousetraps. These are set by calling /zorderMouseTrap().
--
--The format of each element in the returned list is :
--/li integer: /b zorder
--/li integer: /b left
--/li integer: /b top
--/li integer: /b right
--/li integer: /b bottom
--/li integer: /b "mousetrap id"
--/li object: /b userdata
--/li sequence: /b filters
--
--Example:
--/code
--      sequence MTList
--      -- Get all the mousetraps that are under (100,100) that are looking for
--      -- left button down events.
--      MTList = hitMouseTrap(myWindow, WM_LBUTTONDOWN, 100, 100)
--
--/endcode
---------------------------------------------------------
global function hitMouseTrap(integer pWindow, integer pEvent, integer pX, integer pY)
---------------------------------------------------------
    sequence lMouseTraps
    sequence lR

    if atom(ctrl_Mousetrap[pWindow]) then
        return {}
    end if

    lMouseTraps = {}
    lR = {}
    for i = 1 to length(ctrl_Mousetrap[pWindow]) do
        if sequence(ctrl_Mousetrap[pWindow][i]) then
            lR = ctrl_Mousetrap[pWindow][i]
            if lR[6] = w32True and find(pEvent, lR[8]) and
               lR[2] <= pX and lR[3] <= pY and
               lR[4] > pX and lR[5] > pY then
                lR[6] = i
                lMouseTraps = append(lMouseTraps, lR)
            end if
        end if
    end for

    if length(lMouseTraps) > 0 then
        lMouseTraps = sort(lMouseTraps)
    end if
    return lMouseTraps
end function

---------------------------------------------------------
function NewControl(integer pType, integer pOwner)
---------------------------------------------------------
    -- Allocates an ID and management areas for a new control.
    integer id
    sequence lEmptySlots

    -- look for an available slot

    id = ctlblk_freelist[1]
    if id = 0 then
        for i = length(ctrl_Destroyed) to vPrevCtlBlkLength by -1 do
            if ctrl_Destroyed[i] = -1 then
                id = i
                exit
            end if
        end for
    else
        ctlblk_freelist = ctlblk_freelist[2..length(ctlblk_freelist)]
    end if

    --id = find(-1, ctrl_Destroyed)
    if id = 0 then   -- create slots for attributes
        vPrevCtlBlkLength = length(ctrl_Destroyed) + 1
        lEmptySlots         = repeat(-1, vEmptySlots)
        ctrl_Destroyed    &= lEmptySlots
        ctrl_Handle       &= lEmptySlots
        ctrl_Handle_type  &= lEmptySlots
        ctrl_Function         &= lEmptySlots
        ctrl_Family       &= lEmptySlots
        ctrl_Type         &= lEmptySlots
        ctrl_Focus_order  &= lEmptySlots
        ctrl_Current_focus        &= lEmptySlots
        ctrl_Previous_focus   &= lEmptySlots
        ctrl_Parent        &= lEmptySlots
        ctrl_X_Pos            &= lEmptySlots
        ctrl_Y_Pos            &= lEmptySlots
        ctrl_Erase        &= lEmptySlots
        ctrl_Font         &= lEmptySlots
        ctrl_Pen          &= lEmptySlots
        ctrl_Fg_Color       &= lEmptySlots
        ctrl_Bg_Color       &= lEmptySlots
        ctrl_Scroll       &= lEmptySlots
        ctrl_Range        &= lEmptySlots
        ctrl_Tabitems     &= lEmptySlots
        ctrl_Group        &= lEmptySlots
        ctrl_Cursor       &= lEmptySlots
        ctrl_Menu         &= lEmptySlots
        ctrl_Popup        &= lEmptySlots
        ctrl_Notify_List     &= lEmptySlots
        ctrl_Toolbar      &= lEmptySlots
        ctrl_Statusbar    &= lEmptySlots
        ctrl_Hint_Text      &= lEmptySlots
        ctrl_Hint_Width   &= lEmptySlots
        ctrl_Hotkey_Keys  &= lEmptySlots
        ctrl_Hotkey_Ids   &= lEmptySlots
        ctrl_Text_Alignment    &= lEmptySlots
        ctrl_Closed       &= lEmptySlots
        ctrl_TabKey_Used   &= lEmptySlots
        ctrl_Handlers &= lEmptySlots
        ctrl_Bg_Brush       &= lEmptySlots
        ctrl_UserData          &= lEmptySlots
        ctrl_IntData         &= lEmptySlots
        ctrl_Name         &= lEmptySlots
        ctrl_Deferred_Handlers &= lEmptySlots
        ctrl_Auto_Height   &= lEmptySlots
        ctrl_Auto_Width    &= lEmptySlots
        ctrl_Init_Posns         &= lEmptySlots
        ctrl_ClassAddr        &= lEmptySlots
        ctrl_Mousetrap       &= lEmptySlots


        -- create event handlers
        onMouse             &= lEmptySlots
        onClick             &= lEmptySlots
        onKeyPress          &= lEmptySlots
        onKeyUp             &= lEmptySlots
        onKeyDown           &= lEmptySlots
        onResize            &= lEmptySlots
        onChange            &= lEmptySlots
        onGotFocus          &= lEmptySlots
        onLostFocus         &= lEmptySlots
        onOpen              &= lEmptySlots
        onActivate          &= lEmptySlots
        onClose             &= lEmptySlots
        onDestroy           &= lEmptySlots
        onScroll            &= lEmptySlots
        onTimer             &= lEmptySlots
        onPaint             &= lEmptySlots
        onDragAndDrop       &= lEmptySlots
        onEvent             &= lEmptySlots

        id = length(ctrl_Destroyed) - vEmptySlots + 1
    end if

    -- initialize to defaults
    ctrl_Destroyed[id]    = 0
    ctrl_Handle[id]       = -1
    ctrl_Handle_type[id]  = -1
    ctrl_Function[id]         = -1
    ctrl_Family[id]       = classType[ pType ]
    ctrl_Type[id]         = pType
    ctrl_Focus_order[id]  = {}
    ctrl_Current_focus[id]        = 0
    ctrl_Previous_focus[id]   = 0
    ctrl_Parent[id]        = pOwner
    ctrl_X_Pos[id]            = 0
    ctrl_Y_Pos[id]            = 0
    ctrl_Erase[id]        = w32False
    ctrl_Font[id]         = FontDefaults
    ctrl_Pen[id]          = PenDefaults
    ctrl_Fg_Color[id]       = classFGColor[pType]
    ctrl_Bg_Color[id]       = classBGColor[pType]
    ctrl_Range[id]        = {{0,100},{0,100}}
    ctrl_Scroll[id]       = {{1,10}, {1,10}}
    ctrl_Tabitems[id]     = {}
    ctrl_Group[id]        = {}
    ctrl_Cursor[id]       = {w32Func( xLoadCursor, { NULL, classDefPointer[pType] } )}
    ctrl_Menu[id]         = 0
    ctrl_Popup[id]        = {-1,-1,-1,-1} -- One for normal, shift, ctrl, shift-ctrl.
    ctrl_Notify_List[id]     = {{},{},{}}  -- { {id ...}, {{events per id...} }, {{userdata ...}} }
    ctrl_Toolbar[id]      = 0
    ctrl_Statusbar[id]    = 0
    ctrl_Hint_Text[id]      = ""
    ctrl_Hint_Width[id]   = 200
    ctrl_Hotkey_Keys[id]  = {}
    ctrl_Hotkey_Ids[id]   = {}
    ctrl_Text_Alignment[id]    = TA_TOP
    ctrl_Closed[id]       = -11  -- Until its opened.
    ctrl_TabKey_Used[id]   = w32iff(and_bits(classAttr[pType], w32CtrlTab),0,1)
    ctrl_Handlers[id] = repeat({}, w32LastEventType)
    ctrl_Bg_Brush[id]       = 0
    ctrl_UserData[id]          = {{},{},{}}
    ctrl_IntData[id]         = {{},{}}
    ctrl_Name[id]         = 0
    ctrl_Deferred_Handlers[id]  = {}
    ctrl_Auto_Height[id]   = w32False
    ctrl_Auto_Width[id]    = w32False
    ctrl_Init_Posns[id]         = {{},{}}
    ctrl_ClassAddr[id]	    = 0
    ctrl_Mousetrap[id]    = 0

    if pOwner > 0 and pOwner <= length(ctrl_Group) then
        ctrl_Group[ pOwner ] &= id
    end if

    if and_bits(classAttr[pType], w32AutoSelect) then
       defineUserProperty(id, vAutoSelect, w32True)
    end if

    -- initialize event handlers
    onMouse[id]         = -1
    onClick[id]         = -1
    onKeyPress[id]      = -1
    onKeyUp[id]         = -1
    onKeyDown[id]       = -1
    onResize[id]        = -1
    onChange[id]        = -1
    onGotFocus[id]      = -1
    onLostFocus[id]     = -1
    onOpen[id]          = -1
    onActivate[id]      = -1
    onClose[id]         = -1
    onDestroy[id]       = -1
    onScroll[id]        = -1
    onTimer[id]         = -1
    onPaint[id]         = -1
    onDragAndDrop[id]   = -1
    onEvent[id]         = -1


    return id
end function

--/topic Events
--/func subClassControl(sequence Id,  atom hWnd)
--/desc Used to access Windows created controls as if they were win32lib controls.
--/return INTEGER: A win32lib control id. ZERO if it fails.
-- /i Id is a sequence {ControlType, ParentID} /n
-- /i hWnd is the Windows Handle to the control.
--
--Example
--/code
--      -- Use an edit fld that was created outside of win32lib as if it was
--      -- a normal win32lib control.
--    newid = subClassControl( {EditText, myWindow}, winhandle)
--
--      -- Use an external bitmap as if it was a pixmap.
--    bmh = loadBitmapFromFile("..\\demoresources\\java.bmp")
--    myPixMap = subClassControl({Pixmap, 0}, bmh)
--    setPenColor(myPixMap, Cyan)
--    drawRectangle(myPixMap, 1, 0, 0, 40, 40)
--/endcode

global function subClassControl(object pId,  atom phWnd)
    integer lNewId
    integer lParent
    integer lControlType

    if phWnd = 0 then
        return 0
    end if

    if sequence(pId) then
        lControlType = pId[1]
        lParent = pId[2]
        if getId(phWnd) != 0 or -- hWnd already has an ID
           (lParent !=0 and phWnd = getHandle(lParent)) or -- is its own parent
           lControlType < 1 or -- invalid control class
           lControlType > length(vControlTypes)
            then
            return 0
        end if
        lNewId = NewControl(lControlType, lParent)
    else
        lNewId = pId
    end if

    setId( phWnd, lNewId )
    -- Set up data for child control
    ctrl_Handle[lNewId] = phWnd
    if ctrl_Type[lNewId] = Pixmap then
        ctrl_Handle_type[lNewId] = kht_Bitmap
    else
        ctrl_Handle_type[lNewId] = kht_Window
    end if
    ctrl_Function[lNewId]   = w32Func( xSetWindowLong, { phWnd, GWL_WndProc, SubProcAddress } )

    return lNewId
end function

sequence vs_PreviousControl -- static
vs_PreviousControl = {}

integer vAutoFocusLabels
vAutoFocusLabels = w32False
-----------------------------------------------------------------------------

--/topic System Attributes
--/func setAutoFocusLabels(integer NewValue)
--/desc Sets whether or not a '&' in labels set focus to subsequent edit field.
--/ret Returns INTEGER: The current value of the flag.
--By default, this is set to w32False. Which means that any '&' in label captions
-- is ignored as far as setting focus to a subsequently defined input field. /n
-- If you set this to w32True then the '&' notation will cause focus to move to
-- the next input field defined after the label.
--
--Example:
--/code
--      integer lPrevFlag
--      . . .
--      -- Make labels focus on its input field.
--      lPrevFlag = setAutoFocusLabels(w32True)
--      -- The '&N' in the caption means that Alt-N will
--      -- set focus to the next input field.
--      lblX = create(LText, "&Name", Win, 5, 5, 40, 25, 0)
--      fldX = create(Editbox, "", Win, 5, 30, 120, 25, 0)
--      -- Set the flag back to whatever it was.
--      lPrevFlag = setAutoFocusLabels(lPrevFlag)
--
--/endcode

-----------------------------------------------------------------------------
global function setAutoFocusLabels(integer pNewValue)
-----------------------------------------------------------------------------
    integer lOldValue

    lOldValue = vAutoFocusLabels
    vAutoFocusLabels = pNewValue
    return lOldValue

end function


procedure toolbar_resize(integer self, integer event, sequence parms)
    sequence lOuterSize
    sequence lInnerSize
    integer lWidth
    if parms[2] = w32HResize then
        -- get size of toolbar
        lInnerSize = call_func(r_getClientRect,{ self })
        lWidth = parms[4][2]

        if lWidth != lInnerSize[3] then
            lOuterSize = call_func(r_getCtlSize,{self})
            VOID = w32Func( xMoveWindow,
	           { getHandle(self), 0, 0, lWidth, lOuterSize[2], 0} )
	        repaintWindow(self)
        end if
    end if
end procedure
procedure statusbar_resize(integer self, integer event, sequence parms)
    sequence lSize
    integer lWidth
    integer lHeight


    if parms[2] = w32HResize then
        -- get size of statusbar
        lSize = call_func(r_getClientRect,{ self })
        lWidth = parms[4][2]
        lHeight = parms[4][3]

        -- calculate position
        VOID = w32Func( xMoveWindow,
    	       { getHandle(self), 0, lHeight - lSize[4], lWidth, 0, w32True } )
    end if
end procedure

-----------------------------------------------------------------------------
--/topic Defining Controls
--/func createEx( integer controlType, sequence caption, atom Owner, object Left, object Top, object Width, object Height, object flags, object exFlags )
--/desc Create an object of type /i controlType.
--/ret Control identifier.
--
-- This is the same as /create, but allows you to specify extented
-- attribute flags.

global function createEx( integer pControl, sequence pCaption, atom pOwner,
	        object pLeft, object pTop, object pWidth, object pHeight,
	        object styleFlags, object exFlags )

    integer id, at, hotkey
    integer bgControl
    atom style, result, hWnd, flags, extendedflags, lParenthWnd
    atom szClassName, szCaption, hMenu, newhWnd, pstr,
    struct, ok, newobj
    sequence lvcol, BBox
    object sbPanels
    sequence lHintText
    atom lIconInfo
    integer autoclose
    object lBGColor
    object lUserPre
    object lUserPost
    object lTemp

    -- Check for AutoClose flag.

    autoclose = w32False
    if sequence( styleFlags ) then

	    if equal(styleFlags, w32AUTOCLOSE) then
	        autoclose = w32True
	        styleFlags = 0
        else
            flags = find(w32AUTOCLOSE, styleFlags)
            if flags != 0 then
    	        autoclose  = w32True
    	        styleFlags = w32removeIndex(flags, styleFlags)
            end if
        end if
    end if

    if pControl = ListView then
        lvcol = pCaption
        pCaption = ""
        lHintText = ""

    elsif length(pCaption) = 2 and
       w32string(pCaption[1]) and
       w32string(pCaption[2]) then

        lHintText = pCaption[2]
        pCaption = pCaption[1]

    else
        lHintText = ""
    end if

    if    (pOwner != 0)
      and (validId(pOwner) = w32False)  then
        abortErr(Err_OWNERINVALID)
    end if

    if pOwner = 0 then
        if pControl = MenuItem then
            pOwner = vRecent[w32RecentMenu]

        elsif pControl = MenuSpacer then
            pOwner = vRecent[w32RecentMenu]

        elsif pControl = TabItem then
            pOwner = vRecent[w32RecentTabControl]

        elsif pControl = ReBarBand then
            -- Need to find the rebar for the recent window.
            lTemp = findChildren(vRecent[w32RecentWindow])
            for i = 1 to length(lTemp) do
                if lTemp[i][2] = ReBar then
                    pOwner = lTemp[i][1]
                    exit
                end if
            end for
            if pOwner = 0 then
                abortErr(Err_OWNERINVALID)
            end if

        elsif find(pControl, {Window, Pixmap} ) = 0 then
            pOwner = vRecent[w32RecentWindow]

        end if
    else
        -- Certain controls must never have an owner.
        if find(pControl,{ ToolTip, Pixmap, Screen_, Printer_ })  then
            pOwner = 0
        end if

    end if

    if sequence(vControlRID[pControl]) then
        -- User defined control might have to change the owner.
        pOwner = call_func(vControlRID[pControl][kCRID_Control], {"NewOwner", pOwner})
    end if

    -- set up a new Control space
    id = NewControl( pControl, pOwner)

    -- Set the default name for this control.
    setIdName(id, pCaption)


    -- If this control is tab-stoppable and the previous
    -- control is a label, then set the hotkey for this control
    -- based on the previous control's caption,
    -- otherwise set the hotkey based on the current caption.
    if vAutoFocusLabels = w32False then
        registerHotKey( id, pCaption )
    else
        if and_bits( WS_TABSTOP, classStyle[ pControl ] ) and length(vs_PreviousControl) != 0 then
            if classType[ctrl_Type[vs_PreviousControl[1]]] = STATIC then
                registerHotKey( id, vs_PreviousControl[2] )
            else
                registerHotKey( id, pCaption )
            end if
        elsif classType[pControl] != STATIC then
            registerHotKey( id, pCaption )
        end if
    end if
    vs_PreviousControl = {id, pCaption}

    if pControl = CancelButton then
        registerHotKey( id, VK_ESCAPE )
    end if

    -- actual creation
    if sequence(vControlRID[pControl]) and vControlRID[pControl][kCRID_Create] >= 0 then
        -- User defined control.
        lUserPre = call_func(vControlRID[pControl][kCRID_Create],{"Pre",
                        {id, pCaption, pOwner,
                        pLeft, pTop, pWidth, pHeight,
                        styleFlags, exFlags}
                        })
        if sequence(lUserPre) and length(lUserPre) = 9 and lUserPre[1] = id then
            pCaption = lUserPre[2]
            pOwner = lUserPre[3]
            pLeft = lUserPre[4]
            pTop = lUserPre[5]
            pWidth = lUserPre[6]
            pHeight = lUserPre[7]
            styleFlags = lUserPre[8]
            exFlags = lUserPre[9]
        end if
    else
        -- Built in controls.
        lUserPre = {}

        if find(pControl,{ StatusBar} ) = 0 then
            BBox = convPctToPixel(id, pLeft, pTop, pWidth, pHeight)
            pLeft  = BBox[1]
            pTop  = BBox[2]
            pWidth = BBox[3]
            pHeight = BBox[4]

        elsif pControl = StatusBar then
            pLeft = 0
            pWidth = 0
            if sequence(pTop) then
                sbPanels = pTop
            else
                sbPanels = -1
            end if
            pTop = 0

            if sequence(pHeight) or (pHeight > 0 and pHeight < 1) then
                BBox = convPctToPixel(id, 0, 0, 0, pHeight)
                pHeight = BBox[4]
            end if
        end if
    end if

    ---- Creation ----
    if pControl = Screen_
       or pControl = Printer_ then
    -- nothing to do. Just wanted to manage it's storage.
        lUserPre = 0

    elsif pControl = Window then
        lUserPre = 0
        -- create a window
        createWindow( id, pCaption, pOwner, pLeft, pTop, pWidth, pHeight,
	            styleFlags, exFlags )

    elsif pControl = Menu then
        lUserPre = 0
        -- create a menu bar
        createMenu( id, pCaption, pOwner )

    elsif pControl = Popup then
        lUserPre = 0
        -- create a popup menu
        createMenu( id, pCaption, pOwner )

    elsif pControl = MenuItem then
        lUserPre = 0
        -- create a menu bar item
        createMenuItem( id, pCaption, pOwner, styleFlags )

    elsif pControl = MenuSpacer then
        lUserPre = 0
        -- create a menu bar item
        createMenuItem( id, "-", pOwner, 0 )

    elsif pControl = Pixmap then
        lUserPre = 0
        -- create a pixmap item
        createPixmap( id, pWidth, pHeight )

        -- set default font
        setDefaultFont(id)
        setFont(id, FontDefaults[1],FontDefaults[2],FontDefaults[3])


    elsif pControl = TabItem then
        lUserPre = 0
        -- create a tab control item
        createTabItem( id, pCaption, pOwner )
        call_proc(r_setFocus,{id})

    elsif pControl = ImageList then
        lUserPre = 0
        if pWidth = SM_CXSMICON then
            pWidth = getSystemMetrics(SM_CXSMICON)
            pHeight = getSystemMetrics(SM_CYSMICON)
        else
            pWidth = getSystemMetrics(SM_CXICON)
            pHeight = getSystemMetrics(SM_CYICON)
        end if

        hWnd = w32Func( ImageList_Create, { pWidth, pHeight, ILC_MASK + styleFlags,1,1})
        -- save the handle with the control
        setId( hWnd, id )

        VOID = w32Func( ImageList_SetBkColor, { hWnd, CLR_NONE } )
        -- save the handle in the sequence
        ctrl_Handle[id] = hWnd
        ctrl_Handle_type[id] = kht_ImageList

    elsif pControl = ReBarBand then
        lUserPre = 0

        struct = struct_REBARBANDINFO(
            w32or_all( {   RBBIM_ID,       -- fMask
    	                RBBIM_SIZE,
    	                RBBIM_TEXT,
    	                RBBIM_STYLE } ),
            w32or_all( {   RBBS_CHILDEDGE, -- fStyle
    	        RBBS_GRIPPERALWAYS,
    	        styleFlags }),
            0,          -- clrFore
            0,          -- clrBack
            pCaption,    -- lpText
            0,          -- iImage
            0,          -- hwndChild
            0,          -- cxMinChild
            0,          -- cyMinChild
            pWidth,         -- pWidth
            0,          -- hbmBack
            id,         -- wID
            0,          -- cyChild
            0,          -- cyMaxChild
            0,          -- cyIntegral
            0,          -- cxIdeal
            0,          -- lParam
            0 )         -- cxHeader

        hWnd = sendMessage( pOwner, RB_INSERTBAND, -1, struct )

        w32release_mem( struct )


    elsif pOwner != 0
     and ctrl_Type[pOwner] = FlatToolBar
     and classType[pControl] = BUTTON then
        lUserPre = 0
        -- adding a button to a flat toolbar!
        ctrl_Family[id] = BUTTON
        ctrl_Hint_Text[id] = pCaption

        if length( pCaption ) > 0 then
            szCaption = sendMessage( pOwner, TB_ADDSTRING, 0, pCaption & 0 )
        else
            -- Use "" by default.
            szCaption = -1
        end if

        struct = w32acquire_mem( 0, SIZEOF_TBBUTTON )
        w32store( struct, TBBUTTON_idCommand, id )
        w32store( struct, TBBUTTON_dwData, id )
        w32store( struct, TBBUTTON_iBitmap, pLeft-1 )
        w32store( struct, TBBUTTON_fsState, TBSTATE_ENABLED )
        w32store( struct, TBBUTTON_iString, szCaption )

        styleFlags = w32or_all( {styleFlags, classStyle[ pControl ] } )

        w32store( struct, TBBUTTON_fsStyle, styleFlags )

        ok = sendMessage( pOwner, TB_ADDBUTTONS, 1, struct )

        w32release_mem(struct)

        if not ok then
            warnErr( Err_FLATTOOLBARBTN )
        end if
    end if

    if sequence(lUserPre) then
        -- Use standard (built-in) creation processing --

        -- create C string for pControl name
        szClassName = w32acquire_mem( 0, className[ pControl ] )

        -- create C string for caption and link with ClassName
        szCaption = w32acquire_mem( szClassName, pCaption )

        -- user supplied flags
        if and_bits(classAttr[pControl], w32PictCtrl ) = 0 then

            if atom( styleFlags ) then
    	     -- combine with user's values
        	    flags = or_bits( classStyle[ pControl ], styleFlags )
            else
    	     -- replace with user's values
    	        flags = w32or_all(styleFlags)
            end if
        else
            -- 'cos styleFlags is really a DIB handle
            flags = classStyle[ pControl ]

            if find(pControl, {PictureButton, TogglePicture}) then
                if equal(styleFlags, w32PB_BITMAP) or equal(styleFlags,0) then
                    flags = or_bits(flags, BS_BITMAP)
                    styleFlags = 0

                elsif equal(styleFlags, w32PB_ICON) then
                    flags = or_bits(flags, BS_ICON)
                    styleFlags = 0

                elsif w32string(styleFlags) then
                   if (match(".ICO", upper(styleFlags)) != 0 or
                      equal("ICON", upper(styleFlags))) then
                       flags = or_bits(flags, BS_ICON)
                    else
                        flags = or_bits(flags, BS_BITMAP)
                    end if
                elsif atom(styleFlags) then
                    ok = w32Func(xGetObjectType, {styleFlags})
                    if ok = 0 then
                        flags = or_bits(flags, BS_ICON)

                    elsif ok = OBJ_BITMAP then
                        flags = or_bits(flags, BS_BITMAP)

                    else
                        warnErr("The image used to create a picture button\nis not an ICON or a BITMAP")
                        styleFlags = 0
                    end if
                else
                    warnErr("The image used to create a picture button\nis not valid")
                    styleFlags = 0
                end if
            end if
        end if

        -- extended flags
        if atom(exFlags) then
            extendedflags = or_bits( classStyleEx[ pControl ], exFlags )
        else
            extendedflags = w32or_all( exFlags )
        end if

        -- Some controls interpret hMenu differently
        if and_bits( w32OwnerId, classAttr[ pControl ]) != 0 then
            -- identifier of parent
            hMenu = pOwner
        else
            -- null
            hMenu = NULL
        end if

        -- create control
        if and_bits( w32Virtual, classAttr[ pControl ]) != 0 then
            lParenthWnd = getHandle( findParent(pOwner) )
        else
            lParenthWnd = getHandle( pOwner )
        end if

        hWnd = w32Func( xCreateWindow, {
    	    extendedflags,          -- extended style
    	    szClassName,            -- window class name
    	    szCaption,              -- window caption
    	    flags,                  -- window style
    	    pLeft, pTop,            -- initial pLeft, pTop position
    	    pWidth, pHeight,        -- initial pLeft, pTop size
    	    lParenthWnd,            -- parent window handle
    	    hMenu,                  -- window menu handle
    	    instance(),             -- program instance handle
    	    NULL} )                 -- creation parameters

        w32release_mem( szClassName )

        -- associate id with hWnd
        if subClassControl( id, hWnd) = 0 then
            abortErr(Err_CREATECONTROL)
        end if

        -- save tab order with owner if the attribute is tab stop
        if and_bits( WS_TABSTOP, flags ) and pOwner != 0 then
            -- add to the owner's focus_order list
            ctrl_Focus_order[pOwner] &= id
        end if

        -- picture control that's not in a flattoolbar?
        if   and_bits(classAttr[pControl], w32PictCtrl ) != 0 then
            if ctrl_Type[pOwner] != FlatToolBar
               and not equal(styleFlags,0) then
                -- need to load image?
                call_proc(r_setBitmap,{id, styleFlags})
            end if

        end if

        -- Set the new control's background color.
        -- If the control's bg color is -1 then it is "transparent" and
        -- takes on whatever its parent's bg color is.
        if pOwner != 0 and equal(classBGColor[pControl], w32BGTransparent) then
            lBGColor = ctrl_Bg_Color[pOwner]
            while equal(lBGColor, w32BGTransparent) do
                bgControl = getParent(pOwner)
                if bgControl = 0 then
                    lBGColor = classBGColor[ pControl]
                    exit
                end if
                lBGColor = ctrl_Bg_Color[bgControl]
            end while
        else
            lBGColor = classBGColor[ pControl]
        end if

        setWindowBackColor( id, lBGColor)

        -- set default font
        setDefaultFont(id)
    end if

    ----- Post Creation ----
    if length(lHintText) > 0 then
        call_proc(r_setHintEx,{id, lHintText, 0})
    end if

    if and_bits(classAttr[ctrl_Type[id]], w32Toolbar) and
        (ctrl_Toolbar[ pOwner ] = 0) then
        -- track toolbar in owner
        ctrl_Toolbar[ pOwner ] = id
        lTemp = vOnXXXSupport
        setHandler(id, w32HNotify, routine_id("toolbar_resize"))
        vOnXXXSupport = lTemp
        call_proc(r_registerNotification, {pOwner, 1, w32HResize, id, 0})
    end if
    if and_bits(classAttr[ctrl_Type[id]], w32Statusbar) and
        (ctrl_Statusbar[ pOwner ] = 0) then
        -- track statusbar in owner
        ctrl_Statusbar[ pOwner ] = id
        lTemp = vOnXXXSupport
        setHandler(id, w32HNotify, routine_id("statusbar_resize"))
        vOnXXXSupport = lTemp
        call_proc(r_registerNotification, {pOwner, 1, w32HResize, id, 0})
    end if

    if sequence(vControlRID[pControl]) and vControlRID[pControl][kCRID_Create] != -1 then
        -- User defined control
        lUserPost = call_func(vControlRID[pControl][kCRID_Create], {
                    "Post", {id}
                    })
        if sequence(lUserPost) and lUserPost[1] = id then
            if find(lUserPost[2], {w32RecentMenu, w32RecentTabControl, w32RecentWindow}) != 0 then
                vRecent[lUserPost[2]] = id
            end if

        end if
    else
        -- Built in controls.
        if sequence(lUserPre) then
            -- Standard create used.

            if pControl = CancelButton then
                setFont(id, FontDefaults[1],FontDefaults[2],Italic)
            else
                setFont(id, FontDefaults[1],FontDefaults[2],FontDefaults[3])
            end if


            if pControl = TabControl then
                vRecent[w32RecentTabControl] = id

            elsif pControl = Group then
                vRecent[w32RecentWindow] = id

            end if
        end if

        -- Ensure that toolbars have at least one 'string'
        if find(pControl, {FlatToolBar, ToolBar}) then
            VOID = sendMessage( id, TB_ADDSTRING, 0, {0} )
            -- Set default bitmap and button sizes
            lTemp = w32pack_word( w32Func(xGetSystemMetrics,{SM_CXICON}),
                                w32Func(xGetSystemMetrics,{SM_CYICON}))

            VOID = sendMessage(id, TB_SETBUTTONSIZE, 0, lTemp)
            VOID = sendMessage(id, TB_SETBITMAPSIZE, 0, lTemp)
        end if

        -- track as children, since they need to resize
        if pControl = StatusBar then

            if sequence(sbPanels) then
                call_proc(r_setSubFields,{id, sbPanels})
            end if
            if pHeight > 0 then
                VOID = sendMessage(id, SB_SETMINHEIGHT, pHeight, 0)
            end if
        end if

        -- set up image lists and columns
        if pControl = ListView then

            if not ILlarge then
                ILlarge = createEx( ImageList, "", 0, 0,0,SM_CXICON,0,
    	            ILC_COLOR8,0)
                ILsmall = createEx( ImageList, "", 0, 0,0,SM_CXSMICON,0,
    	            ILC_COLOR8,0)
            end if

            if and_bits(LVS_REPORT, flags) != 0 then
                if w32string(lvcol) then
                    lvcol = {lvcol}
                end if
                for i = 1 to length( lvcol ) do
                    if sequence(lvcol[i]) then
                        if length(lvcol[i]) > 0 then
                            if not sequence(lvcol[i][1]) then
                                -- We only have a column heading
                                lvcol[i] = {lvcol[i], 100, 0}
                            else
                                if length(lvcol[i]) < 2 then
                                    -- No width, so set default
                                    lvcol[i] = append(lvcol[i], 100)
                                end if
                                if length(lvcol[i]) < 3 then
                                    -- No alignment, so set default
                                    lvcol[i] = append(lvcol[i], 0)
                                end if
                            end if
                        else
                            lvcol[i] = {"", 100,0}
                        end if
                    else
                        -- We only have a width.
                        lvcol[i] = {"", w32abs(floor(lvcol[i])),0}
                    end if
                    insertLVColumn( id, 0, 0,lvcol[i][3],lvcol[i][2], lvcol[i][1], i)
                end for
            end if

            setImageList( id, ILlarge, LVSIL_NORMAL )
            setImageList( id, ILsmall, LVSIL_SMALL )

            lv_id &= id
            lv_properties &= {lv_Default_Properties}
            lv_properties[length(lv_id)][kLVSortRtn] = r_lvSortitems

        elsif pControl = ToolTip then
            if tooltipControl != 0 then
                VOID = sendMessage( tooltipControl, TTM_ACTIVATE, 0, 0 )
            end if

            tooltipControl = id
            VOID = sendMessage( tooltipControl, TTM_ACTIVATE, 1, 0 )

        elsif pControl = TreeView then
            if not ILlarge then
                ILlarge = createEx( ImageList, "", 0, 0,0,SM_CXICON,0,
        	        ILC_COLOR8,0)
                ILsmall = createEx( ImageList, "", 0, 0,0,SM_CXSMICON,0,
        	        ILC_COLOR8,0)
            end if

            setImageList( id, ILsmall, TVSIL_NORMAL )
            -- Haven't set State icons

            tv_id &= id


        elsif pControl = FlatToolBar then

            VOID = sendMessage( id, TB_BUTTONSTRUCTSIZE, SIZEOF_TBBUTTON, 0 )

            if himlFTBDefault = 0 then
                -- Need to create imagelists

                himlFTBDefault = createEx( ImageList, "", 0, 0,0,SM_CXICON,0,
        	        ILC_COLOR8,0)
                himlFTBHot = createEx( ImageList, "", 0, 0,0,SM_CXICON,0,
        	        ILC_COLOR8,0)
                himlFTBDisabled = createEx( ImageList, "", 0, 0,0,SM_CXICON,0,
        	        ILC_COLOR8,0)

            end if

            if not tooltipControl then
                tooltipControl = createEx( ToolTip, "", 0, 0, 0, 0, 0, 0, 0 )
            end if

            VOID = sendMessage( id, TB_SETTOOLTIPS, 0, getHandle( tooltipControl ) )

            -- Set image lists for the 3 states
            VOID = sendMessage( id, TB_SETIMAGELIST, 0, getHandle(himlFTBDefault) )
            VOID = sendMessage( id, TB_SETHOTIMAGELIST, 0, getHandle(himlFTBHot) )
            VOID = sendMessage( id, TB_SETDISABLEDIMAGELIST, 0 ,getHandle(himlFTBDisabled) )

        elsif pControl = ComboBoxEx then

            if not ILlarge then
                ILlarge = createEx( ImageList, "", 0, 0,0,SM_CXICON,0,
        	        ILC_COLOR8,0)
                ILsmall = createEx( ImageList, "", 0, 0,0,SM_CXSMICON,0,
        	        ILC_COLOR8,0)
            end if

            VOID = sendMessage( id, CBEM_SETIMAGELIST, 0, getHandle(ILsmall) )
        elsif pControl = Bitmap then
           if match(".BMP", upper(pCaption)) = (length(pCaption)-3) then
                call_proc(r_setBitmap,{id, pCaption})
           end if

        elsif pControl = Icon then
            if match(".ICO", upper(pCaption)) = (length(pCaption)-3) then
                call_proc(r_setIcon,{id, pCaption})
            end if

        end if

        -- See if I have to subclass this control.
        if ctrl_Family[id] = COMBO or
           equal(className[pControl], WC_COMBOBOXEX) then

            newhWnd = w32Func(xGetWindow,{ hWnd, GW_CHILD})
            VOID = subClassControl( {EditText,id}, newhWnd)
        end if

    end if


    if autoclose then
        lTemp = vOnXXXSupport
        setHandler(id, w32HClick, r_autoclose)
        vOnXXXSupport = lTemp
    end if

    return id

end function
r_createEx = routine_id("createEx")


-----------------------------------------------------------------------------
--/topic Defining Controls
--/func create( pControl, title, parent, x, y, cx, cy, flags )
--/desc Create an object of type /i pControl.
--/ret Control identifier.
--
-- The /i title is the text that will appear in the object's caption. It can be
-- a single string or a sequence of two strings. In this later form, the first
-- string is the caption text, and the second is the tooltip text. /n
-- /n Note for /Bitmap controls, the caption can also be the name of a bitmap (.BMP)
-- file. In this case, it will be automatically loaded into the Bitmap control and
-- placed in RAM until the program ends.
--
-- /i x and /i y specify the position of the object, and /i cx and
-- /cy specify the width and height.
--
-- You can specify additional attributes by passing them in the /i flags
-- parameter. If /i flags is an atom, then these are combined with the
-- default style flags for the control class. If /i flags is a sequence of
-- flags, then they replace the default style flags.
--
-- The /i flags parameter is used differently for /PictureButton and /TogglePicture
-- controls. In this case, it can be the name of a bitmap (.BMP) or an icon (.ICO) file
-- which causes that image to be displayed on the button face. Alternatively, you can
-- pass the handle of bitmap or icon in the flags parameter. This technique is useful
-- if you have preloaded images from files and intend to reuse them. Once the type
-- of image, bitmap or icon, is determined for the control, you cannot change
-- it to the other type.
--
-- Note that if the /i flags parameter contains the flag 'w32AUTOCLOSE', the
-- control's click event will close its parent window.
--
-- /b Returns: The value returned is the /i id of the control. This is
-- typically the first parameter expected in Win32Lib functions.
--
-- The parent of the main window is 0.
--
-- If you don't care about the positioning of a window, you can
-- use the parameter /b Default, and Windows will automatically
-- position the window.
--
-- /b Note: for windows, the size specified by /i cx, /i cy is
-- the /i total size of the window, not the size of the client area.
-- After creating a Window, you can use /setClientRect to give an exact
-- client area size.
--
-- /b Note: The /i x and /i y values are relative to the parent's client area.
--
-- Each dimension for /i x, /i y, /i cx, and /i cy can be expressed as either... /n
-- a) an integer >= 0, in which case it is not touched. /n
--     eg.  50 (= 50 pixels) /n
-- b) an atom in the range > 0 and ~< 1, which is taken to be a %
--    of the control's parent dimension. /n
--     eg.  0.50 (= 50% of parent's size) /n
-- c) The constant /i w32Edge which signifies the parent's extreme
--    client edge for the dimension. That is, either the rightmost or
--    bottom most edge, as appropriate. /n
-- d) a sequence of two elements, the first as in (b) or (c) above, and
--    the other a pixel offset. The offset is added after converting. /n
--     eg.  {0.50, -3} ( = 50% of parent size less 3 pixels) /n
--     eq   (w32Edge, -10} ( = right/bottom pixel less 10 pixels) /n
-- e) a sequence of three elements, the first two as in (d), and
--    the other a two-element sequence containing the minimum and
--    maximum allowable values. These can be a percentage or a
--    pixel amount. /n
--     eg.  {0.50, -3, {20, 300}} ( = 50% of parent size less
--            3 pixels, and a minimum of 20 pixels and a
--            maximum of 300 pixels) /n
--
-- However, for /StatusBar controls, the /i x and /i cx values are ignored,
-- as a statusbar is always aligned to the bottom left edge of a window.
-- Also for /StatusBar controls, the /i x can be used to define subPanels
-- in the bar. See /setSubFields for details.
-- The following will create a /Window called /b MyWindow:
--
-- For /b Menus , if the /i title contains a '!' character, a /b Command menu
-- is created rather than a /b Popup menu. The difference is that a Command menu
-- reacts immediately to being clicked, while a Popup menu will display its
-- menu items instead. /n
-- /b "Note 1:" This type of menu will not be allowed
-- to contain MenuItems. The reason being that when you click on the menu
-- a w32HClick event is generated and any items are never shown. /n
-- /b "Note 2:" The '!' character is stripped out of the title before displaying
-- it on screen.
--
--Examples:
--/code
--      -- create a window
--      constant MyWindow = create( Window,         -- the pControl
--                          "My Window",        -- the caption
--                          0,                  -- the parent
--                          Default, Default,   -- x and y position
--                          0.5,                -- 50% of the screen width
--                          40,                 -- 40 pixels high
--                          0 )                 -- no special flags
--
--      constant MsgWindow = create( Window,         -- the pControl
--                          "Messages",        -- the caption
--                          0,                  -- the parent
--                          Default, Default,   -- x and y position
--                          200,                -- 200 pixels wide
--                          200,                -- 200 pixels high
--                          {WS_DLGFRAME,
--                           WS_SYSMENU,
--                           WS_MINIMIZEBOX
--                           } )-- replacement flags
--/endcode
--
-- The following will create a /PushButton in /b MyWindow:
--/code
--      -- create a pushbutton
--      constant MyButton = create(
--                              PushButton,         -- the pControl
--                              {"Push Me!",        -- the caption
--                               "Go on, have a go!"}, -- the tooltip text
--                              MyWindow,           -- the parent
--                              10, 10,             -- x and y position
--                              60, 40,             -- width and height
--                              0 )                 -- no special flags
--/endcode
--
-- The following will create a /Bitmap in /b MyWindow:
--/code
--      -- create a bitmap
--      constant BM1 = create(
--                              Bitmap,         -- the pControl
--                              "images\\logo.bmp", -- the file to display
--                              MyWindow,           -- the parent
--                              10, 90,             -- x and y position
--                              60, 40,             -- width and height
--                              0 )                 -- no special flags
--/endcode
--
-- The different classes of objects are:
-- /li /Bitmap: static bitmap
-- /li /CheckBox: check box
-- /li /Combo: combo box - has edit box and drop down list (aka ComboBox)
-- /li /ComboBoxEx: Combo with images
-- /li /CText: static text lable, center justified
-- /li /DefPushButton: default push button
-- /li /DropDownList: drop down list, non-editable
-- /li /EditText: edit text (aka EditBox, TextBox, SleText)
-- /li /FlatToolBar: like a toolbar, only flat
-- /li /Group: group box  (aka GroupBox)
-- /li /HScroll: horizontal scroll bar
-- /li /HTrackBar: horizontal track bar
-- /li /Icon: static icon
-- /li /ImageList: A storage container for images.
-- /li /List: list with scroll bar (aka ListBox)
-- /li /ListView: list with icons, labels and columns
-- /li /LText: left justified static label
-- /li /Menu: menu bar item
-- /li /MenuItem: dropdown menu item
-- /li /MenuSpacer: Horizontal line in a menu.
-- /li /MleText: multiple line text edit
-- /li /MonthCalendar: select dates
-- /li /PictureButton: push button with graphic
-- /li /Pixmap: off-screen color bitmap
-- /li /Popup: a pop up menu
-- /li /ProgressBar: shows task completion state
-- /li /PushButton: push button (aka Button, CommandButton)
-- /li /Radio: radio button (aka RadioButton)
-- /li /ReBar: advanced toolbars
-- /li /ReBarBand: Rebar divider for grouping controls
-- /li /RichEdit: text edit with formatting
-- /li /RText: right-justified static text label
-- /li /SepButton: divider on FlatToolBars
-- /li /SimpleCombo: combo box, no drop down list
-- /li /SortedCombo: combo box, with sorted list
-- /li /SortedList: list, with sorted elements
-- /li /StatusBar: control for status text
-- /li /TabControl: control containing tab items
-- /li /TabItem: control item in /TabControl
-- /li /ToggleButton: push button that toggles off and on
-- /li /TogglePicture: toggle button with picture
-- /li /ToolBar: control for placing other controls into
-- /li /ToolTip: A group of tooltips with all the same style.
-- /li /TreeView: hierarchical list
-- /li /TriCheckBox: 3 state check box
-- /li /UpDown: increment/decrement control
-- /li /VScroll: vertical scroll bar
-- /li /VTrackBar: vertical track bar
-- /li /Window: window
global function create( integer pControl, sequence caption, atom pOwner,
	        object x, object y, object cx, object cy,
	        object styleFlags )
    -- create with no extended style flags
    return createEx( pControl, caption, pOwner, x, y, cx, cy, styleFlags, 0 )

end function

vWinFlagNames = {
    "WS_OVERLAPPED",
    "WS_POPUP",
    "WS_CHILD",
    "WS_MINIMIZE",
    "WS_VISIBLE",
    "WS_DISABLED",
    "WS_CLIPPINGCHILD",
    "WS_CLIPSIBLINGS",
    "WS_CLIPCHILDREN",
    "WS_MAXIMIZE",
    "WS_CAPTION",
    "WS_BORDER",
    "WS_DLGFRAME",
    "WS_HSCROLL",
    "WS_VSCROLL",
    "WS_SYSMENU",
    "WS_THICKFRAME",
    "WS_GROUP",
    "WS_TABSTOP",
    "WS_SCROLLBARS",
    "WS_MINIMIZEBOX",
    "WS_MAXIMIZEBOX",
    "WS_TILED",
    "WS_ICONIC",
    "WS_SIZEBOX",
    "WS_OVERLAPPEDWINDOW",
    "WS_TILEDWINDOW",
    "WS_POPUPWINDOW",
    "WS_CHILDWINDOW",
    "BS_3STATE",
    "BS_AUTO3STATE",
    "BS_AUTOCHECKBOX",
    "BS_AUTORADIOBUTTON",
    "BS_BITMAP",
    "BS_BOTTOM",
    "BS_CENTER",
    "BS_CHECKBOX",
    "BS_DEFPUSHBUTTON",
    "BS_GROUPBOX",
    "BS_ICON",
    "BS_LEFT",
    "BS_LEFTTEXT",
    "BS_MULTILINE",
    "BS_NOTIFY",
    "BS_OWNERDRAW",
    "BS_PUSHBUTTON",
    "BS_PUSHLIKE",
    "BS_RADIOBUTTON",
    "BS_RIGHT",
    "BS_RIGHTBUTTON",
    "BS_TEXT",
    "BS_TOP",
    "BS_USERBUTTON",
    "BS_VCENTER",
    "ES_LEFT",
    "ES_CENTER",
    "ES_RIGHT",
    "ES_MULTILINE",
    "ES_AUTOHSCROLL",
    "ES_AUTOVSCROLL",
    "ES_DISABLENOSCROLL",
    "ES_LOWERCASE",
    "ES_NUMBER",
    "ES_NUMERIC",
    "ES_OEMCONVERT",
    "ES_PASSWORD",
    "ES_READONLY",
    "ES_UPPERCASE",
    "ES_WANTRETURN",
    "ES_AUTOSCROLL",
    "ES_SAVESEL",
    "ES_NOHIDESEL",
    "LBS_NOTIFY",
    "LBS_SORT",
    "LBS_NOREDRAW",
    "LBS_MULTIPLESEL",
    "LBS_OWNERDRAWFIXED",
    "LBS_OWNERDRAWVARIABLE",
    "LBS_HASSTRINGS",
    "LBS_USETABSTOPS",
    "LBS_NOINTEGRALHEIGHT",
    "LBS_MULTICOLUMN",
    "LBS_WANTKEYBOARDINPUT",
    "LBS_EXTENDEDSEL",
    "LBS_DISABLENOSCROLL",
    "LBS_NODATA",
    "LBS_NOSEL",
    "LBS_STANDARD",
    "LVS_ICON",
    "LVS_REPORT",
    "LVS_SMALLICON",
    "LVS_LIST",
    "LVS_TYPEMASK",
    "LVS_SINGLESEL",
    "LVS_SHOWSELALWAYS",
    "LVS_SORTASCENDING",
    "LVS_SORTDESCENDING",
    "LVS_SHAREIMAGELISTS",
    "LVS_NOLABELWRAP",
    "LVS_AUTOARRANGE",
    "LVS_EDITLABELS",
    "LVS_OWNERDATA",
    "LVS_NOSCROLL",
    "LVS_TYPESTYLEMASK",
    "LVS_ALIGNTOP",
    "LVS_ALIGNLEFT",
    "LVS_ALIGNMASK",
    "LVS_OWNERDRAWFIXED",
    "LVS_NOCOLUMNHEADER",
    "LVS_NOSORTHEADER",
    "RBS_TOOLTIPS",
    "RBS_VARHEIGHT",
    "RBS_BANDBORDERS",
    "RBS_FIXEDORDER",
    "RBS_REGISTERDROP",
    "RBS_AUTOSIZE",
    "RBS_VERTICALGRIPPER",
    "RBS_DBLCLKTOGGLE",
    "RBBS_BREAK",
    "RBBS_FIXEDSIZE",
    "RBBS_CHILDEDGE",
    "RBBS_HIDDEN",
    "RBBS_NOVERT",
    "RBBS_FIXEDBMP",
    "RBBS_VARIABLEHEIGHT",
    "RBBS_GRIPPERALWAYS",
    "RBBS_NOGRIPPER",
    "TVS_HASBUTTONS",
    "TVS_HASLINES",
    "TVS_LINESATROOT",
    "TVS_EDITLABELS",
    "TVS_DISABLEDRAGDROP",
    "TVS_SHOWSELALWAYS",
    "TVS_RTLREADING",
    "TVS_NOTOOLTIPS",
    "TVS_CHECKBOXES",
    "TVS_TRACKSELECT",
    "TVS_SINGLEEXPAND",
    "TVS_INFOTIP",
    "TVS_FULLROWSELECT",
    "TVS_NOSCROLL",
    "TVS_NONEVENHEIGHT",
    "UDS_ALIGNLEFT",
    "UDS_ALIGNRIGHT",
    "UDS_ARROWKEYS",
    "UDS_AUTOBUDDY",
    "UDS_HORZ",
    "UDS_NOTHOUSANDS",
    "UDS_SETBUDDYINT",
    "UDS_WRAP",
    "SS_NOPREFIX",
    "SS_NOTIFY",
    "SS_CENTERIMAGE",
    "SS_RIGHTJUST",
    "SS_REALSIZEIMAGE",
    "SS_SUNKEN",
    "SS_ENDELLIPSIS",
    "SS_PATHELLIPSIS"

        }

vWinExFlagNames = {
    "WS_EX_ACCEPTFILES",
    "WS_EX_APPWINDOW",
    "WS_EX_CLIENTEDGE",
    "WS_EX_CONTEXTHELP",
    "WS_EX_CONTROLPARENT",
    "WS_EX_DLGMODALFRAME",
    "WS_EX_LEFT",
    "WS_EX_LEFTSCROLLBAR",
    "WS_EX_LTRREADING",
    "WS_EX_MDICHILD",
    "WS_EX_NOPARENTNOTIFY",
    "WS_EX_OVERLAPPEDWINDOW",
    "WS_EX_PALETTEWINDOW",
    "WS_EX_RIGHT",
    "WS_EX_RIGHTSCROLLBAR",
    "WS_EX_RTLREADING",
    "WS_EX_STATICEDGE",
    "WS_EX_TOOLWINDOW",
    "WS_EX_TOPMOST",
    "WS_EX_TRANSPARENT",
    "WS_EX_WINDOWEDGE",
    "WS_EX_LAYERED",
    "WS_EX_NOINHERITLAYOUT",
    "WS_EX_LAYOUTRTL",
    "WS_EX_NOACTIVATE"
    }

vLVExFlagNames = {
    "LVS_EX_GRIDLINES",
    "LVS_EX_SUBITEMIMAGES",
    "LVS_EX_CHECKBOXES",
    "LVS_EX_TRACKSELECT",
    "LVS_EX_HEADERDRAGDROP",
    "LVS_EX_FULLROWSELECT",
    "LVS_EX_ONECLICKACTIVATE",
    "LVS_EX_TWOCLICKACTIVATE",
    "LVS_EX_FLATSB",
    "LVS_EX_REGIONAL",
    "LVS_EX_NFOTIP",
    "LVS_EX_UNDERLINEHOT",
    "LVS_EX_UNDERLINECOLD",
    "LVS_EX_MULTIWORKAREAS"
    }

vLVExFlagValues = {
    LVS_EX_GRIDLINES,
    LVS_EX_SUBITEMIMAGES,
    LVS_EX_CHECKBOXES,
    LVS_EX_TRACKSELECT,
    LVS_EX_HEADERDRAGDROP,
    LVS_EX_FULLROWSELECT,
    LVS_EX_ONECLICKACTIVATE,
    LVS_EX_TWOCLICKACTIVATE,
    LVS_EX_FLATSB,
    LVS_EX_REGIONAL,
    LVS_EX_NFOTIP,
    LVS_EX_UNDERLINEHOT,
    LVS_EX_UNDERLINECOLD,
    LVS_EX_MULTIWORKAREAS
    }
vWinFlagValues = {
    WS_OVERLAPPED,
    WS_POPUP,
    WS_CHILD,
    WS_MINIMIZE,
    WS_VISIBLE,
    WS_DISABLED,
    WS_CLIPPINGCHILD,
    WS_CLIPSIBLINGS,
    WS_CLIPCHILDREN,
    WS_MAXIMIZE,
    WS_CAPTION,
    WS_BORDER,
    WS_DLGFRAME,
    WS_HSCROLL,
    WS_VSCROLL,
    WS_SYSMENU,
    WS_THICKFRAME,
    WS_GROUP,
    WS_TABSTOP,
    WS_SCROLLBARS,
    WS_MINIMIZEBOX,
    WS_MAXIMIZEBOX,
    WS_TILED,
    WS_ICONIC,
    WS_SIZEBOX,
    WS_OVERLAPPEDWINDOW,
    WS_TILEDWINDOW,
    WS_POPUPWINDOW,
    WS_CHILDWINDOW,
    BS_3STATE,
    BS_AUTO3STATE,
    BS_AUTOCHECKBOX,
    BS_AUTORADIOBUTTON,
    BS_BITMAP,
    BS_BOTTOM,
    BS_CENTER,
    BS_CHECKBOX,
    BS_DEFPUSHBUTTON,
    BS_GROUPBOX,
    BS_ICON,
    BS_LEFT,
    BS_LEFTTEXT,
    BS_MULTILINE,
    BS_NOTIFY,
    BS_OWNERDRAW,
    BS_PUSHBUTTON,
    BS_PUSHLIKE,
    BS_RADIOBUTTON,
    BS_RIGHT,
    BS_RIGHTBUTTON,
    BS_TEXT,
    BS_TOP,
    BS_USERBUTTON,
    BS_VCENTER,
    ES_LEFT,
    ES_CENTER,
    ES_RIGHT,
    ES_MULTILINE,
    ES_AUTOHSCROLL,
    ES_AUTOVSCROLL,
    ES_DISABLENOSCROLL,
    ES_LOWERCASE,
    ES_NUMBER,
    ES_NUMERIC,
    ES_OEMCONVERT,
    ES_PASSWORD,
    ES_READONLY,
    ES_UPPERCASE,
    ES_WANTRETURN,
    ES_AUTOSCROLL,
    ES_SAVESEL,
    ES_NOHIDESEL,
    LBS_NOTIFY,
    LBS_SORT,
    LBS_NOREDRAW,
    LBS_MULTIPLESEL,
    LBS_OWNERDRAWFIXED,
    LBS_OWNERDRAWVARIABLE,
    LBS_HASSTRINGS,
    LBS_USETABSTOPS,
    LBS_NOINTEGRALHEIGHT,
    LBS_MULTICOLUMN,
    LBS_WANTKEYBOARDINPUT,
    LBS_EXTENDEDSEL,
    LBS_DISABLENOSCROLL,
    LBS_NODATA,
    LBS_NOSEL,
    LBS_STANDARD,
    LVS_ICON,
    LVS_REPORT,
    LVS_SMALLICON,
    LVS_LIST,
    LVS_TYPEMASK,
    LVS_SINGLESEL,
    LVS_SHOWSELALWAYS,
    LVS_SORTASCENDING,
    LVS_SORTDESCENDING,
    LVS_SHAREIMAGELISTS,
    LVS_NOLABELWRAP,
    LVS_AUTOARRANGE,
    LVS_EDITLABELS,
    LVS_OWNERDATA,
    LVS_NOSCROLL,
    LVS_TYPESTYLEMASK,
    LVS_ALIGNTOP,
    LVS_ALIGNLEFT,
    LVS_ALIGNMASK,
    LVS_OWNERDRAWFIXED,
    LVS_NOCOLUMNHEADER,
    LVS_NOSORTHEADER,
    RBS_TOOLTIPS,
    RBS_VARHEIGHT,
    RBS_BANDBORDERS,
    RBS_FIXEDORDER,
    RBS_REGISTERDROP,
    RBS_AUTOSIZE,
    RBS_VERTICALGRIPPER,
    RBS_DBLCLKTOGGLE,
    RBBS_BREAK,
    RBBS_FIXEDSIZE,
    RBBS_CHILDEDGE,
    RBBS_HIDDEN,
    RBBS_NOVERT,
    RBBS_FIXEDBMP,
    RBBS_VARIABLEHEIGHT,
    RBBS_GRIPPERALWAYS,
    RBBS_NOGRIPPER,
    TVS_HASBUTTONS,
    TVS_HASLINES,
    TVS_LINESATROOT,
    TVS_EDITLABELS,
    TVS_DISABLEDRAGDROP,
    TVS_SHOWSELALWAYS,
    TVS_RTLREADING,
    TVS_NOTOOLTIPS,
    TVS_CHECKBOXES,
    TVS_TRACKSELECT,
    TVS_SINGLEEXPAND,
    TVS_INFOTIP,
    TVS_FULLROWSELECT,
    TVS_NOSCROLL,
    TVS_NONEVENHEIGHT,
    UDS_ALIGNLEFT,
    UDS_ALIGNRIGHT,
    UDS_ARROWKEYS,
    UDS_AUTOBUDDY,
    UDS_HORZ,
    UDS_NOTHOUSANDS,
    UDS_SETBUDDYINT,
    UDS_WRAP,
    SS_NOPREFIX,
    SS_NOTIFY,
    SS_CENTERIMAGE,
    SS_RIGHTJUST,
    SS_REALSIZEIMAGE,
    SS_SUNKEN,
    SS_ENDELLIPSIS,
    SS_PATHELLIPSIS

        }

vWinExFlagValues = {
    WS_EX_ACCEPTFILES,
    WS_EX_APPWINDOW,
    WS_EX_CLIENTEDGE,
    WS_EX_CONTEXTHELP,
    WS_EX_CONTROLPARENT,
    WS_EX_DLGMODALFRAME,
    WS_EX_LEFT,
    WS_EX_LEFTSCROLLBAR,
    WS_EX_LTRREADING,
    WS_EX_MDICHILD,
    WS_EX_NOPARENTNOTIFY,
    WS_EX_OVERLAPPEDWINDOW,
    WS_EX_PALETTEWINDOW,
    WS_EX_RIGHT,
    WS_EX_RIGHTSCROLLBAR,
    WS_EX_RTLREADING,
    WS_EX_STATICEDGE,
    WS_EX_TOOLWINDOW,
    WS_EX_TOPMOST,
    WS_EX_TRANSPARENT,
    WS_EX_WINDOWEDGE,
    WS_EX_LAYERED,
    WS_EX_NOINHERITLAYOUT,
    WS_EX_LAYOUTRTL,
    WS_EX_NOACTIVATE
    }

vControlNames = {
    "WINDOW",
    "PUSHBUTTON",
    "COMMANDBUTTON",
    "BUTTON",
    "DEFPUSHBUTTON",
    "DEFBUTTON",
    "CANCELBUTTON",
    "CHECKBOX",
    "TRICHECKBOX",
    "RADIO",
    "RADIOBUTTON",
    "GROUP",
    "GROUPBOX",
    "LIST",
    "LISTBOX",
    "SORTEDLIST",
    "COMBO",
    "COMBOBOX",
    "SORTEDCOMBO",
    "SIMPLECOMBO",
    "DROPDOWNLIST",
    "EDITTEXT",
    "EDITBOX",
    "TEXTBOX",
    "SLETEXT",
    "MLETEXT",
    "LTEXT",
    "LABEL",
    "RTEXT",
    "CTEXT",
    "HSCROLL",
    "VSCROLL",
    "ICON",
    "BITMAP",
    "MENU",
    "POPUP",
    "MENUITEM",
    "MENUSPACER",
    "PIXMAP",
    "TOOLBAR",
    "STATUSBAR",
    "PICTUREBUTTON",
    "TOGGLEBUTTON",
    "TOGGLEPICTURE",
    "HTRACKBAR",
    "VTRACKBAR",
    "TABCONTROL",
    "TABITEM",
    "PROGRESSBAR",
    "LISTVIEW",
    "IMAGELIST",
    "TREEVIEW",
    "RICHEDIT",
    "MONTHCALENDAR",
    "UPDOWN",
    "REBAR",
    "REBARBAND",
    "TOOLTIP",
    "FLATTOOLBAR",
    "SEPBUTTON",
    "COMBOBOXEX"
        }

vControlTypes = {
    Window,
    PushButton,
    CommandButton,
    Button,
    DefPushButton,
    DefButton,
    CancelButton,
    CheckBox,
    TriCheckBox,
    Radio,
    RadioButton,
    Group,
    GroupBox,
    List,
    ListBox,
    SortedList,
    Combo,
    ComboBox,
    SortedCombo,
    SimpleCombo,
    DropDownList,
    EditText,
    EditBox,
    TextBox,
    SleText,
    MleText,
    LText,
    Label,
    RText,
    CText,
    HScroll,
    VScroll,
    Icon,
    Bitmap,
    Menu,
    Popup,
    MenuItem,
    MenuSpacer,
    Pixmap,
    ToolBar,
    StatusBar,
    PictureButton,
    ToggleButton,
    TogglePicture,
    HTrackBar,
    VTrackBar,
    TabControl,
    TabItem,
    ProgressBar,
    ListView,
    ImageList,
    TreeView,
    RichEdit,
    MonthCalendar,
    UpDown,
    ReBar,
    ReBarBand,
    ToolTip,
    FlatToolBar,
    SepButton,
    ComboBoxEx
        }
vControlRID = repeat(0, length(vControlNames))

vEventNames = {
    "Break",
    "Pause",
    "Mouse",
    "Click",
    "KeyPress",
    "KeyUp",
    "KeyDown",
    "Resize",
    "Change",
    "GotFocus",
    "LostFocus",
    "Scroll",
    "Open",
    "Close",
    "Destroy",
    "Timer",
    "Paint",
    "DragAndDrop",
    "Event",
    "Activate",
    "AfterEvent",
    "DropDown",
    "CloseUp",
    "Idle",
    "Input",
    "GetHandler"
}
vEventNamesUpper = {
    "BREAK",
    "PAUSE",
    "MOUSE",
    "CLICK",
    "KEYPRESS",
    "KEYUP",
    "KEYDOWN",
    "RESIZE",
    "CHANGE",
    "GOTFOCUS",
    "LOSTFOCUS",
    "SCROLL",
    "OPEN",
    "CLOSE",
    "DESTROY",
    "TIMER",
    "PAINT",
    "DRAGANDDROP",
    "EVENT",
    "ACTIVATE",
    "AFTEREVENT",
    "DROPDOWN",
    "CLOSEUP",
    "IDLE",
    "REGION",
    "GETHANDLER",
    "DATACHANGE"
}

vEventCodes = {
    w32HBreak,
    w32HPause,
    w32HMouse,
    w32HClick,
    w32HKeyPress,
    w32HKeyUp,
    w32HKeyDown,
    w32HResize,
    w32HChange,
    w32HGotFocus,
    w32HLostFocus,
    w32HScroll,
    w32HOpen,
    w32HClose,
    w32HDestroy,
    w32HTimer,
    w32HPaint,
    w32HDragAndDrop,
    w32HEvent,
    w32HActivate,
    w32HAfterEvent,
    w32HDropDown,
    w32HCloseUp,
    w32HIdle,
    w32HMouseTrap,
    w32HGetHandler,
    w32HDataChange
}

vWinIconNames = {
    "APPLICATION",
    "ERROR",
    "QUESTION",
    "WARNING",
    "ASTERISK",
    "WINLOGO"
    }

---------------------------
--/topic Defining Controls
--/info
--This section describes how to create windows and the various elements that can appear in them.

--/topic Defining Controls
--/proc newUIObj(sequence Definition)
--/desc Defines a User Interface Object, a.k.a. a Control
--This is a high-level method of defining the attributes of a control
--to be used by your program. It is an interface to the /create() routine.
--
-- /setCallback() is usually used in conjunction with applications that use newUIObj()
--
-- The /i Definition parameter is used to specify a specific type of control
-- to create and its attributes. It consists of one or more parameters that
-- can be expressed in a variety of formats, depending on your preferred
-- way of doing things. However they are all variations on a set of /i "keyword=value"
-- pairs, where the /b key is expresses the type of parameter and the /b value
-- is the parameter's information. /n
--
-- The parameters inside /i Definition can be formed as a 2-element sequence
-- where the first element is the keyword and the second is the information. For
-- example /b'("width", 200)'. The alternative to this is to have the
-- parameter as a string, /b'"width=200"'. In fact, when using the string form
-- you can have multiple parmeters in the same string, eg.
-- /b'"width=200, height=300, left=20, top=35"' with each parmeter delimited
-- by a comma. /n
--So to summarize this, the /i Definition sequence consists of one or more
-- elements, and each element can /b either be a 2-element sequence of
-- (keyword,value) or a string that contains one or more comma delimited
-- 'keyword=value' entries.
--
--All the parameters have a keyword name, which is not case sensitive, meaning
-- that "width=200" and "WIDTH=200" are both acceptable. However, certain
-- parameters can have assumed keyword names if not supplied. The first unnamed
-- parameter is assumed to be the "TYPE" parameter, the second unnamed
-- is assumed to be "CAPTION", and so on for "NAME", "LEFT", "TOP", "WIDTH",
-- "HEIGHT", "FLAGS", and "EXFLAGS" parameters, in that order. If there
-- are still unnamed parameters after all the assumed ones have been
-- allocated, an error message is issued.
--
-- /b"Reference Control"
-- Some of the commands deal with a 'reference control'. By default, this is the previously
-- defined control, but can be explictly named in some cases too.
--
--The keywords supported are ... /n
--/b AT ** This is a shorthand for LEFT=n,TOP=n. It specifies both the left and top position
-- of the control. The format is AT=(leftpos,toppos) where both /i leftpos and /i toppos have the
-- same formats as allowed for /i LEFT= and /i TOP= parameters respectively. /n
--Additionally, if either /i leftpos or /i toppos is omitted, then /i () is assumed
-- for them, meaning that they use the same position as the previous control, respectively.
--Also, if /i leftpos or /i toppos are in the form /i /b"x"nnn where /i x is either '>' or '~<'
-- and /i nnn is a number. The '>' means that the control is positioned /i nnn pixels after
-- the previous control's /i other edge and '~<' means it is positioned /i nnn pixels before
-- the previous control's /i other edge. By " /i other" edge
-- the same as LEFT=(+/-nnn) and TOP=(+/-nnn) respectively. /n
--~s~seg.~s /b "at=(20,10)" --> The control's is positioned at 20 pixels from the left,
--and 10 pixels from the top. /n
--~s~seg.~s /b "at=((3),(0,OtherControl))" --> The control's is positioned at 3 pixels to the left
-- of the previously defined control, and 0 pixels from the bottom a control called "OtherControl". /n
--~s~seg.~s /b "at=(,+4)" --> The control is positioned with the same /i left position as the
-- previous control and 4 pixels below the previous control.
--
--/b BARS or /b BAR ** This only applies to a Window control. It is used to specify any toolbar,
-- scrollbar, and statusbar that the window has.  /n
-- For statusbars, the form is either /i "BAR=status", which will cause a simple statusbar to be defined for
-- the window, or /i "BAR=status=(re1,re2,...)" which specifies the set of /b righthand edge
-- locations for a multi-panel statusbar. /n
-- /i "BAR=(vert,horz)" can be used to specify vertical and horizontal scrollbars for the window /n
-- /i "BAR=toolbar" will define a toolbar, 34 pixels high. /n
-- /i "BAR=flattoolbar" will define a FlatToolbar, high enough for a 32x32 button and text underneath.
-- /b Note that the name assigned to the statusbar, toolbar and flattoolbar will be the name of the Window
-- with "SB", "TB", and "FB" appended respectively.
--
--/b BGCOLOR or /b BGCOLOUR ** This specifies the background color for the control. Note that
-- some types of controls, for example Buttons, cannot have their background changed by this method.
--
-- It can take one of three forms: A single RGB value, the name of one of the predefined colors, or
-- a list of three color values from 0 - 255.
--
--Example:
--   BGCOLOR=1188733
--   BGCOLOR=Purple
--   BGCOLOR=(#70,#80,#FF)
--
--/b BOTTOM ** This specifies the bottom edge position of the control. You
-- would only specify either TOP or BOTTOM, but if you did use both, then the
-- BOTTOM specification takes precedence. /n
--~s~seg.~s /b "bottom=20" --> The control's bottom edge is 20 pixels above it's
-- container's bottom edge.
--
--/b BUDDY ** This only applies to an UpDown control. It specifies the 'buddy' control that
-- is linked to the UpDown control being defined.
--
--/b CAPTION or /b TEXT ** Specifies the control's initial display value. If
-- the value is not enclosed in () then it is trimmed of leading and
--trailing spaces. And note that if the value has any commas, it must be
--enclosed in (). /n
--~s~s~seg.~s /b <"caption= Customer's Name: "> --> The spaces are trimmed to
-- produce a value of "Customer's Name:". /n
--~s~s~seg.~s /b <"caption=( Customer's Name: )"> --> The spaces are not trimmed to
-- produce a value of " Customer's Name: ". /n
--~s~s~seg.~s /b <"caption=(Hello, world!)"> --> The text value has an embedded
-- comma so is enclosed in (). /n
--~s~s~seg.~s /b <"caption=Hello, world!"> --> This example shows why the ()
-- are needed for text that as commas. Without the enclosing () this would
-- produce the value "Hello" and the "world!" would be interpreted as an
-- unknown keyword. /n
--
--It is also possible to look up caption text from an external file. If the
-- caption parameter has the form /b'"caption=~<HW>"', the library looks
-- for the "HW" key in the messages text file. Unless changed by /setMsgFile
--this is "msgs.ini" in the current folder. Also, unless changed by
-- /setUserLanguage, this looks in the [english] section of the messages file. /n
--Thus if the messages file looked like ...
--
--/code
--    [english]
--    HW = Hello World
--    [francais]
--    HW = Bonjour Monde
--/endcode
--
-- and the user's language was 'francais' then the above caption example
-- would be equivalent to /b<"caption=Bonjour Monde">
--
-- A special format is available to load a combo or list control with its
--initial set of list items. To do this, the keyword and value must use the
-- 2-element sequence form rather than the simple string form. /n
--~s~seg.~s /b <("text", ("item1","item2","item3"))> --> causes the three
-- items to be loaded as the initial list values. /b Note that this only applies
-- to /i combo and /i list type of controls. /n
--
--/b CHECK or /b CHECKED ** This specifies whether or not the control is initially checked. It
-- has the form of check=~<setting>, where ~<setting> can be one of Yes, w32True, 1, or On
-- to set it to checked, or anything else to uncheck it. /n
--~s~seg.~scheck=no
--
--/b COLUMNS or /b COLUMN ** This specifies the column headings, widths, and alignment for
-- ListView controls. This takes the form of a list of column definitions enclosed in braces. Each
-- column definition is a set of one, two, or three elements enclosed in braces. The elements
-- are a column header (text), a column width (integer) and an alignment keyword - /b left,
-- /b center, and /b right. You can also use the characters ~<, ^, >, for left, center and right
-- respectively. /n
-- Example: columns=((First Name, 80, ~<), (Surname, 110, ~<), (Age, 30, >), (Status, 40, ^)) /n
-- Note that if you specify ListView columns, the flag LVS_REPORT is automatically added.
--
--/b DELTA ** This specifies the increments for scrollbars. It takes the form of
-- delta=(small,large). /n
--~s~seg.~sdelta=(1,15) /n
--
--/b ENABLE or /b ENABLED ** This specifies whether or not the control is initially enabled. It
-- has the form of enable=~<setting>, where ~<setting> can be one of Yes, w32True, 1, or On
-- to set it to enabled, or anything else to disable it. /n
--~s~seg.~senable=no
--
--/b EVENTS or /b EVENT ** This specifies one or more events that the control expects your application
-- to provide handlers for. It takes the form of a list of event names or 2-element sets of the
-- form (eventname, eventhandler_name). /n
--Example:
--
--  event=((click,ShowCustomer)) /n
--  event=(mouse,keypress)
--
--Some controls always assume certain events even if you don't specify them here. /n
--/li Button-type controls, Statusbar and MenuItems always assume a w32HClick event.
--/li HScroll, VScroll, HTrackBar, VTrackBar, ProgressBar, and UpDown
--controls always assume a w32HScroll event.
--/li Window controls always assume w32HScroll, w32HPaint, w32HOpen, w32HActivate, w32HResize, and
-- w32HClose events.
--
-- All this means is that for these control types, you do not have to explicitly add these event
-- types as they will be automatically assumed.
--
-- The suggested naming convention for event handlers is ~<eventname>_~<controlname>, for example
-- a control called "Go Button" that invokes the w32HClick event, the suggested handler name
-- would be "Click_GoButton"
--
-- When the application starts and if an event resolution callback routine has been supplied,
-- Win32lib calls the event resolution callback routine for each event specified in this parameter.
-- This callback routine is expected to return a routine_id that will handle any events for the
-- control. /n
--/code
--  procedure AppCallback(integer self, integer event, sequence parms)
--      -- self is the control's id value
--      -- event can be w32HGetHandler, in which case ...
--          -- parms[1] is the routine handler name
--          -- if a handler name is not supplied then this
--          -- is in the form ~<eventname>_~<controlname>
--          -- eg. "Click_PushBtn"
--          -- parms[2] is the event code to be handled
--          -- eg. w32HClick
--          -- parms[3] is the control's name
--          -- eg. "PushBtn"
--
--      if event = w32HGetHandler then
--          returnValue(routine_id(parms[1]))
--      end if
--  end procedure
--  startApp(routine_id("AppCallback"))
--/endcode
--
--/b EXFLAGS or /b EXFLAG ** This is similar to the FLAGS keyword but /i only
-- applies to the extended flag values. Its primary usage is for when you need to
-- replace the default extended flags with the ones you enter with this keyword.
--
--~s~seg.~sflags=(NEW, WS_EX_CLIENTEDGE) -- Replaces the default extended flags /n
--~s~s~s~s~s~s~sflags=WS_EX_CLIENTEDGE -- combined with default flags.
--
--/b FGCOLOR or /b FGCOLOUR ** This specifies the text (foreground) color for the control. Note that
-- some types of controls, for example Buttons, cannot have their text color changed by this method.
--
-- It can take one of three forms: A single RBG value, the name of one of the predefined colors, or
-- a list of three color values from 0 - 255.
--
--Example:
--   FGCOLOR=1188733
--   FGCOLOR=Purple
--   FGCOLOR=(#70,#80,#FF)
--
--/b FLAGS or /b FLAG ** This specifies one or more flag values used to
-- create the control. If you need more than one flag value, you must enclose
-- all the values in matching () and separate the values with commas. Normally
-- the values are combined with a control's default flags but if you need to
-- replace the default flags, include the special value 'NEW' in the list
-- of flag values. Note that you can freely intermix normal flags with extended
-- flags. /n
--~s~seg.~sflags=(NEW, WS_VISIBLE, WS_POPUP, WS_BORDER, WS_EX_CLIENTEDGE) /n
--~s~s~s~s~s~s~sflags=SS_NOTIFY /n
-- If you specify WS_CHILD and do not specify a parent control, the most recent
-- Window is used as the parent control.
--/b POSITION ** This specifies the initial position of the thumb in scrollbars. /n
--~s~seg.~sposition=10
--
--/b FONT ** This specifies the font to use for the control. It takes the form
-- FONT=(fontname, size, style)
--
--/b FROM ** The specifies the reference control to use with subsequent commands for
-- the current control definition. This is a control that is the basis for the
-- relative values in any LEFT, TOP, WIDTH, and HEIGHT parameters for this control.
-- Normally, these values are relative to the previously defined control, but
-- sometimes you may need to override that.
--
-- Example: FROM=Go Button, left=(5), top=() /n
-- which means that the control being defined starts 5 pixels to the left of the Go Button
-- and has the same 'top' value as the go button.
--
-- This is really a shorthand because the same effect could be achieved by doing ... /n
-- left=(5,Go Button), top=(0,Go Button,) /n
--
--/b HEIGHT ** This specifies the height of the control. It has three basic forms, a simple
-- value that is the absolute height, a percentage value that is relative to the control's
-- container, and a specification that is relative to another control. /n
-- Some examples... /n
--~s~seg.~s /b"height=400" --> Exactly 400 pixels high. /n
--~s~seg.~s /b"height=400pxl" --> Just an alternative to above, exactly 400 pixels high. /n
--~s~seg.~s /b"height=100char" --> Exactly 100 characters high. The exact pixel value depends on the font
-- set for the control. /n
--~s~seg.~s /b"height=40%" --> 40 percent of the container's height. /n
--~s~seg.~s /b"height=CustName+10" --> The height is calculated as 'CustName' height + 10 pixels /n
--~s~seg.~s /b"height=CustName*2" --> The height is calculated as 'CustName' height * 2 /n
--~s~seg.~s /b"height=CustName" --> The height is calculated as the same as 'CustName' height /n
--~s~seg.~s /b"height=CustName*90%" --> The height is calculated as 'CustName' height * 0.9 /n
--~s~seg.~s /b"height=*" --> The height is the same the current reference control's height. /n
--~s~seg.~s /b"height=*-5" --> The height is calculated as the current reference control's height less 5 pixels/n
--~s~seg.~s /b"height=**0.5" --> The height is calculated as half the current reference control's height. /n
--The examples above talk about a /i "current reference control". This is the control used
-- as a reference point in WIDTH, HEIGHT, TOP and LEFT parameters when no explicit control
-- is named in those parameters. You can set the current reference control by using the FROM
-- parameter, otherwise it is the control that was most recently defined before the current one.
--
--/b "Note:" If you specify /b more than one height parameter in a control's definition,
-- the values accumulate. Thus if you need a control to be half the height of another control
-- plus 3 pixels you would specify "height=OtherControl*0.5,height=3", or if you need the
-- sum of two other controls, "height=CTRL1,height=CTRL2"
--
--/b IMAGE ** This specifies an image to be used with Window, Icon and Bitmap controls. For
-- Bitmaps it must be the name of a ".BMP" file and for Windows and Icon controls, it can be either
-- an ".ICO" file or a predefined MS-Windows name "APPLICATION", "ERROR", "QUESTION", "WARNING",
-- "ASTERISK", or "WINLOGO".
--
--/b INITIALFOCUS ** This indicates that the control is the one that has the initial focus
-- when the form is opened.  It has the form of initialfocus=~<setting>, where ~<setting> can be
-- one of Yes, 1, or On to set it, or anything else to unset it. /n
--
--/b LEFT ** This specifies the left edge position of the control. It has four forms, a simple
-- value that is the absolute position, a percentage value that is relative to the control's
-- container's width, the word 'Center', and one that is relative to another control. /n
-- Some examples... /n
--~s~seg.~s /b"left=400" --> Exactly 400 pixels. /n
--~s~seg.~s /b"left=400pxl" --> Just an alternative to above, exactly 400 pixels. /n
--~s~seg.~s /b"left=100char" --> Exactly 100 characters. The exact pixel value depends on the font
-- set for the container control. /n
--~s~seg.~s /b"left=40%" --> 40 percent of the container's width. /n
--~s~seg.~s /b"left=center" --> The control is centered horizontally in its container. /n
--~s~seg.~s /b"left=CustName" --> The left is calculated as the same as 'CustName' right. /n
--~s~seg.~s /b"left=CustName+10" --> The left is calculated as 'CustName' right + 10 pixels. /n
--~s~seg.~s /b"left=CustName*" --> The left is calculated as 'CustName' left. /n
--~s~seg.~s /b"left=CustName*+10" --> The left is calculated as 'CustName' left + 10. /n
--~s~seg.~s /b"left=*" --> The left is calculated as the current reference control's right /n
--~s~seg.~s /b"left=*+5" --> The left is calculated as the current reference control's right + 5 /n
--~s~seg.~s /b"left=**" --> The left is the same the current reference control's left. /n
--The examples above talk about a /i "current reference control". This is the control used
-- as a reference point in WIDTH, HEIGHT, TOP and LEFT parameters when no explicit control
-- is named in those parameters. You can set the current reference control by using the FROM
-- parameter, otherwise it is the control that was most recently defined before the current one.
--
--/b "Note:" If you specify more than one left parameter in a control's definition,
-- the values /b "do not" accumulate. Instead, the last /i "left=" parameter is used.
--
--/b MEMBER ** This specifies the ControlSet that the new control will belong to. Its value
-- must be a positive integer. See /showControlSet and /setControlSet for details about
-- control sets. /n
-- Example: MEMBER=2
--
--Example:
--/code
--      procedure Click_AcceptForm(integer self, integer event, sequence parms)
--          -- code to handle the user pressing the Accept Form button.
--          . . .
--      end procedure
--
--      procedure AppCallback(integer self, integer event, sequence parms)
--          if event = w32HGetHandler then
--              returnValue(routine_id(parms[1]))
--          end if
--      end procedure
--
--      newUIObj(("Window,Main Window", "width=400,height=50%"))
--      newUIObj("LText, at=(5,5),caption=Name:")
--      newUIObj(("EditText, UserName", "left=(),top=(0),width=20char"))
--      newUIObj(("Button,AcceptForm", "left=5,bottom=5,height=40",
--                                     "caption=&Accept"))
--      newUIObj(("List,Devices,left=100, top=5, height=4char",
--                ("text", ("Tape","DVD","Disk","Printer")),
--                "events=(Click,change)")
--      prevValue = setCallback(routine_id("AppCallback"))
--      . . .
--/endcode
--
--/b NAME ** Each control created by newUIObj should have a unique name. The name can
--have any character in it however all but alphabetic characters, digits and the
--underscore character are stripped out of the supplied name. Also, any leading
--digits are stripped out. For example, if you had used /b"NAME=(Customer's Name)"
--then the actual stored name would be /b"CustomersName"
--
--If no /i name parameter is supplied, the control's caption, if supplied is used. And
--if neither /i name or /i caption is supplied, the control's name is set to /b NoName~<id>,
--where ~<id> is the control's Id number.
--
--You can always change a control's name with the /setIdName() routine, and fetch a control's
--name with /getIdName()
--
--/b OWNER or /b PARENT ** This specifies the parent control, also known as 'owner', of the control
-- being defined. It can be either the name of a control or the actual control id value.
-- Most of the time this is not required as the default parent is sufficient. /n
-- The default parent is determined as ... /n
-- If the control is a MenuItem or MenuSpacer then the most recently defined menu, otherwise if the control
-- is a TabItem, the most recently defined TabControl, otherwise if the control is a ReBarBand then
-- the toolbar attached to the most recently defined window, otherwise if the control is /b not
-- a Window and not a Pixmap then the most recently defined Window, TabItem or Group, otherwise
-- the main window.
--
-- /b See the keyword '*' for details about how to change the default parent id.
--
--/b POINTER ** This specifies the shape of the mouse pointer when it is over this control. It
-- can specify either a cursor file (.CUR or .ANI) or one of the system predefined shapes. See
-- /setMousePointer for more details. /n
-- Example:   POINTER=SizeWE
--
--/b POPUP ** This specifies the menu(s) that will popup when the user presses the
-- righthand mouse button in this control. It takes the form of
-- POPUP=(normal,shift,control,shift-control) where 'normal','shift', 'control', and
-- 'shift-control' are the names of menus that will popup in combination of the Righthand mouse
-- button being pressed and No-Control-Shift, Shift, Control, and Shift-Control keys
-- being held down respectively. /n
-- If any of these names are omitted, the corresponding combination is not set. Thus to
-- set popup menus for only the Normal and Control key combinations, use /n
-- something like POPUP=(NormalPopup,,ControlPopup)
--
--/b PRAGMA ** This is a /i directive type command and does not actually create a control. It can
-- only have the value 'PARENT' for now. This will cause the named control to become the
-- default parent for subsequent controls being created in the form. /n
-- This is typically used after the last control in a Group control has been defined, or
-- after the last menu item in a sub-menu has been defined. /n
-- Example:  "Window,name=MainWin,pragma=PARENT" says that 'MainWin' is the new default Window. /n
-- Example:  "Menu,name=FileMenu,pragma=PARENT" says that 'FileMenu' is the new default Menu. /n
--
--/b RANGE ** This specifies the minimum and maximum values for scrollbars,
--progressbars and UpDown controls. It takes the form of range=(lower,upper). /n
--~s~seg.~srange=(4,1200)
--
--/b RIGHT ** This specifies the right edge position of the control. You
-- would only specify either LEFT or RIGHT, but if you did use both, then the
-- RIGHT specification takes precedence. /n
--~s~seg.~s /b "right=20" --> The control's right edge is 20 pixels to the left
-- of it's container's right edge.
--
--/b SIZE ** This is a shorthand for WIDTH=n,HEIGHT=n. It specifies both the width and height
-- of the control. The format is SIZE=(width,height) where both /i width and /i height have the
-- same formats as allowed for /i WIDTH= and /i HEIGHT= parameters respectively. /n
--Additionally, if either /i width or /i height is omitted, then /i () is assumed
-- for them, meaning that they use the same dimensions as the reference control, respectively.
--Also, if /i width or /i height are in the form ?+nnn or ?-nnn this is taken to be
-- the same as WIDTH=(+/-nnn) and HEIGHT=(+/-nnn) respectively. /n
--~s~seg.~s /b "size=(100,200)" --> The control's is 100 pixels wide, and 200 pixels high. /n
--~s~seg.~s /b "size=(,?-15)" --> The control is the same /i width as the
-- reference control and 15 pixels shorter the reference control.
--
--There are some special forms of /b size. /n
-- /b "size=()" means that the width and height of this control is
-- the same as the respective values of the reference control (usually the previously defined
-- control). /n
--/b "size=maximum" means that when this window is first opened, it will be maximized. /n
--/b "size=minimum" means that when this window is first opened, it will be minimized. /n
--/b "size=~<cntrl>" where ~<cntl> is the name of a control previously defined in this form./n
--/b "size=?" which makes this new control the same size as the reference control./n
--
--/b TAG ** This is a general purpose value that can be attached to any control.
-- Win32lib does not use this in any way at all. It is in fact a shorthand for
-- adding a User Defined Property called "Tag" to the control. You would get and
-- set the Tag value using the /getUserProperty(cntrl, "Tag") and
-- /setUserProperty(cntrl, "Tag", newvalue). /n
--~s~seg.~stag=Special
--
--/b TOOLTIP or /b HINT ** This specifies the hint text for a control. If the text has an embedded
-- comma, it must be enclosed in braces eg. HINT=(This has a, comma in it)
--
--/b TOP ** This specifies the top edge position of the control. It has four forms, a simple
-- value that is the absolute position, a percentage value that is relative to the control's
-- container's height, the word 'Center', and one that is relative to another control. /n
-- Some examples... /n
--~s~seg.~s /b"top=400" --> Exactly 400 pixels. /n
--~s~seg.~s /b"top=400pxl" --> Just an alternative to above, exactly 400 pixels. /n
--~s~seg.~s /b"top=100char" --> Exactly 100 characters. The exact pixel value depends on the font
-- set for the container control. /n
--~s~seg.~s /b"top=40%" --> 40 percent of the container's height. /n
--~s~seg.~s /b"top=center" --> The control is centered vertically in its container. /n
--~s~seg.~s /b"top=CustName" --> The top is calculated as the same as 'CustName' bottom. /n
--~s~seg.~s /b"top=CustName+10" --> The top is calculated as 'CustName' bottom + 10 pixels. /n
--~s~seg.~s /b"top=CustName*" --> The top is calculated as 'CustName' top. /n
--~s~seg.~s /b"top=CustName*+10" --> The top is calculated as 'CustName' top + 10. /n
--~s~seg.~s /b"top=*" --> The top is the same the current reference control's bottom. /n
--~s~seg.~s /b"top=*+5" --> The top is calculated as the current reference control's bottom + 5 /n
--~s~seg.~s /b"top=**" --> The top is the same the current reference control's top. /n
--The examples above talk about a /i "current reference control". This is the control used
-- as a reference point in WIDTH, top, TOP and LEFT parameters when no explicit control
-- is named in those parameters. You can set the current reference control by using the FROM
-- parameter, otherwise it is the control that was most recently defined before the current one.
--
--/b "Note:" If you specify more than one top parameter in a control's definition,
-- the values /b "do not" accumulate. Instead, the last /i "top=" parameter is used.
--
--/b TYPE ** This specifies the type of control you are defining. If omitted, and
-- there are no 'unnamed' parameters, the default type is LText. If you specify an
-- unknown type, an error is generated.
--If you are using the /i "/b events" /i Parameter, you will also have to
-- use either the /setCallback or /startApp routine in your program. /n
-- If the /i type is a Window and a window has already been defined, then this new
-- window will be forced into being a child window.
--
--/b USER ** This is similar to TAG but can be used to add any user defined property
-- to the control. It takes the form of user=(PropertyName, PropertyValue). /n
--~s~seg.~suser=(DefaultColor, #308817) /n
--
--/b VISIBLE ** This specifies whether or not the control is initially visible. It
-- has the form of visible=~<setting>, where ~<setting> can be one of Yes, w32True, 1, or On
-- to set it to visible, or anything else to hide it. /n
--~s~seg.~svisible=off
--
--/b WIDTH ** This specifies the width of the control. It has three basic forms, a simple
-- value that is the absolute width, a percentage value that is relative to the control's
-- container, and a specification that is relative to another control.
-- Some examples... /n
--~s~seg.~s /b"width=400" --> Exactly 400 pixels wide. /n
--~s~seg.~s /b"width=400pxl" --> Just an alternative to above, exactly 400 pixels wide. /n
--~s~seg.~s /b"width=100char" --> Exactly 100 characters wide. The exact pixel value depends on the font
-- set for the control. /n
--~s~seg.~s /b"width=40%" --> 40 percent of the container's width. /n
--~s~seg.~s /b"width=CustName+10" --> The width is calculated as 'CustName' width + 10 pixels /n
--~s~seg.~s /b"width=CustName*2" --> The width is calculated as 'CustName' width * 2 /n
--~s~seg.~s /b"width=CustName" --> The width is calculated as the same as 'CustName' width /n
--~s~seg.~s /b"width=CustName*90%" --> The width is calculated as 'CustName' width * 0.9 /n
--~s~seg.~s /b"width=*-5" --> The width is calculated as the current reference control's width less 5 pixels /n
--~s~seg.~s /b"width=**0.5" --> The width is calculated as half the current reference control's width. /n
--~s~seg.~s /b"width=*" --> The width is the same the current reference control's width. /n
--The examples above talk about a /i "current reference control". This is the control used
-- as a reference point in WIDTH, HEIGHT, TOP and LEFT parameters when no explicit control
-- is named in those parameters. You can set the current reference control by using the FROM
-- parameter, otherwise it is the control that was most recently defined before the current one.
--
--/b "Note:" If you specify more than one WIDTH parameter in a control's definition,
-- the values accumulate. Thus if you need a control to be half the width of another control
-- plus 3 pixels you would specify "width=OtherControl*0.5,width=3", or if you need the
-- sum of two other controls, "width=CTRL1,width=CTRL2"
--

sequence vRecentNewUI vRecentNewUI = {}

global procedure newUIObj( object pParms)
    integer i
    integer incr
    integer lType
    integer lID
    sequence lCaption
    object lOwner
    object lLeft, lTop, lWidth, lHeight
    object lDefLeft, lDefTop, lDefWidth, lDefHeight
    object lFlags, lExFlags, lLVExFlags
    sequence lKey
    sequence lKeyValue
    integer lPos
    object lData
    object lTemp
    atom lSizeInc
    object lUpperData
    object lNumData
    object lTooltip
    integer lAutoClose
    sequence lChar
    integer lCharSize
    sequence lTE
    sequence lParentRect
    sequence lFont
    sequence lFormattedFont
    integer lResize
    sequence lEnable
    sequence lVisible
    sequence lCheck
    sequence lEventList
    integer lParent
    sequence lName
    sequence lRefControl
    sequence lUserProp
    sequence lScrollRange
    sequence lScrollChange
    object lScrollPosition
    object lImage
    object lBGColor
    object lFGColor
    object lStatusBar
    object lToolbar
    object lFlatToolbar
    integer lNewFlag
    integer lNewExFlag
    object lRight
    object lBottom
    object lReBarBand
    sequence lAssumedKeys
    integer lAKPosn
    sequence lText
    object lPointer
    integer lBuddy
    object lDirective
    integer lBarId
    object lAttachPopup
    integer lSetMember
    sequence lLVColumns
    sequence lCTitle
    atom  lCWidth
    atom  lCAlign
    sequence lFlds
    sequence lButtons
    integer lInitView
    sequence lIFOptions
    integer lInitFocus

    if sequence(pParms) and length(pParms) = 0 then
        return
    end if

    lType = LText
    lTooltip = ""
    lCaption = ""
    lOwner = {}
    lWidth = {}
    lHeight = {}
    lLeft = {}
    lTop = {}
    lFlags = 0
    lExFlags = 0
    lLVExFlags = 0
    lAutoClose = w32False
    lFont = ""
    lResize = w32False
    lCheck = {w32False,0}
    lEnable = {w32False,0}
    lVisible = {w32False,0}
    lEventList = {}
    lName = ""
    lReBarBand = {}
    lRefControl = {}
    lUserProp = {{},{}}
    lScrollRange ={}
    lScrollChange = {}
    lScrollPosition = {}
    lImage = {}
    lBGColor = {}
    lFGColor = {}
    lStatusBar = {}
    lToolbar = {}
    lFlatToolbar = {}
    lNewFlag = w32False
    lNewExFlag = w32False
    lRight = {}
    lBottom = {}
    lAssumedKeys = {"TYPE","CAPTION","NAME","LEFT","TOP","WIDTH","HEIGHT","FLAGS","EXFLAGS"}
    lText = {}
    lPointer = {}
    lBuddy=0
    lDirective=0
    lBarId = 0
    lAttachPopup = 0
    lSetMember = 0
    lLVColumns = ""
    lButtons = {}
    lInitView = 0
    lChar = repeat(w32False, 2)
    lIFOptions = {}
    lAKPosn = 0
    lInitFocus = 0

    -- Extract the key/value pairs from the parms.
    if w32string(pParms) then
        if length(pParms) > 0 and find(pParms[1], ";`~|#/\\-_^*@,") then
            lTemp = pParms[1]
            pParms = pParms[2..length(pParms)]
        else
            lTemp = ','
        end if
        pParms = w32MakeArgs(pParms,lTemp, '=')
    -- Check for string fragments
    elsif sequence(pParms) then
        lPos = 1
        while lPos <= length(pParms) do
            if w32string(pParms[lPos]) then
                if length(pParms[lPos]) > 0 and find(pParms[lPos][1], ";`~|#/\\-_^*@,") then
                    lTemp = pParms[lPos][1]
                    pParms[lPos] = pParms[lPos][2..length(pParms[lPos])]
                else
                    lTemp = ','
                end if
                lTE = w32MakeArgs(pParms[lPos], lTemp, 0)
                if length(lTE) > 0 then
                    pParms = pParms[1..lPos-1] & lTE & pParms[lPos+1..length(pParms)]
                    lPos += length(lTE) - 1
                end if
            end if
            lPos += 1
        end while
    else
        warnErr(sprintf("Bad newUIObj() parameter %d\n" &
                        "Last good one was '%s'\n" &
                        "Parameter was not a sequence/string.",{pParms,vRecentNewUI}))
        return
    end if

    -- Start processing the parms.
    i = 1
    incr = 1
    while i <= length(pParms) do
        lKeyValue = pParms[i]
        incr = 1
        lCharSize = w32False

        if sequence(lKeyValue) and length(lKeyValue) = 2 then
            if w32string(lKeyValue[1]) then
                lKey = upper(w32trim(lKeyValue[1]))
                lData = lKeyValue[2]
                if length(lKey) = 0 then
                    -- No keyword, so get the next assumed one.
                    lAKPosn += 1
                    if lAKPosn <= length(lAssumedKeys) then
                        lKey = lAssumedKeys[lAKPosn]
                        if equal("TYPE", lKey) then
                            if sequence(lData) then
                                lType = w32lookup(upper(w32trim(lData)), vControlNames, vControlTypes)
                            else
                                lType = lData
                            end if

                            if lType < 1 or lType > length(vControlTypes) then
                                lType = Label
                                lAKPosn += 1
                                lKey = lAssumedKeys[lAKPosn]
                            end if
                            lData = {lType}
                        end if


                    else
                        -- Too many assumed keys used, so ignore it.
                        warnErr(sprintf("Bad newUIObj() parameter %d\n" &
                                        "Last good one was '%s'\n" &
                                        "Too many assumed keys used.",{i,vRecentNewUI}))
                        return
                    end if
                end if

            else
                -- Badly formed parm so ignore it.
                warnErr(sprintf("Bad newUIObj parameter %d\n" &
                             "Last good one was '%s'\n" &
                       "The key name in a 2-element key/value is not a string.",
                        {i,vRecentNewUI}))
                return
            end if

        else
            -- Wrongly formatted parameter, so ignore it.
            warnErr(sprintf("Bad newUIObj parameter %d\n" &
                             "Last good one was '%s'\n" &
                       "Wrongly formatted parameter.",
                        {i,vRecentNewUI}))
            return
        end if

        if atom(lData) then
            lData = {lData}
        end if
        for j = 1 to length(lData) do
            if sequence(lData[j]) and length(lData[j]) = 2 and
               sequence(lData[j][w32AKey]) and length(lData[j][w32AKey]) = 0
                then
                lData[j] = lData[j][w32AValue]
            end if
        end for

        if not find(lKey, {"CAPTION","TEXT","NAME"} ) then
            if length(lData) = 1 then
                if sequence(lData[1]) and length(lData[1]) > 0  then
                    -- See if its convertable to a number.
                    if length(lData[1]) = 2 and atom(lData[1][1]) and w32string(lData[1][2]) then
                        -- Already split out into a numeric plus modifier.
                        lTE = ' ' & upper(lData[1][2])
                        lNumData = {lData[1][1], 2}
                    else
                        -- Convert to a number plus optional modifier.
                        lTE = upper(w32trim(lData[1]))
                        lNumData = w32TextToNumber({lTE,w32True})
                    end if

                    if lNumData[2] = 0 then
                        -- Yes, it converted nicely.
                        lData[1] = lNumData[1]

                    elsif lNumData[2]>1 then
                        if equal(lData[1][lNumData[2]], "%") then
                            lData[1] = lNumData[1] / 100
                        elsif match("CH", lTE) = lNumData[2] then
                            lCharSize = w32True
                            lData[1] = lNumData[1]
                        elsif match("PX", lTE) = lNumData[2] then
                            lData[1] = lNumData[1]
                        elsif match("PIX", lTE) = lNumData[2] then
                            lData[1] = lNumData[1]
                        end if

                    end if
                end if
            end if
        end if

        if equal(lKey, "FLAGS") or equal(lKey, "FLAG") then
            lKey = "FLAGS" -- Standardize
            if atom(lData) then
                lFlags = or_bits(lFlags,lData)
            else
                if w32string(lData) then
                    lData = {lData}
                end if
                for j = 1 to length(lData) do
                    lUpperData = upper(w32trim(lData[j]))
                    if equal(lUpperData,"NEW") then
                        lNewFlag = w32True
                    else
                        if equal(lUpperData,"AUTOCLOSE") or equal(lUpperData,"W32AUTOCLOSE") then
                            lAutoClose = w32True
                        else
                            lFlags = or_bits(lFlags, w32lookup(lUpperData, vWinFlagNames, vWinFlagValues))
                            lExFlags = or_bits(lExFlags, w32lookup(lUpperData, vWinExFlagNames, vWinExFlagValues))
                            lLVExFlags = or_bits(lLVExFlags, w32lookup(lUpperData, vLVExFlagNames, vLVExFlagValues))
                        end if
                    end if
                end for
            end if

        elsif equal(lKey, "EXFLAGS") or equal(lKey, "EXFLAG") then
            lData = lData[1]
            lKey = "EXFLAGS" -- Standardize
            if atom(lData) then
                lExFlags = or_bits(lExFlags,lData)
            else
                if w32string(lData) then
                    lData = {lData}
                end if
                for j = 1 to length(lData) do
                    lUpperData = w32trim(lData[j])
                    if equal(lUpperData,"NEW") then
                        lNewExFlag = w32True
                    else
                        lExFlags = or_bits(lExFlags, w32lookup(lUpperData, vWinExFlagNames, vWinExFlagValues))
                        lLVExFlags = or_bits(lLVExFlags, w32lookup(lUpperData, vLVExFlagNames, vLVExFlagValues))
                    end if
                end for
            end if

        elsif equal(lKey, "TAG") then
            lData = lData[1]
            lPos = find("Tag", lUserProp[1])
            if lPos = 0 then
                lUserProp[1] = append(lUserProp[1], "Tag")
                lUserProp[2] = append(lUserProp[2], 0)
                lPos = length(lUserProp[1])
            end if

            lUserProp[2][lPos] = lData

        elsif equal(lKey, "USER") then
            -- grab the property name and value
            if length(lData) = 1 then
                lData = {lData[1], ""}
            end if
            lData[1] = w32trim(lData[1])
            lPos = find(lData[1], lUserProp[1])
            if lPos = 0 then
                lUserProp[1] = append(lUserProp[1], lData[1])
                lUserProp[2] = append(lUserProp[2], 0)
                lPos = length(lUserProp[1])
            end if
            lData[2] = w32trim(lData[2])
            if w32string(lData[2]) then
                lNumData = w32TextToNumber({lData[2],w32True})
                if lNumData[2] = 0 then
                    -- Yes, it converts nicely.
                    lData[2] = lNumData[1]
                end if
            end if
            lUserProp[2][lPos] = lData[2]

        elsif equal(lKey, "RANGE") then
            if length(lData) >= 2 and length(lData) <= 3 then
                lScrollRange = lData
            end if


        elsif equal(lKey, "DELTA") then
            if length(lData) = 2 then
                lScrollChange = lData
            end if

        elsif equal(lKey, "POSITION") then
            lScrollPosition = lData[1]

        elsif equal(lKey, "TYPE") then
            if length(lData) != 1 then
                lType = 0
            else
                lData = lData[1]
                if sequence(lData) then
                    lType = w32lookup(upper(w32trim(lData)), vControlNames, vControlTypes)
                else
                    lType = lData
                end if

            end if
            if lType < 1 or lType > length(vControlTypes) then
                warnErr(sprintf("Bad newUIObj() parameter %d\n" &
                                "Last good one was '%s'\n" &
                                "Unknown control TYPE specified.",{i,vRecentNewUI}))

                return
            end if

            if lType = Window then
                lDefLeft = Default
                lDefTop = Default
                lDefWidth = lWidth
                lDefHeight = lHeight
            else
                lDefLeft = 5
                lDefTop  = 5
                lDefWidth = lWidth
                lDefHeight = lHeight
            end if

            if find(lType, {Menu,MenuItem,MenuSpacer,Popup,TabItem,StatusBar}) then
                lDefWidth = 0
                lDefHeight = 0
                lDefLeft = 0
                lDefTop = 0
            elsif find(lType, {ReBar,ReBarBand,Pixmap}) then
                lDefWidth = 1
                lDefHeight = 1
                lDefLeft = 0
                lDefTop = 0
            end if

            if equal(lLeft,"") then
                lLeft = lDefLeft
            end if
            if equal(lTop,"") then
                lTop = lDefTop
            end if
            if equal(lWidth,"") then
                lWidth = lDefWidth
            end if
            if equal(lHeight,"") then
                lHeight = lDefHeight
            end if

        elsif equal(lKey, "CHECK") or equal(lKey, "CHECKED") then
            lData = lData[1]
            if atom(lData) then
                lCheck = {w32True,(lData != 0)}
            elsif length(lData) = 0 then
                lCheck = {w32True,w32True}
            elsif equal(upper(lData), "ON") then
                lCheck = {w32True,w32True}
            else
                lCheck = {w32True, (find(lData[1],"YT1yt"))}  -- Yes True 1
            end if

        elsif equal(lKey, "ENABLE") or equal(lKey, "ENABLED") then
            lData = lData[1]
            if atom(lData) then
                lEnable = {w32True,(lData != 0)}
            elsif length(lData) = 0 then
                lEnable = {w32True,w32True}
            elsif equal(upper(lData), "ON") then
                lEnable = {w32True,w32True}
            else
                lEnable = {w32True, (find(lData[1],"YT1yt"))}  -- Yes True 1
            end if

        elsif equal(lKey, "VISIBLE") then
            lData = lData[1]
            if atom(lData) then
                lVisible = {w32True,(lData != 0)}
            elsif length(lData) = 0 then
                lVisible = {w32True,w32True}
            elsif equal(upper(lData), "ON") then
                lVisible = {w32True,w32True}
            else
                lVisible = {w32True, (find(lData[1],"YT1yt"))}  -- Yes True 1
            end if

        elsif equal(lKey, "WIDTH") then
            -- =num      {num}
            -- =*        {"*"}
            -- =*-num    {"*-num"}
            -- =fld      {"fld"}
            -- =fld-num  {"fld-num"}
            -- =fld-fld  {"fld-fld"}
            -- =-fld     {"-fld"}
            lChar[1] = lCharSize
            lSizeInc = 0
            if equal(lWidth,"") then
                lWidth = 0
            end if
            if length(lData) = 1 then
                lData = lData[1]
            end if
            if sequence(lData) then
                lPos = 0 -- zero means add, 1 means multiply, -1 means subtract.
                -- Relative to another control.
                if length(lData) = 0 then
                    lData = "*"
                end if
                if equal(lData[1], '*') then
                    if length(lRefControl) = 0 then
                        lData = vRecentNewUI & lData[2..length(lData)]
                    else
                        lData = lRefControl & lData[2..length(lData)]
                    end if
                end if
                if find('-', lData) then
                    lData = w32split(lData,'-')
                    lPos = -1
                elsif find('*', lData) then
                    lData = w32split(lData,'*')
                    lPos = 1
                else
                    lData = w32split(lData,'+')
                    lPos = 0
                end if
                -- lData[1] should be control name
                -- lData[2] should be offset, but can be omitted
                if length(lData) = 1 then
                    if length(lData[1]) = 0 or equal(lData[1], "*") then
                        if length(lRefControl) = 0 then
                            lData[1] = vRecentNewUI
                        else
                            lData[1] = lRefControl
                        end if
                    end if
                    lData &= 0
                    lPos = 0 -- Force 'add' operation
                else
                    if length(lData[1]) = 0 or equal(lData[1], "*") then
                        if length(lRefControl) = 0 then
                            lData[1] = vRecentNewUI
                        else
                            lData[1] = lRefControl
                        end if
                    end if
                    lNumData = w32TextToNumber({lData[2],w32True})
                    if lNumData[2] != 0 then
                        lData[2] = getNameIdInContext(w32trim(lData[2]), vRecent[w32RecentForms][length(vRecent[w32RecentForms])])
                        if lData[2] > 0 then
                            lTE = call_func(r_getRect,{lData[2]})
                            lData[2] = lTE[3] - lTE[1]
                        else
                            lData[2] = 0
                            lPos = 0
                        end if
                    else
                        lData[2] = lNumData[1]
                    end if
                end if
                if sequence(lData[1]) then
                    lData[1] = getNameIdInContext(w32trim(lData[1]), vRecent[w32RecentForms][length(vRecent[w32RecentForms])])
                end if
                if lData[1] > 0 then
                    lTE = call_func(r_getRect,{lData[1]})
                    lSizeInc = lTE[3] - lTE[1]
                    if lPos = 0 then
                        lSizeInc += lData[2]
                    elsif lPos = -1 then
                        lSizeInc -= lData[2]
                    else
                        lSizeInc *= lData[2]
                    end if
                end if

            else
                lSizeInc = lData
            end if

            lWidth += lSizeInc
            if lWidth > 1 then
                lWidth = floor(lWidth)
            end if


        elsif equal(lKey, "HEIGHT") then
            -- =num      {num}
            -- =*        {"*"}
            -- =*-num    {"*-num"}
            -- =fld      {"fld"}
            -- =fld-num  {"fld-num"}
            -- =fld-fld  {"fld-fld"}
            -- =-fld     {"-fld"}

            lChar[2] = lCharSize
            lSizeInc = 0
            if equal(lHeight,"") then
                lHeight = 0
            end if
            if length(lData) = 1 then
                lData = lData[1]
            end if
            if sequence(lData) then
                if length(lData) = 0 then
                    lData = "*"
                end if
                if equal(lData[1], '*') then
                    if length(lRefControl) = 0 then
                        lData = vRecentNewUI & lData[2..length(lData)]
                    else
                        lData = lRefControl & lData[2..length(lData)]
                    end if
                end if
                lPos = 0 -- zero means add, 1 means multiply, -1 means subtract.
                -- Relative to another control.
                if find('-', lData) then
                    lData = w32split(lData,'-')
                    lPos = -1
                elsif find('*', lData) then
                    lData = w32split(lData,'*')
                    lPos = 1
                else
                    lData = w32split(lData,'+')
                    lPos = 0
                end if
                -- lData[1] should be control name
                -- lData[2] should be offset, but can be omitted
                if length(lData) = 1 then
                    if length(lData[1]) = 0 or equal(lData[1], "*") then
                        if length(lRefControl) = 0 then
                            lData[1] = vRecentNewUI
                        else
                            lData[1] = lRefControl
                        end if
                    else
                        lData &= 0
                    end if
                    lData &= 0
                    lPos = 0 -- Force 'add' operation
                else
                    if length(lData[1]) = 0 or equal(lData[1], "*") then
                        if length(lRefControl) = 0 then
                            lData[1] = vRecentNewUI
                        else
                            lData[1] = lRefControl
                        end if
                    end if
                    lNumData = w32TextToNumber({lData[2],w32True})
                    if lNumData[2] != 0 then
                        lData[2] = getNameIdInContext(w32trim(lData[2]), vRecent[w32RecentForms][length(vRecent[w32RecentForms])])
                        if lData[2] > 0 then
                            lTE = call_func(r_getRect,{lData[2]})
                            lData[2] = lTE[4] - lTE[2]
                        else
                            lData[2] = 0
                            lPos = 0
                        end if
                    else
                        lData[2] = lNumData[1]
                    end if
                end if
                if sequence(lData[1]) then
                    lData[1] = getNameIdInContext(w32trim(lData[1]), vRecent[w32RecentForms][length(vRecent[w32RecentForms])])
                end if
                if lData[1] > 0 then
                    lTE = call_func(r_getRect,{lData[1]})
                    lSizeInc = lTE[4] - lTE[2]
                    if lPos = 0 then
                        lSizeInc += lData[2]
                    elsif lPos = -1 then
                        lSizeInc -= lData[2]
                    else
                        lSizeInc *= lData[2]
                    end if
                end if

            else
                lSizeInc = lData
            end if

            lHeight += lSizeInc
            if lHeight > 1 then
                lHeight = floor(lHeight)
            end if

        elsif equal(lKey, "TOP") then
            if atom(lData[1]) then
                lTop = lData[1]
            else
                if length(lData) >= 1 and w32string(lData[1]) then
                    lData = lData[1]
                end if

                lPos = 0 -- zero means add, -1 means subtract.
                -- Relative to another control.
                if find('-', lData) then
                    lData = w32split(lData,'-')
                    lPos = -1
                else
                    lData = w32split(lData,'+')
                    lPos = 0
                end if
                while length(lData) < 3 do
                    lData = append(lData, 0)
                end while

                -- lData[1] should be control name
                -- lData[2] should be offset
                -- lData[3] indicates which edge is relative
                if atom(lData[1]) or length(lData[1]) = 0 then
                    lData[1] = "*"
                end if

                lUpperData = upper(lData[1])
                if equal(lUpperData,"CENTER") or equal(lUpperData,"CENTRE") then
                    lTop = Center
                elsif equal(lUpperData,"DEFAULT") then
                    lTop = Default
                else
                    if length(lData[1]) > 1 and lData[1][length(lData[1])] = '*' then
                        lData[3] = 1
                        lData[1] = lData[1][1..length(lData[1])-1]
                    end if

                    if length(lData[1]) = 0 or equal(lData[1],"*")  then
                        if length(lRefControl) = 0 then
                            lData[1] = vRecentNewUI
                        else
                            lData[1] = lRefControl
                        end if
                    end if
                    lData[1] = getNameIdInContext(w32trim(lData[1]), vRecent[w32RecentForms][length(vRecent[w32RecentForms])])
                    if lData[1] > 0 then
                        if sequence(lData[2]) then
                            lNumData = w32TextToNumber({lData[2],1})
                            if lNumData[2] = 0 then
                                lData[2] = lNumData[1]
                            else
                                lData[2] = 0
                            end if
                        end if
                        lTE = call_func(r_getRect,{lData[1]})
                        if lPos < 0 then
                            lData[2] = -lData[2]
                        end if
                        if sequence(lData[3]) or lData[3] != 0 then
                            lTop = lData[2] + lTE[2]
                        else
                            lTop = lData[2] + lTE[4]
                        end if
                    end if
                end if
            end if

        elsif equal(lKey, "LEFT") then
            if atom(lData[1]) then
                lLeft = lData[1]
            else
                if length(lData) >= 1 and w32string(lData[1]) then
                    lData = lData[1]
                end if

                lPos = 0 -- zero means add, -1 means subtract.
                -- Relative to another control.
                if find('-', lData) then
                    lData = w32split(lData,'-')
                    lPos = -1
                else
                    lData = w32split(lData,'+')
                    lPos = 0
                end if
                while length(lData) < 3 do
                    lData = append(lData, 0)
                end while

                -- lData[1] should be control name
                -- lData[2] should be offset
                -- lData[3] indicates which edge is relative
                if atom(lData[1]) or length(lData[1]) = 0 then
                    lData[1] = "*"
                end if

                lUpperData = upper(lData[1])
                if equal(lUpperData,"CENTER") or equal(lUpperData,"CENTRE") then
                    lLeft = Center
                elsif equal(lUpperData,"DEFAULT") then
                    lLeft = Default
                else
                    if length(lData[1]) > 1 and lData[1][length(lData[1])] = '*' then
                        lData[3] = 1
                        lData[1] = lData[1][1..length(lData[1])-1]
                    end if

                    if length(lData[1]) = 0 or equal(lData[1],"*")  then
                        if length(lRefControl) = 0 then
                            lData[1] = vRecentNewUI
                        else
                            lData[1] = lRefControl
                        end if
                    end if
                    lData[1] = getNameIdInContext(w32trim(lData[1]), vRecent[w32RecentForms][length(vRecent[w32RecentForms])])
                    if lData[1] > 0 then
                        if sequence(lData[2]) then
                            lNumData = w32TextToNumber({lData[2],1})
                            if lNumData[2] = 0 then
                                lData[2] = lNumData[1]
                            else
                                lData[2] = 0
                            end if
                        end if
                        lTE = call_func(r_getRect,{lData[1]})
                        if lPos < 0 then
                            lData[2] = -lData[2]
                        end if
                        if sequence(lData[3]) or lData[3] != 0 then
                            lLeft = lData[2] + lTE[1]
                        else
                            lLeft = lData[2] + lTE[3]
                        end if
                    end if
                end if
            end if

        elsif equal(lKey, "BOTTOM") then
            lBottom = lData[1]

        elsif equal(lKey, "RIGHT") then
            lRight = lData[1]

        elsif equal(lKey, "AT") then

            -- This must have either zero, or two sub-values, or 'center'.
            if length(lData) = 2 then
                pParms[i] = {"LEFT",{lData[1]}}
                pParms = w32insertElement(pParms, i+1, {"TOP",{lData[2]}})
                incr = 0
            elsif length(lData) = 1 then
                lData = lData[1]
                if sequence(lData) then
                    lUpperData = upper(w32trim(lData))
                    if find(lUpperData, {"CENTER","CENTRE"}) then
                        pParms[i] = {"LEFT","CENTER"}
                        pParms = w32insertElement(pParms, i+1, {"TOP","CENTER"})
                        incr = 0
                    else
                        pParms[i] = {"LEFT",{lData}}
                        pParms = w32insertElement(pParms, i+1, {"TOP",{lData}})
                        incr = 0
                    end if
                else
                    pParms[i] = {"LEFT",{lData}}
                    incr = 0
                end if
            elsif length(lData) = 0 then
                -- Check for special value of "size={}" and turn it into "size={{},{}}"
                pParms[i] = {"LEFT","*"}
                pParms = w32insertElement(pParms, i+1, {"TOP","*"})
                incr = 0
            end if
        elsif equal(lKey, "SIZE") then
            -- This must have either zero or two sub-values, or a control name, or one of 'maximum' or 'minimum'.
            if length(lData) = 2 then
                pParms[i] = {"WIDTH",{lData[1]}}
                pParms = w32insertElement(pParms, i+1, {"HEIGHT",{lData[2]}})
                incr = 0
            elsif length(lData) = 1 then
                lData = lData[1]
                if sequence(lData) then
                    lUpperData = upper(w32trim(lData))
                    if equal(lUpperData, "MAXIMUM") then
                        lInitView = 1
                        lData = ""
                    elsif equal(lUpperData, "MINIMUM") then
                        lInitView = 2
                        lData = ""
                    else
                        pParms[i] = {"WIDTH",{lData}}
                        pParms = w32insertElement(pParms, i+1, {"HEIGHT",{lData}})
                        incr = 0
                    end if
                else
                    pParms[i] = {"WIDTH",{lData}}
                    incr = 0
                end if
            elsif length(lData) = 0 then
                -- Check for special value of "size={}" and turn it into "size={{},{}}"
                pParms[i] = {"WIDTH","*"}
                pParms = w32insertElement(pParms, i+1, {"HEIGHT","*"})
                incr = 0
            end if

        elsif equal(lKey, "CAPTION") or equal(lKey, "TEXT") then
            if length(lData) = 1 then
                if not w32string(lData) then
                    lData = lData[1]
                    if length(lData) = 0 then
                         lData = {{}}
                    elsif lData[1] = '<' and lData[length(lData)] = '>' then
                        lData = rt:UseText(lData[2..length(lData)-1],"")
                    end if
                else
                    -- Special for Text vs Caption
                    if not equal(lKey, "CAPTION") or w32string(lData) = 0 then
                        lData = w32ToString(lData[1])
                    end if
                end if
            end if
            lCaption = w32trim(lData)

        elsif equal(lKey, "VALUE") then
            if length(lData) = 1  and not w32string(lData) then
                lData = lData[1]
            end if
            lText = w32trim(lData)

        elsif equal(lKey, "NAME") then
            if length(lData) = 1  and not w32string(lData) then
                lData = lData[1]
            end if
            lName = w32trim(lData)

        elsif equal(lKey, "IMAGE") then
            lData = lData[1]
            lImage = w32lookup(upper(lData), vWinIconNames, WinIcons)
            if lImage = 0 then
                lImage = lData
            end if

        elsif equal(lKey, "OWNER") or equal(lKey, "PARENT") then
            lKey = "OWNER" -- Standardize
            lData = lData[1]
            if atom(lData) then
                lOwner = lData
            else
                lOwner = getNameId(w32trim(lData))
            end if
            if lOwner > 0 and ctrl_Type[lOwner] = ReBarBand then
                lReBarBand = lOwner
                lOwner = ctrl_Parent[lOwner]
            end if

        elsif equal(lKey, "TOOLTIP") or equal(lKey, "HINT") then
            lKey = "TOOLTIP" -- Standardize
            if length(lData) = 1 then
                lData = lData[1]
            else
                lData = ""
            end if
            lTooltip = lData

        elsif equal(lKey, "EVENT") or equal(lKey, "EVENTS") then
            lKey = "EVENTS" -- Standardize
            if sequence(lData) then
                for j = 1 to length(lData) do
                    lUpperData = lData[j]
                    -- 2-element: code plus event handler name
                    if length(lUpperData) = 2 and w32string(lUpperData[1]) then
                        lUpperData[w32AKey] = w32lookup(upper(w32trim(lUpperData[w32AKey])), vEventNamesUpper,vEventCodes)
                        lUpperData[2] = lUpperData[w32AValue][1][w32AValue]
                        lEventList &=  lUpperData
                    else
                        lEventList &= w32lookup(upper(w32trim(lUpperData)), vEventNamesUpper,vEventCodes)
                    end if
                end for
            else
                lEventList &= lData
            end if

        elsif equal(lKey, "BAR") or equal(lKey, "BARS") then
            lKey = "BARS" -- Standardize
            for j = 1 to length(lData) do
                if w32string(lData[j]) then
                    lData[j] = upper(w32trim(lData[j]))
                    -- Only support statusbar so far.
                    if find(lData[j], {"TOOLBAR","TOOL"})  then
                        lToolbar = w32True

                    elsif find(lData[j], {"FLATTOOLBAR","FLAT", "FLATTOOL"}) then
                        lFlatToolbar = w32True

                    elsif find(lData[j], {"VERT","VERTICAL"}) then
                        lFlags = or_bits(lFlags, WS_VSCROLL)

                    elsif find(lData[j], {"HORZ","HORIZONTAL"}) then
                        lFlags = or_bits(lFlags, WS_HSCROLL)

                    elsif find(lData[j], {"STATUS","STATUSBAR"}) then
                         lStatusBar = w32True
                    end if
                elsif length(lData[j]) >= w32AValue then
                    if find(upper(lData[j][w32AKey]), {"STATUS","STATUSBAR"}) then
                        lStatusBar = repeat(-1, length(upper(lData[j][w32AValue])))
                        for k = 1 to length(upper(lData[j][w32AValue])) do
                            if length(lData[j][w32AValue][k]) >= w32AValue then
                                lStatusBar[k] = lData[j][w32AValue][k][w32AValue]
                            end if
                        end for
                    end if
                end if

            end for

        elsif equal(lKey, "FONT") then
            lFont = lData

        elsif equal(lKey, "INITIAL") or equal(lKey, "INITIALFOCUS") then
            lKey = "INITIALFOCUS"

            lData = lData[1]
            if atom(lData) then
                lInitFocus = (lData != 0)
            elsif equal(upper(lData), "ON") then
                lInitFocus = w32True
            else
                lInitFocus = (find(lData[1],"YT1yt"))  -- Yes True 1
            end if

        elsif equal(lKey, "COLUMNS") or equal(lKey, "COLUMN") then
            lKey = "COLUMNS"
            lLVColumns = ""

            -- It must be enclosed in braces.
            for k = 1 to length(lData) do
                lFlds = w32trim(lData[k])
                if length(lFlds) > 0 and lFlds[1] = '(' and lFlds[length(lFlds)] = ')' then
                    lFlds = w32split(lFlds[2..length(lFlds)-1],',')
                    lCTitle = ""
                    lCWidth = 100
                    lCAlign = -1

                    for j = 1 to length(lFlds) do
                        lFlds[j] = w32trim(lFlds[j])
                        if equal(lFlds[j], ">") and lCAlign = -1 then
                            lCAlign = LVCFMT_RIGHT
                        elsif equal(lFlds[j], "^") and lCAlign = -1 then
                            lCAlign = LVCFMT_CENTER
                        elsif equal(lFlds[j], "<") and lCAlign = -1 then
                            lCAlign = LVCFMT_LEFT
                        elsif equal(upper(lFlds[j]), "LEFT") and lCAlign = -1 then
                            lCAlign = LVCFMT_LEFT
                        elsif equal(upper(lFlds[j]), "RIGHT") and lCAlign = -1 then
                            lCAlign = LVCFMT_RIGHT
                        elsif equal(upper(lFlds[j]), "CENTER") and lCAlign = -1 then
                            lCAlign = LVCFMT_CENTER
                        else
                            lNumData = w32TextToNumber({lFlds[j],w32True})
                            if sequence(lNumData) and lNumData[2] = 0 then
                                -- Yes, it converts nicely.
                                lCWidth = w32abs(floor(lNumData[1]))
                            else
                                lCTitle = lFlds[j]
                            end if
                        end if
                    end for
                    lLVColumns = append(lLVColumns, {lCTitle, lCWidth, lCAlign})
                end if
            end for

        elsif equal(lKey, "FROM") then
            lData = lData[1]
            lRefControl = w32trim(lData)
            if atom(lRefControl) or length(lRefControl) = 0 or equal(lRefControl,"{}") then
                lRefControl = vRecentNewUI
            end if

        elsif equal(lKey, "BGCOLOR") or equal(lKey, "BGCOLOUR") or equal(lKey, "BG") then
            lKey = "BGCOLOR" -- Standardize

            if atom(lData) then
                lBGColor = lData
            else
                if length(lData) = 1 and equal("PARENT", upper(lData[1])) then
                    lBGColor = "PARENT"
                else
                    if length(lData) = 3 then
                        vColorValues[length(vColorValues)] = rgb(lData[1], lData[2], lData[3])
                    elsif length(lData) = 1 and w32string(lData[1]) then
                        lData = lData[1]
                    end if
                    lBGColor = w32lookup(upper(w32trim(lData)), vColorNames, vColorValues)
                end if
            end if

        elsif equal(lKey, "FGCOLOR") or equal(lKey, "FGCOLOUR") or equal(lKey, "FG") then
            lKey = "FGCOLOR" -- Standardize
            if atom(lData) then
                lFGColor = lData
            else
                if length(lData) = 3 then
                    vColorValues[length(vColorValues)] = rgb(lData[1], lData[2], lData[3])
                elsif length(lData) = 1 and w32string(lData[1]) then
                    lData = lData[1]
                end if
                lFGColor = w32lookup(upper(w32trim(lData)), vColorNames, vColorValues)
            end if

        elsif equal(lKey, "POINTER") then
            lPointer = w32trim(lData[1])

        elsif equal(lKey, "MEMBER") then
            lData = lData[1]
            if integer(lData) and lData > 0 then
                lSetMember = lData
            end if

        elsif equal(lKey, "BUDDY") then
            lData = lData[1]
            if atom(lData) then
                lBuddy = floor(lData)
            else
                lBuddy = getNameId(w32trim(lData))
            end if

        elsif equal(lKey, "PRAGMA") then
            lDirective = upper(w32trim(lData[1]))

        elsif equal(lKey, "POPUP") then

            if length(lData) > 0 then

                for j = 1 to length(lData) do
                    lData[j] = w32trim(lData[j])
                    if length(lData[j]) = 0 then
                        lData[j] = -1
                    else
                        lData[j] = getNameId(lData[j])
                    end if
                end for

                lAttachPopup = lData
            end if


        end if

        lPos = find(lKey, lAssumedKeys)
        if lPos then
            lAssumedKeys = w32removeIndex(lPos, lAssumedKeys)
            if lPos <= lAKPosn then
                lAKPosn -= 1
            end if
        end if

        i += incr
    end while

    -- All parameters have been processed.

    if sequence(lDirective) then
        if equal(lDirective, "PARENT") then
            if lType = Menu then
                vRecent[w32RecentMenu] = getNameId(lName)
            elsif lType = Window then
                vRecent[w32RecentWindow] = getNameId(lName)
            elsif lType = TabControl then
                vRecent[w32RecentTabControl] = getNameId(lName)
            end if
        end if

        return
    end if

    -- so now we check for missing values etc...
    if equal(lCaption, {{}}) then
        lCaption = ""
        if length(lName) = 0 then
            lName = {{}}
        end if

    elsif length(lCaption) = 0 then
        if length(lName) = 0 then
            -- This is fixed up after the control is created.
        else
            -- Do not set a default caption for certain control types.
            if find(lType, {StatusBar, EditText, MleText, ToolBar, FlatToolBar,
                            Pixmap, Bitmap,Group}) = 0 then
                lCaption = lName
            end if
        end if
    else
        if lCaption[1] = '<' and lCaption[length(lCaption)] = '>' then
            lCaption = rt:UseText(lCaption[2..length(lCaption)-1],"")
        end if
    end if

    if length(lName) = 0 then
        if w32string(lCaption) then
            lName = lCaption
        else
            lName = {{}}
        end if
    end if

    if sequence(lOwner) then
        -- No parent was specified.
        if lType = MenuItem or lType = MenuSpacer then
            lOwner = vRecent[w32RecentMenu]

        elsif lType = TabItem then
            lOwner = vRecent[w32RecentTabControl]

        elsif lType = ReBarBand then
            lOwner = 0

        elsif find(lType, {Window, Pixmap} ) = 0 then
            lOwner = vRecent[w32RecentWindow]

        else
            if (lType = Window) and vRecent[w32RecentWindow] != 0 then
                -- Make this a child window.
                if sequence(lFlags) then
                    lFlags = lFlags[1]
                end if
                lFlags = w32or_all({lFlags, WS_CHILD, WS_VISIBLE, WS_CLIPSIBLINGS})
                lFlags = {and_bits(lFlags,#FF30FFFF)}
                lOwner = vRecent[w32RecentWindow]
            else
                lOwner = 0
            end if
        end if
    end if

    -- Both top and left must either be 'Default' or 'not Default'.
    -- We can't have a mixture.
    if equal(lTop,Default) and not equal(lLeft, Default) then
        lTop = 0
    elsif equal(lLeft,Default) and not equal(lTop, Default) then
        lLeft = 0
    end if

    if lType = ListView then
        if length(lLVColumns) > 0 then
            lCaption = lLVColumns
            lFlags = or_bits(lFlags, LVS_REPORT)
        end if
    end if

    if lNewFlag then
        lFlags = {lFlags}
    end if
    if lNewExFlag then
        lExFlags = {lExFlags}
    end if

    ------------------------------------------
    -- Finally we get to create the control.

    lID = createEx(lType, lCaption, lOwner,
                   lLeft, lTop, lWidth, lHeight,
                   lFlags, lExFlags)
    ------------------------------------------

    -- Test for user defined properties.
    for j = 1 to length(lUserProp[1]) do
        defineUserProperty(lID, lUserProp[1][j], lUserProp[2][j])
    end for

    if equal(lName, {{}}) then
        lName = sprintf("NoName%d", lID)

    elsif length(lName) = 0 then
        lName = sprintf("NoName%d", lID)
--        if find(lType, {StatusBar, EditText, MleText, ToolBar, FlatToolBar,
--                            Pixmap, Bitmap,Combo,ComboBoxEx,Group}) = 0 then
--            lCaption = lName
--        end if
--        call_proc(r_setText,{lID, lCaption})
    end if

    setIdName(lID, lName )
    vRecentNewUI = getIdName(lID)

    if lType = ListView then
        if lLVExFlags != 0 then
            call_proc(r_setLVStyle, {lID, lLVExFlags})
        end if
    end if

    if lType = Window then
        if atom(lStatusBar) then
            lBarId = create(StatusBar, "", lID, 0, 0, 0, 0, 0)
            setIdName(lBarId, lName & "SB" )
            ctrl_Deferred_Handlers[lBarId] &= w32HClick
        elsif length(lStatusBar) > 0 then
            lBarId = create(StatusBar, "", lID, 0, lStatusBar, 0, 0, 0)
            setIdName(lBarId, lName & "SB" )
            ctrl_Deferred_Handlers[lBarId] &= w32HClick
        end if

        if atom(lToolbar) then
            lBarId = create(ToolBar, "", lID, 0, 0, 0, 34, 0)
            setIdName(lBarId, lName & "TB" )

        elsif atom(lFlatToolbar) then
            lTemp = getTextExtent(Screen, "|")
            lTemp = (32 + 12 + lTemp[2])
            lBarId = create(FlatToolBar, "", lID, 0, 0, 0, lTemp, 0)
            setIdName(lBarId, lName & "FB" )
        end if

        if lInitView = 1 then
            setUserProperty(lID, "w32InitView", SW_MAXIMIZE)
        elsif lInitView = 2 then
            setUserProperty(lID, "w32InitView", SW_MINIMIZE)
        end if
    end if

    if lInitFocus != 0 then
        setUserProperty(lOwner, "w32initfocus", lID)
    end if

    -- See if a list needs initial data
    if length(lText) > 0 then
        if find(classType[lType], {COMBO,LISTBOX}) then
            call_proc(r_addItem,{lID, lText})
        end if
    end if

    -- See if we need to add this to a rebar band
    if atom(lReBarBand) then
        call_proc(r_addToBand,{ lID,  lReBarBand })
    end if

    -- See if this has a special mouse pointer
    if atom(lPointer) or length(lPointer) > 0 then
        call_proc(r_setMousePointer,{lID, lPointer})
    end if


    if length(lFont) > 0 then
        lFormattedFont = ctrl_Font[lID]
        for j = 1 to length(lFont) do
            if atom(lFont[j]) then
                lFormattedFont[FontSize] = lFont[j]
            else
                lUpperData = upper(w32trim(lFont[j]))
                if equal(lUpperData,"NEW") then
                    lFormattedFont[FontAttrib] = 0
                elsif equal(lUpperData,"BOLD") then
                    lFormattedFont[FontAttrib] = or_bits(Bold, lFormattedFont[FontAttrib])
                elsif equal(lUpperData, "ITALIC") then
                    lFormattedFont[FontAttrib] = or_bits(Italic, lFormattedFont[FontAttrib])
                elsif equal(lUpperData, "UNDERLINE") then
                    lFormattedFont[FontAttrib] = or_bits(Underline, lFormattedFont[FontAttrib])
                elsif equal(lUpperData, "STRIKEOUT") then
                    lFormattedFont[FontAttrib] = or_bits(Strikeout, lFormattedFont[FontAttrib])
                elsif equal(lUpperData, "NORMAL") then
                    -- do nothing.
                else
                    if atom(lFont[j]) then
                        lNumData = {lFont[j], 0}
                    else
                        lNumData = w32TextToNumber({lFont[j],w32True})
                    end if
                    if lNumData[2] = 0 and lNumData[1] > 0 then
                        lFormattedFont[FontSize] = lNumData[1]
                    else
                        lFormattedFont[FontName] = lFont[j]
                    end if
                end if
            end if
        end for

        call_proc(r_setFont, lID & lFormattedFont[1..3])
    end if

     if equal(lWidth,"") then
        if lType = Window then
            ctrl_Auto_Width[lID] = w32True
        end if
        if length(lCaption) > 0 then
            lWidth = getTextWidth(lID, lCaption)
            if classType[lType] = BUTTON then
                lWidth += 12
            elsif lType = Window then
                lWidth += getSystemMetrics(SM_CXICON) * 4
            end if

            if lType = CheckBox then
                lWidth += 12
            elsif lType = Radio then
                lWidth += 12
            end if
        else
            lWidth = 1
            lChar[1] = w32True
        end if
        lResize = w32True
    end if

    if equal(lHeight,"") then
        if lType = Window then
            ctrl_Auto_Height[lID] = w32True
            lHeight = 50
        elsif length(lCaption) > 0 then
            lHeight = 10 + getTextHeight(lID, lCaption)
            if classType[lType] = BUTTON then
                lHeight += 6
            end if
        else
            lHeight = 1
            lChar[2] = w32True
        end if
        lResize = w32True
    end if


    if find(w32True, lChar) then
        lTE = getTextExtent(lID, "M")
        if lChar[1] then
            lWidth = lWidth * lTE[1] + 6
            if classType[lType] = BUTTON then
                lWidth += 6
            end if
        end if

        if lChar[2] then
            lHeight = lHeight * lTE[2] + 10
            if classType[lType] = BUTTON then
                lHeight += 6
            end if
        end if

        lResize = w32True
    end if

    if atom(lRight) then
        lTE = call_func(r_getRect,{lID})
        if lTE[3]-lTE[1] > lWidth then
            lWidth = lTE[3]-lTE[1]
        end if
        lOwner = findParent(lID)
        if lOwner = 0 then
            lOwner = Screen
        end if
        lParentRect = call_func(r_getClientRect,{lOwner})
        lLeft = lParentRect[3]-lRight-lWidth-lParentRect[1]

        call_proc(r_setRect,{lID, lLeft, lTE[2], lWidth, lTE[4]-lTE[2], w32True} )


    end if

    if atom(lBottom) then
        lTE = call_func(r_getRect,{lID})
        if lTE[4]-lTE[2] > lHeight then
            lHeight = lTE[4]-lTE[2]
        end if
        lOwner = findParent(lID)
        if lOwner = 0 then
            lOwner = Screen
        end if
        lParentRect = call_func(r_getClientRect,{lOwner})
        lTop = lParentRect[4]-lBottom-lHeight-lParentRect[2]

        call_proc(r_setRect,{lID, lTE[1], lTop, lTE[3]-lTE[1], lHeight, w32True} )

    end if

    if lResize then
        lTE = call_func(r_getRect,{lID})
        if not equal(lLeft, Center) then
            lLeft = lTE[1]
        end if
        if not equal(lTop, Center) then
            lTop = lTE[2]
        end if
        call_proc(r_setRect,{lID, lLeft, lTop, lWidth, lHeight, w32True} )
    end if

    if atom(lTooltip) or length(lTooltip) > 0 then
        call_proc(r_setHintEx,{lID, lTooltip,0})
    end if

    if lCheck[1] then
        call_proc(r_setCheck,{lID, lCheck[2]})
    end if
    if lEnable[1] then
        call_proc(r_setEnable,{lID, lEnable[2]})
    end if
    if lVisible[1] then
        if lVisible[2] = 0 and lType = Window then
            setUserProperty(lID, "w32InitView", SW_HIDE)
        else
            call_proc(r_setVisible,{lID, lVisible[2]})
        end if
    end if

    if lAutoClose then
        lTemp = vOnXXXSupport
        setHandler(lID, w32HClick, r_autoclose)
        vOnXXXSupport = lTemp
    end if

    if lSetMember > 0 then
        call_proc(r_setControlSet, {lSetMember, w32True, lID})
    end if

    if (ctrl_Family[lID] = BUTTON or find(lType,{MenuItem, StatusBar,Bitmap,Icon,LText,RText,CText} )) and find(w32HClick, lEventList) = 0 then
        lEventList &= w32HClick

    elsif find(lType,{HScroll,VScroll,HTrackBar,VTrackBar,ProgressBar,UpDown}) and find(w32HScroll, lEventList) = 0 then
        lEventList &= w32HScroll

    elsif find(lType,{EditText,MleText,RichEdit}) then
        if find(w32HKeyPress, lEventList) = 0 then
            lEventList &= w32HKeyPress
        end if

        if find(w32HKeyDown, lEventList) = 0 then
            lEventList &= w32HKeyDown
        end if

        if find(w32HKeyUp, lEventList) = 0 then
            lEventList &= w32HKeyUp
        end if

    elsif lType = Window then
        if find(w32HScroll, lEventList) = 0 then
            lEventList &= w32HScroll
        end if
        if find(w32HPaint, lEventList) = 0 then
            lEventList &= w32HPaint
        end if
        if find(w32HOpen, lEventList) = 0 then
            lEventList &= w32HOpen
        end if
        if find(w32HActivate, lEventList) = 0 then
            lEventList &= w32HActivate
        end if
        if find(w32HResize, lEventList) = 0 then
            lEventList &= w32HResize
        end if
        if find(w32HClose, lEventList) = 0 then
            lEventList &= w32HClose
        end if
    end if
    ctrl_Deferred_Handlers[lID] = lEventList

    -- Check if this has been added since the application started running.
    if vWinMainState = kStarted then
        ResolveDeferredHandler(lID)
        if lBarId != 0 then
            ResolveDeferredHandler(lBarId)
        end if
    end if

    -- Test for special scrollbar values
    if length(lScrollRange) != 0 then
        if length(lScrollRange) = 2 then
            call_proc(r_setScrollRange,{ lID, lScrollRange[1], lScrollRange[2] } )
        elsif length(lScrollRange) = 3 then
            call_proc(r_setWindowScrollRange,{ lID, 0, lScrollRange[1], lScrollRange[2], lScrollRange[3] } )
        end if
    end if
    if length(lScrollChange) != 0 then
        call_proc(r_setScrollChange,{ lID, lScrollChange[1], lScrollChange[2] } )
    end if
    if atom(lScrollPosition) then
        call_proc(r_setScrollPos,{ lID, lScrollPosition })
    end if
    if lBuddy > 0 then
        call_proc(r_setBuddy,{lID, lBuddy})
    end if

    -- Test for image setting
    if sequence(lImage) then
        if length(lImage) > 0 then
            if find(lType, {Window, Icon}) != 0 then
                call_proc(r_setIcon,{lID, lImage})
            elsif lType = Bitmap then
                call_proc(r_setBitmap,{lID, lImage})
            end if
        end if
    else
        call_proc(r_setIcon,{lID, lImage})
    end if
    lParent = ctrl_Parent[lID]

    -- Test for background color change
    if equal(lBGColor, "PARENT") then
        setWindowBackColor(lID, ctrl_Bg_Color[lParent])
    elsif not sequence(lBGColor) then
        setWindowBackColor(lID, lBGColor)
    end if
    if not sequence(lFGColor) then
        setTextColor(lID, lFGColor)
    end if

    -- Test for parent auto sizing.
    if lParent != 0 and not find( lType,{Popup,Menu,MenuItem,MenuSpacer,Pixmap}) then
        if ctrl_Auto_Height[lParent] then
            lTE = call_func(r_getRect,{lID})
            lParentRect = call_func(r_getClientRect,{lParent})
            if lTE[4] + 5 > lParentRect[4]-lParentRect[2] then
                call_proc(r_setClientRect,{lParent,
                                            lParentRect[3]-lParentRect[1],
                                            lTE[4] + 5})
            end if

        end if

        if ctrl_Auto_Width[lParent] then
            lTE = call_func(r_getRect,{lID})
            lParentRect = call_func(r_getClientRect,{lParent})
            if lTE[3] + 5 > lParentRect[3]-lParentRect[1] then
                call_proc(r_setClientRect,{lParent,
                                            lTE[3] + 5,
                                            lParentRect[4]-lParentRect[2]
                                            })
            end if

        end if
    end if

    if sequence(lAttachPopup) then
        VOID = call_func(r_attachPopup,{lID, lAttachPopup})
    end if
end procedure

--/topic Forms
--/proc createForm( sequence pFormDefinition )
--/desc This creates a Window and its controls.
--/i pFormDefinition is a list of Control definitions, the first is assumed to be
-- a Window definition and the rest are the controls that the window is to contain.
--Each control definition is passed on to /newUIObj to create the actual control in
-- the order they are defined in /i pFormDefinition.
--
--The elements in /i pFormDefinition as strings that each define a single control. The
-- string is a comma separated list of parameters in the form KEY=VALUE, but note
-- that some key names can be defaulted if omitted.
-- All the parameters have a keyword name, which is not case sensitive, meaning
-- that "width=200" and "WIDTH=200" are both acceptable. However, certain
-- parameters can have assumed keyword names if not supplied. The first unnamed
-- parameter is assumed to be the "TYPE" parameter, the second unnamed
-- is assumed to be "CAPTION", and so on for "NAME", "LEFT", "TOP", "WIDTH",
-- "HEIGHT", "FLAGS", and "EXFLAGS" parameters, in that order. If there
-- are still unnamed parameters after all the assumed ones have been
-- allocated, an error message is issued.
--
-- Also note that /b "include w32Start.ew" is usually used in conjunction with
-- applications that use createForm()
--
--Example:
--/code
--      createForm({"Window, Login,height=200,bar=status, left=10, top=Center",
--                  "RText,   User Name:, left=10,top=10",
--                  "EditText,User Name Text,caption=(), from=UserName" &
--                            ", left=(2),top=(-2,,), width=25chars",
--                  "RText,   Password:, from=UserName,left=(),top=(15),width=()",
--                  "EditText,Password Text,caption=(), from=Password" &
--                            ", left=(2),top=(-2,,), width=(),flag=es_password",
--                  "DefPushButton,&Submit, right=75, width=70,bottom=5, height=25",
--                  "CancelButton,&Cancel,  from=Submit, left=(5),top=()" &
--                  ", height=(), width=(), flag=autoclose",
--                  "TabOrder=(UserName,PasswordText,Submit)"
--                  })
--/endcode

global procedure createForm(sequence pForm)
    object lCtlDefn
    integer lPos
    object lTemp
    integer lNewId
    integer lDelim
    sequence lKeyValue

    if length(pForm) = 0 then
        return
    end if


    -- Pass 1: Standardize the control definitions.
    if w32string(pForm) then
        pForm = {pForm}
    end if

    for i = 1 to length(pForm) do
        if not w32string(pForm[i]) then
            lPos = 0
            while lPos < length(pForm[i]) do
                lPos += 1
                if sequence(pForm[i][lPos]) then
                    -- Convert an embedded sequence to a string.
                    lTemp = w32ToString(pForm[i][lPos])
                    if not find(',', lTemp) then
                        -- Strip off enclosing parens if not a list of items.
                        lTemp = lTemp[2..length(lTemp)-1]
                    end if
                    pForm[i] = pForm[i][1..lPos-1] &
                               lTemp &
                               pForm[i][lPos+1..length(pForm[i])]
                    lPos -= 1
                end if
            end while
        end if
    end for

    lPos = 1
    while lPos <= length(pForm) do
        lCtlDefn = pForm[lPos]

        -- Only deal with non-empty definitions!
        if length(lCtlDefn) != 0 then
            -- Split it up delimited by commas
            if length(lCtlDefn) > 0 and find(lCtlDefn[1], ";`~|#/\\-_^*@,") then
                lDelim = lCtlDefn[1]
                lCtlDefn = lCtlDefn[2..length(lCtlDefn)]
            else
                lDelim = ','
            end if
            pForm[lPos] = w32MakeArgs(lCtlDefn, lDelim, '=')

        else
            -- delete the empty string.
            pForm = pForm[1..lPos-1] & pForm[lPos+1 .. length(pForm)]
            lPos -= 1
        end if

        lPos += 1
    end while

    -- Pass 2: Make sure a 'window' definition is the first one.
    lPos = 0
    for i = 1 to length(pForm) do
        lCtlDefn = pForm[i]
        for j = 1 to length(lCtlDefn) do
            lKeyValue = lCtlDefn[j]

            if j = 1 and equal(upper(lKeyValue[w32AValue]), "WINDOW") then
                lPos = i
                exit
            end if
        end for
        if lPos != 0 then
            exit
        end if
    end for
    if lPos = 0 then
        -- No Window explictly defined, so I assume one.
        pForm[1] = prepend(pForm[1], {"TYPE",Window})
    end if

    -- Ensure form type is first element.
    if lPos > 1 then
        lCtlDefn = pForm[lPos]
        pForm = prepend(w32removeIndex(lPos, pForm), lCtlDefn)
    end if

    vRecent[w32RecentWindow] = 0
    vRecent[w32RecentTabControl] = 0
    vRecent[w32RecentMenu] = 0

    -- Pass 3: Define each control in order.
    for i = 1 to length(pForm) do
        newUIObj(pForm[i])
        if i = 1 then
            vRecent[w32RecentForms] &= vRecent[w32RecentWindow]
        end if
    end for

end procedure
r_createForm = routine_id("createForm")

--/topic Forms
--/func getFormIds(integer Action)
--/desc Returns the most recently created form(s)
--/ret SEQUENCE: A list of window ids created by the /createForm routine.
--If /i Action = 1 then only the most recent form id is returned,
--otherwise all the form ids are returned as a list ordered from
--oldest to most recently created.
--
--Example:
--/code
--      sequence fid
--      -- Create a form
--      createForm( FormDefn )
--      -- Get its form (window) id.
--      fid = getFormIds(1)
--/endcode
global function getFormIds(integer pAction)
    -- N.B. The first entry is a dummy one and should never be used.
    if length(vRecent[w32RecentForms]) <= 1 then
        return {}
    end if

    if pAction = 1 then
        return {vRecent[w32RecentForms][length(vRecent[w32RecentForms])]}
    end if

    return vRecent[w32RecentForms][2..length(vRecent[w32RecentForms])]
end function
r_getFormIds = routine_id("getFormIds")

--/topic Forms
--/func loadForms(sequence FileName)
--/desc Builds a form definition from a text file.
--/ret SEQUENCE: A form definition suitable to give to /createForm()
--/i FileName is the pathname of a file that contains form definition
--statements. These are almost identical to the ones used by /newUIObject
--but there are a few differences to help laying out the text file.
--
--The form definition file consists of one or more lines of text. Any
--text following the /b"comment string" are stripped off. Initially
-- the comment string is two semi-colons, eg. ";;". /n
--The lines are grouped into UI Object definitions. Each definition
-- starts in column 1. If you need to extend a definition over
-- multiple lines, offset the second and subsequent lines by at least
-- one space (or tab) character.
--
--You can change the default comment string by inserting a comment
-- in the form "comment=~<xxx>" where "~<xxx>" is one or more characters
--that become the new comment lead-in string from that point onwards.
--
--Example of a form definition file:
--/code
-- ;;comment=---
-- --- Customer.form
-- --- This defines the customer input screen.
--
-- Window, Customer Input
--         at={20, 20}
--         bar=status
--
--
-- Label, Number ------------------ Customer Number
--      at={5,10}
-- EditText
-- 	    left={}, top={0}, width=20ch
--
-- Label, Name ------------------ Customer Name
-- 	    left={}, top={4}
-- EditText
-- 	    left={}, top={0}, width=50char
--
-- Button, Accept
-- 	    left={}, top={10}
-- Button, Cancel
-- 	    left={4}, top={}
--/endcode
--
--Example for calling loadForm:
--/code
--      sequence lFormDefn
--      lFormDefn = loadForm("customer.form")
--      createForm(lFormDefn)
--      lFormId = getFormIds(1)
--      setText(lFormId[1], sprintf("%s (%d)",{getText(lFormId[1]), lFormId[1]}))
--/endcode

-----------------------------
global function loadForm(sequence pName)
-----------------------------
    integer lFH
    sequence lForm
    object lLine
    sequence lDefn
    integer lCont
    integer lPos
    sequence lCommentLead
    sequence lComment


    lCommentLead = ";;"
    lForm = {}
    lFH = w32FileOpen(pName, "r")
    if lFH = -1 then
        return {}
    end if

    lDefn = ""
    lLine = gets(lFH)
    while sequence(lLine) do
        lCont = lLine[1]
        lLine = w32trim(lLine)
        lPos = match(lCommentLead, lLine)
        if lPos != 0 then
            lComment = lLine[lPos+length(lCommentLead)..length(lLine)]
            lLine = w32trim(lLine[1..lPos-1])
            if match("comment=", lComment) = 1 and length(lComment) > 8 then
                lCommentLead = lComment[9..length(lComment)]
            end if
        end if
        if length(lLine) > 0 then
            if lCont = ' ' or lCont = '\t' then
                if length(lDefn) > 0 and lDefn[length(lDefn)] != ',' then
                    lDefn &= ','
                end if
                lDefn &= lLine
            else
                if length(lDefn) > 0 then
                    lForm = append(lForm, lDefn)
                end if
                lDefn = lLine
            end if
        end if

        lLine = gets(lFH)
    end while
    if length(lDefn) > 0 then
        lForm = append(lForm, lDefn)
    end if

    close(lFH)

    return lForm
end function


--/topic Values
--/proc showMessage( sequence Message )
--/desc Displays /i Message in a Statusbar
--/i pText is the text string which is displayed in the first (or only) panel of the
-- status bar which is on the main window. /n
--
-- It is possible to display it on a different status bar by using the format
-- { Message, pID }, where /i pID is either a Window id, which has a status bar, or
-- an actual status bar control id. /n
-- If you wish to display the message in a panel other than the first panel, the
-- /i pID has the format {id, panel#} /n
--
--In any case, if the /i pID is zero, the application's main window is assumed.
--
-- Example:
--
--/code
--      -- Show the caption of status bar in the main window
--      showMessage( "Ready" )
--      -- To display a message in another window:
--      showMessage( {"Searching...", EditWindow} )
--      -- If the statusbar has subfields, you can specify them like:
--      showMessage( {"2nd subField", {EditWindow,2}} )
--/endcode

global procedure showMessage( sequence pMsg)
    integer lPanel
    object id
    sequence lSizeA
    sequence lSizeB

    lPanel = 0
    if length(pMsg) = 2 and sequence(pMsg[1]) then
        id = pMsg[2]
        pMsg = pMsg[1]
    else
        id = mainWindow
    end if

    if sequence(id) then
        lPanel = id[2]
        id = id[1]
    end if

    if id = 0 then
        id = mainWindow
    end if
    if ctrl_Type[id] = Window then
        id = ctrl_Statusbar[id]
    elsif ctrl_Type[id] != StatusBar then
        id = findParent(id)
        if id != 0 then
            id = ctrl_Statusbar[id]
        end if
    end if


    -- Is there a statusbar in this window?
    if id = 0 then
        id = ctrl_Statusbar[mainWindow]
        if id = 0 then
            lSizeA = call_func(r_getRect,{mainWindow})
            id = createEx(StatusBar, "", mainWindow, 0, 0, 0, 0, 0, 0)
            lSizeB = call_func(r_getRect,{id})
            call_proc(r_setRect,{mainWindow, lSizeA[1], lSizeA[2], lSizeA[3]-lSizeA[1],
                                                lSizeA[4] + lSizeB[4] - lSizeA[2] - lSizeB[2], 1})
        end if
    end if
    if id then
        if lPanel != 0 then
            id = {id, lPanel}
        end if
        call_proc(r_setText,{id, pMsg})
    end if
end procedure
-----------------------------------------------------------------------------

-----------------------------------------------------------------------------
-- DESTROYING CONTROLS
--
-----------------------------------------------------------------------------
--/topic Attributes
--/proc destroy( id )
--/desc Destroy an object created with the /create function.
-- When a control is destroyed, it releases its resources back to
-- Windows. This also means that a /i parent control also destroys
-- its child controls.
--
-- When the control being destroyed is a Window, it cannot be reopened.
-- If you want to be able to reopen a window, use /closeWindow() instead
-- of /destroy().
--
-- When this is called, but before the control is actually destroyed,
-- the /w32HDestroy event is triggered, enabling you to clean up things
-- associated with this control. Or even prevent the control from
-- being destroyed, by returning -1 from the event handler.
--
-- The following will destroy a pushbutton called /i MyButton.
--
--/code
--      -- destroy a pushbutton
--      destroy( MyButton )
--/endcode
--

-- begin mwl 2/10/04
-- delayed destruction:
sequence vDestroyQueue
vDestroyQueue = {}

-- This is called to do the actual destruction of a control.
procedure fDoDestruction( integer id )
    -- Destroy the requested item.

    -- It is safe to assume that all children of this control
    -- have already been destroyed before this is called.

    integer class, parent, tabseq, lIdx, lKid
    atom handle
    object rc
    sequence parenttabs
    sequence lChildren
    integer tabnumber
    object lUserResponse
    object lTemp


    lTemp = ctrl_Type[id]
    lTemp = vControlRID[lTemp]
    if sequence(lTemp) and (lTemp[kCRID_Destroy] >= 0) then
        lUserResponse = call_func(lTemp[kCRID_Destroy], {"Destroy", {id}})
    else
        lUserResponse = 0
    end if

    if equal(lUserResponse,0) then
        -- get class and parent
        class = ctrl_Family[id]
        parent = findParent(id)

        if ctrl_Type[id] = TabItem then
            ctrl_Group[id] = {}

            -- remove from tab list
            tabnumber = find(id, ctrl_Tabitems[ parent ])
            VOID = sendMessage( parent, TCM_DELETEITEM, tabnumber-1, 0 )
            ctrl_Tabitems[parent] = w32removeItem(id, ctrl_Tabitems[parent])

            -- Set focus to next tabitem
            if tabnumber > length(ctrl_Tabitems[parent]) then
                tabnumber = length(ctrl_Tabitems[parent])
            end if
            if tabnumber != 0 then
                call_proc(r_setFocus,{ctrl_Tabitems[parent][tabnumber]})
            end if

        elsif class = WINDOW then
            -- destroy window
            VOID = w32Func( xDestroyWindow, { ctrl_Handle[id] } )
            if ctrl_ClassAddr [id] != 0 then
                VOID = w32Func( xUnregisterClass, { ctrl_ClassAddr [id], instance() })
                w32release_mem (ctrl_ClassAddr [id])
                ctrl_ClassAddr [id] = 0
            end if

        elsif parent != 0
            and
          ctrl_Type[parent] = FlatToolBar then
            handle = sendMessage( parent, TB_COMMANDTOINDEX, id, 0 )
            VOID = sendMessage( parent, TB_DELETEBUTTON, handle, 0 )

        elsif find( class,
            {COMMON_CONTROL,BUTTON,COMBO,EDIT,LISTBOX,SCROLLBAR,STATIC} ) then
            -- destroy control
            VOID = w32Func( xDestroyWindow, { ctrl_Handle[id] } )

        elsif class = PIXMAP then
           deleteObject( ctrl_Handle[ id ] )

        elsif class = MENU or class = MENUITEM then
            -- delete from parent
            if not w32Func( xDeleteMenu, { ctrl_Menu[id][1],
                                           ctrl_Menu[id][3],
                                           MF_BYCOMMAND } ) then
                abortErr( Err_DESTROYMENU )
            end if
            ctrl_Menu[id] = -1

        else
            -- no special processing.
        end if

        -- mark as destroyed
        if ctrl_Type[id] = ListView then
            lIdx = find(id, lv_id)
            if lIdx then
                lv_id[lIdx] = -1
                lv_properties[lIdx] = lv_Default_Properties
            end if
        end if

    end if

    releaseResourcesForID ( id )

    ctrl_Destroyed[id] = -1  -- Destruction completed.
    ctrl_Handle[id] = -1
    ctrl_Handle_type [id] = - 1
    ctrl_Mousetrap[id] = 0  -- Delete all mousetraps for this window.
    ctlblk_freelist = id & ctlblk_freelist
    ctrl_Group[id] = {}


    ------- Remove destroyed control from ...
    if parent != 0 then

        -- parent's tabbed items.
        ctrl_Focus_order[parent] = w32removeItem(id, ctrl_Focus_order[parent])
        -- parent's group items.
        ctrl_Group[parent] = w32removeItem(id, ctrl_Group[parent])

    end if
    -- Treeview ids
    tv_id = w32removeItem(id, tv_id)

    -- Listview ids
    lv_id = w32removeItem(-1, lv_id)

    -- Form ids
    vRecent[w32RecentForms] = w32removeItem(id, vRecent[w32RecentForms])

    deleteObject( ctrl_Bg_Brush [id] )
end procedure

global procedure destroy( integer id )

    -- destroy the requested item
    integer class, parent, tabseq, lIdx, lKid
    atom handle
    object rc
    sequence parenttabs
    sequence lChildren

    -- Ignore bad control ids.
    if not validId(id) then
        return
    end if

    rc = 0
    if ctrl_Destroyed[id] = 0 then
        -- destroy routine?
        rc = invokeHandler(id, w32HDestroy, {})
        if sequence(rc) and not equal(rc[1], 0) then
            -- ignore the destroy order.
            vDestroyQueue  = {}
            return
        end if

        if ctrl_Type[id] = Window then

            ctrl_Destroyed[id] = 2 -- Destruction requested.
            -- First try to close the window.
            rc = sendMessage( id, WM_CLOSE, 0, 0 )
            if not equal(rc,0) or ctrl_Closed[id] = 0 then
                -- ignore the destroy order.
                ctrl_Destroyed[id] = 0 -- Destruction denied.
                return
            end if
            -- See if closing the window also destroyed it.
            if ctrl_Destroyed[id] = -1 then
                return
            end if
        end if

    end if

    if find(id, vDestroyQueue) = 0 then
        vDestroyQueue &= id
    end if

    if sequence(rc) and not equal(rc[1],0) then
        -- ignore destroy order
        for dq = 1 to length(vDestroyQueue) do
            ctrl_Destroyed[vDestroyQueue[dq]] = 0
        end for


        vDestroyQueue = {}
        return
    end if


    lChildren = findChildren(id)
    for i = length(lChildren) to 1 by -1 do
        destroy(lChildren[i][1])
        if length(vDestroyQueue) = 0 then
            exit
        end if
    end for

    -- Only really destroy things if the current id is at the head of the queue.
    if length(vDestroyQueue) > 0 and vDestroyQueue[1] = id then

        -- keep any events from being triggered
        -- by clearing all event handlers for
        -- each control being destroyed.
        for i = 1 to length(vDestroyQueue) do
            ctrl_Handlers[vDestroyQueue[i]] =
                repeat( {}, length(ctrl_Handlers[vDestroyQueue[i]] ))
        end for

        -- Process the queue in reverse order
        -- so that owned controls get destroyed before
        -- their owner does.
        for dq = length(vDestroyQueue) to 1 by -1 do
            id = vDestroyQueue[dq]

            -- Do not do bad control ids.
            if validId(id) then
                fDoDestruction( id )
            end if

        end for
        vDestroyQueue = {}
    end if


end procedure
r_destroy = routine_id("destroy")


-----------------------------------------------------------------------------
-- SCREEN DISPLAY
--

-----------------------------------------------------------------------------
--/topic Fonts
--/proc setPenPos( window, x, y )
--/desc Position the text pen in /i window.
-- Example:
--
--/code
--      -- move the pen
--      /setPenPos( MyWindow, 10, 10 )
--
--      -- display message
--      /wPuts( MyWindow, "This is at {10,10}" )
--/endcode

global procedure setPenPos( integer id, object x, object y )
    sequence BBox

    BBox = convPctToPixel(id, x,y, 0, 0)

    -- set the window cursor position
    ctrl_X_Pos[id] = BBox[1]
    ctrl_Y_Pos[id] = BBox[2]
end procedure
r_setPenPos = routine_id("setPenPos")
-----------------------------------------------------------------------------

--/topic Attributes
--/func getRect( atom id )
--/desc Get the dimensions of /i id.
--/ret Sequence: { left, top, right, bottom }
-- The returns the pixel positions of the top-left corner and the bottom
-- right corner. For Screen, Printer and bitmaps the top-left is always
-- 0,0 and thus /i right is the width and /i bottom is the height.
--
-- Example:
--
--/code
--      -- where is the window located?
--      sequence extent
--
--      -- get the extent of the window
--      extent = /getRect( MyWindow )
--
--      -- display the position
--      /wPrintf( MyWindow, "MyWindow is located at %d,%d }, extent[1 .. 2] )
--/endcode

global function getRect( atom id )

    -- get metrics for current window
    -- returns { left, top, bottom, right }

    integer top, bottom, left, right
    atom struct, pt, hdc, mset, bufsize, hWnd
    sequence xy, retval


    retval = {0, 0, 0, 0}
    if id = 0 then
        return retval
    end if

    mset = w32new_memset()

    if id = Screen  or  id = Printer  then

        hdc = getDC( id )

        -- screen size
        retval[3] = w32Func( xGetDeviceCaps, {hdc, HORZRES} )
        retval[4] = w32Func( xGetDeviceCaps, {hdc, VERTRES} )

        releaseDC( id )

    elsif not validId( id ) then
    -- probably passed a bitmap

        bufsize = w32Func(xGetObjectType, {id})
        if bufsize = OBJ_BITMAP then
            bufsize = w32Func( xGetObject, { id, 0, 0} )

        else
            bufsize = 0

        end if

        if bufsize != 0 then
            -- Allocate a buffer to hold bitmap information
            struct = w32acquire_mem( mset, bufsize )

            -- load bitmap data into structure
            if w32Func( xGetObject, { id, bufsize, struct} ) != bufsize then
                warnErr( Err_GSGETBITMAP )
            end if
            -- get the values from the bitmap
            retval[3] = w32fetch( struct, bmWidth )
            retval[4] = w32fetch( struct, bmHeight )
        else
            warnErr( Err_GSGETBITMAP )
            retval[3] = 0
            retval[4] = 0
        end if

    elsif ctrl_Family[ id ] = PIXMAP then


        -- do we have one?
        hWnd = ctrl_Handle[id]
        if hWnd != 0 then

            bufsize = w32Func( xGetObject, { hWnd, 0, 0} )
            -- Allocate a buffer to hold bitmap information
            if bufsize > 0 then
                struct = w32acquire_mem( mset, bufsize )

                -- load bitmap data into structure
                if w32Func( xGetObject, { hWnd, bufsize, struct} ) != bufsize then
                    warnErr( Err_GSGETPIXMAP )
                end if

                -- get the values from the bitmap
                retval[3] = w32fetch( struct, bmWidth )
                retval[4] = w32fetch( struct, bmHeight )
            end if
        end if

    else

        -- Allocate a buffer to hold the rectangle information
        struct  = w32acquire_mem( mset, SIZEOF_RECT )

        -- load rectangle information into the buffer
        if not w32Func( xGetWindowRect, { getHandle( id ), struct } ) then
            abortErr( Err_GSGETWINDRECT )
        end if

        -- get points
        retval = peek4s({struct,4})

        -- is it owned by a window?
        if ctrl_Parent[ id ] then

            -- set to owner window
            id = ctrl_Parent[ id ]

            xy = ClientToScreen(id, 0, 0)

            -- adjust points
            retval -= (xy & xy)

        end if

    end if

    -- Return any memory blocks used.
    w32release_mem(mset)

    -- return values
    return retval -- { left, top, right+1, bottom+1 }

end function
r_getRect = routine_id("getRect")

-----------------------------------------------------------------------------
--/topic Attributes
--/func getClientSize( atom id )
--/desc Get the dimensions of /i "id's" client area.
--/ret Sequence: { Screen.left, Screen.top, right, bottom }
-- The returns the pixel positions of the top-left corner, relative to the screen
-- and the width and height of the client area.
-- For Screen, Printer and Pixmap the top-left is always 0,0
--
-- Example:
--
--/code
--      -- where is the button located?
--      sequence extent
--
--      -- get the extent of the button
--      extent = /getClientSize( MyButton )
--
--      -- display the position
--      /wPrintf( MyWindow, "MyButton is at %d,%d and width=%d, height=%d", extent )
--/endcode

global function getClientSize( integer id )

    -- get metrics for current window's client area
    -- returns { Sceeen.left, Screen.top, width, height }

    integer cx, cy
    atom rect, pt, hWnd
    sequence xy

    if find(ctrl_Type[id],{Screen_, Printer_, Pixmap}) then
        return getRect(id)
    end if

    -- get handle of window
    hWnd = getHandle( id )

    -- Allocate a buffer to hold the rectangle information
    rect = w32acquire_mem( 0, SIZEOF_RECT )

    -- get size of client area
    if not w32Func( xGetClientRect, {hWnd, rect} ) then
        warnErr( Err_GCSGETCLIENTRECT )
    end if

    -- fetch the extent
    cx = w32fetch( rect, rectRight  )
    cy = w32fetch( rect, rectBottom )

    -- Locate the top left corner relative to the screen.
    xy = ClientToScreen(id, 0, 0)
    --xy = {w32fetch( rect, rectLeft  ), w32fetch( rect, rectTop  )}


    -- Free point and rectangle
    w32release_mem( rect )

    -- return values
    return { xy[1], xy[2], cx, cy}

end function



-----------------------------------------------------------------------------
--/topic Attributes
--/func getClientPoint( window, x, y )
--/desc Get screen position of point { /i x, /i y } in /i window.
--/ret { screen x, screen y }
--This routine handles relative positions similar to the /create() routine
--
-- Example:
--
--/code
--      -- where does {0.50, 10} in MyWindow appear on the screen?
--      sequence point
--
--      -- get the screen position
--      point = /getClientPoint( MyWindow, 0.50, 10 )
--
--      -- display the size
--      /wPrintf( MyWindow, "The point {0.50,10} maps to {%d, %d on the screen"}, point )
--/endcode

global function getClientPoint( integer id, object x, object y )

    atom pt
    sequence point, BBox

    BBox = convPctToPixel(id, x, y, 0, 0)
    x = BBox[1]
    y = BBox[2]

    point = ClientToScreen(id, x, y)

    return point

end function


-----------------------------------------------------------------------------
--/topic Attributes
--/func getCtlSize( atom id )
--/desc Get the width and height of /i object.
--/ret SEQUENCE: { width, height }
--
--
-- Example:
--
--/code
--      -- how large is TheButton?
--      sequence size
--
--      -- get the size of TheButton
--      size = /getCtlSize( TheButton )
--
--      -- display the size
--      /wPrintf( MyWindow, "TheButton is %d by %d"}, size )
--/endcode

global function getCtlSize( atom id )

    -- get { width, height } for the requested item
    sequence s

    -- get extent
    s = getRect( id )

    -- Calculate the width and height
    return { s[3]-s[1], s[4]-s[2] }

end function
r_getCtlSize = routine_id("getCtlSize")

-----------------------------------------------------------------------------
--/topic Attributes
--/func getPosition( object )
--/desc Get the location of /i object.
--/ret { left, top }
--
--
-- Example:
--
--/code
--      -- Where is TheButton?
--      sequence posn
--
--      -- get the position of TheButton
--      posn = /getPosition( TheButton )
--
--      -- display the position
--      /wPrintf( MyWindow, "TheButton is at %d, %d}, posn )
--/endcode

global function getPosition( atom id )

    -- get { left, top } for the requested item
    sequence s

    -- get extent
    s = getRect( id )

    -- Return the left hand top corner position
    return { s[1], s[2] }

end function

--/topic Attributes
--/func getWindowRect( id )
--/desc Dimensions of window /i id.
--/ret { left, top, right, bottom }
-- Retrieves the dimensions of the bounding rectangle of the
-- specified window. The dimensions are given in screen coordinates
-- that are relative to the upper-left corner of the screen.
global function getWindowRect( integer id )
    atom r, ok
    sequence result

    r = w32acquire_mem(0, SIZEOF_RECT )
    ok = w32Func( xGetWindowRect, { ctrl_Handle[id], r } )
    if not ok then
        result = {0,0,0,0}
    else
        result = peek4s({r,4})
    end if

    w32release_mem(r)

    return result
end function

--/topic Attributes
--/proc setWindowRect( integer id, sequence Rect )
--/desc Sets the dimensions of window /i id.
--/i Rect is a sequence containing the { left, top, right, bottom }
-- coordinates of the control.

global procedure setWindowRect( integer id, sequence pRect )

    pRect[3] -= pRect[1]
    pRect[4] -= pRect[2]
    VOID = w32Func( xMoveWindow, getHandle( id ) & pRect & w32True)

end procedure

-----------------------------------------------------------------------------
--/topic Attributes
--/func getClientRect( integer ControlId )
--/desc Get uncovered portion of the client area.
--/ret { left, top, width, height, bottom, right }
-- Unlike the menu, toolbar and statusbar both occupy space in the window.
-- To determine what part of the window's client area is not covered, use
-- this function. This function can be used even if there is no toobar or
-- statusbar in the window.
--
-- For example, the /b generic demo has a /MleText that needs to be resized
-- every time the window is resized. It uses getClientRect to determine the
-- metrics of the /MleText.
--
--/code
--          -- color the unoccupied portion of the window red
--          sequence rect
--
--          -- find out what portion of the window is available
--          rect = getClientRect( TheWindow )
--
--          -- draw a filled rectangle
--          /setPenColor( TheWindow, Red )
--          /drawRectangle( TheWindow, w32True, rect[1], rect[2], rect[1]+rect[3], rect[2]+rect[4] )
--/endcode
-----------------------------------------------------------------------------
global function getClientRect( integer id )

    -- returns rectangle of the client area, accounting for
    -- the toolbar and status bar.

    integer x, y, cx, cy, toolbar, statusbar
    atom ptrRect, hdc
    sequence rect, size

    rect = repeat( 0, 6 )

    if id = Screen
     or
       id = Printer
    then

        hdc = getDC( id )

        -- screen size
        rect[3] = w32Func( xGetDeviceCaps, {hdc, HORZRES} )
        rect[4] = w32Func( xGetDeviceCaps, {hdc, VERTRES} )

        releaseDC( id )

    elsif ctrl_Type[id] = Pixmap then
        rect[1..4] = getRect(id)

    elsif ctrl_Type[id] = ReBarBand then
        rect[1..4]  = getRect(id)

    else

        -- Allocate a rectangle structure
        ptrRect = w32acquire_mem( 0, SIZEOF_RECT )

        -- get client rectangle size
        if not w32Func( xGetClientRect, {getHandle(id), ptrRect} ) then
            warnErr( Err_GCRGETCLIENTRECT )
        end if
        rect[1..4] = peek4u({ptrRect,4})

        -- Free the structure
        w32release_mem( ptrRect )


        -- is there a toolbar?
        toolbar = ctrl_Toolbar[ id ]
        if toolbar and ((vWinMainState = kNotStarted) or call_func(r_isVisible, {toolbar})) then

            -- get the size of the toolbar
            size = getCtlSize( toolbar )

            -- add height to the y value
            rect[2] += size[2]
            rect[4] -= size[2]
        end if

        -- is there a statusbar?
        statusbar = ctrl_Statusbar[ id ]
        if statusbar --and ((vWinMainState = kNotStarted) or call_func(r_isVisible, {statusbar}))
                           then

            -- get the size of the toolbar
            size = getCtlSize( statusbar )

            -- subtract height from the y value
            rect[4] -= size[2]

        end if

    end if

    rect[5] = rect[1] + rect[3] - 1
    rect[6] = rect[2] + rect[4] - 1

    return rect

end function
r_getClientRect = routine_id("getClientRect")

-----------------------------------------------------------------------------
-- GENERIC CONTROLS
--

-----------------------------------------------------------------------------
function getMenuState( integer id )
    -- get menu state
    return w32Func( xGetMenuState, { getHandle( id ), id, 0 } )
end function


-----------------------------------------------------------------------------
--/topic Attributes
--/proc setSubFields( integer pID, sequence pPartInfo )
--/desc Defines the sub-fields, or panels, in a status bar.
-- /i pID must refer to a status bar control. /n
-- /i pPartInfo is a list of panel size specifiers for each
-- subfield (a.k.a. panel) in the statusbar. /n
-- Each value in this list can be expressed in one of four
-- ways: /n
--<nl>
--/li A /b positive integer refers to the panels absolute right-hand side
-- pixel position
--/li A /b negitive integer less than -1. This refers to a right-hand side
-- position relative to the window's right-hand edge.
--/li An /b atom > 0 and ~< 1 refers to the panel's width
-- as a fraction of the window's width (0.25 means 25% of the window width)
-- /li A sequence (containing one integer) refers to the panel's width
-- in pixels.
--</nl>
-- If the any specification has the value -1, it means that
-- this is the last panel and it extends to the right hand edge of the
-- window.
--
-- You can use /setText() and /getText() to write and read these panels.
--
-- Example:
--/code
--       -- This specifies 6 panels.
--       -- The first one's rightedge is at pixel 55.
--       -- The second is 100 pixels wide.
--       -- The third is 10% of the window width.
--       -- The 4th is 20 pixels wide.
--       -- The 5th is 10 pixels in from the window's RHS.
--       -- The last one extends to the window's edge.
--       setSubFields(SB, {55, {100}, 0.10, {20},-10,-1})
--/endcode

global procedure setSubFields( integer pID, sequence pPartInfo)
    atom lBuffer
    atom lAddr
    integer lRightEdge
    integer lPanelCnt
    object lWindowWidth

    if not validId(pID) then
        return
    end if

    if ctrl_Type[pID] != StatusBar then
        return
    end if

    if length(pPartInfo) = 0 then
        return
    end if

    lWindowWidth = getCtlSize( ctrl_Parent[pID] )
    lWindowWidth = lWindowWidth[1]
    lBuffer = w32acquire_mem(0, 4 * length(pPartInfo))
    if lBuffer = 0 then
        return
    end if

    lRightEdge = 0
    lPanelCnt = 0
    lAddr = lBuffer
    for i = 1 to length(pPartInfo) do
        if sequence(pPartInfo[i]) then
            lRightEdge += floor(pPartInfo[i][1])
        elsif pPartInfo[i] < 1 then
            if pPartInfo[i] > 0 then
                lRightEdge += floor(pPartInfo[i] * lWindowWidth)
            elsif pPartInfo[i] < -1 then
                lRightEdge = lWindowWidth + pPartInfo[i]
            else
                lRightEdge = -1
            end if
        else
            lRightEdge = floor(pPartInfo[i])
        end if
        poke4(lAddr, lRightEdge)
        lAddr += 4
        lPanelCnt += 1
        if lRightEdge = -1 then
            exit
        end if
    end for
    VOID = sendMessage( pID, SB_SIMPLE, 0, 0)
    VOID = sendMessage( pID, SB_SETPARTS, lPanelCnt, lBuffer)
    w32release_mem(lBuffer)
end procedure
r_setSubFields = routine_id("setSubFields")

-----------------------------------------------------------------------------
--/topic Values
--/proc insertText( object pID, object pText )
--/desc Inserts text at the current caret (insersion point)
-- Example:
--
--/code
--      -- Adds some text to the end of the control.
--      /insertText( myedit, "\n(Ready)\n" )
--/endcode
global procedure insertText( integer id, sequence text )

   -- replace selection; w32True means allow undo
   VOID = sendMessage( id, EM_REPLACESEL, w32True, text)

end procedure

--/topic Values
--/proc appendText( object pID, object pText )
--/desc Adds text to the end of a edit control.
-- Example:
--
--/code
--      -- Adds some text to the end of the control.
--      /appendText( myedit, ">Ready\n" )
--/endcode
global procedure appendText( integer id, sequence text )
    -- Insert text at end of edit control's existing text --
   atom editlength

   editlength = sendMessage( id, WM_GETTEXTLENGTH, 0, 0 )
   VOID = sendMessage( id, EM_SETSEL, editlength, editlength )
   insertText( id, text )
end procedure

--/topic Values
--/proc setText( object pID, object pText )
--/desc Set the text in /i pID control.
-- If the control is editable, it updated the data in the control.
-- Otherwise, it updates the caption text of the control. /n
-- For StatusBar controls, the /i pID can also be used to specify
-- the subField to use. It takes the form of a 2-element sequence
-- {id, subfield}.
--
-- Example:
--
--/code
--      -- change the caption of status bar
--      /setText( TheStatusBar, "Ready" )
--      -- If a statusbar has subfields, you can specify
--      -- them like:
--      setText( {TheStatusBar,2}, "2nd subField")
--/endcode

global procedure setText( object pID, object pText )

    -- set the text in a window

    atom lHandle, lTCMITEM, lMenu
    integer id, lPart, lPartCnt
    sequence s
    integer lPosn
    integer tabNumber, owner

    if atom(pID) then
        id = pID
        lPart = 1
    else
        id = pID[1]
        lPart = pID[2]
    end if

    if validId(id) = w32False then
        return
    end if

    if and_bits(classAttr[ctrl_Type[id]], w32PictCtrl ) != 0
      or
       (ctrl_Parent[id] != 0
           and
        ctrl_Type[ ctrl_Parent[id] ] = FlatToolBar
       ) then
        return
    end if

    if atom(pText) then
        s = sprintf("%g", pText)
    elsif length(pText) = 2 and sequence(pText[1]) then
        s = sprintf(pText[1], pText[2])
    else
        s = pText
    end if

    if ctrl_Type[ id ] = StatusBar then

        -- send the text to the statusbar
        VOID = sendMessage( id, SB_SETTEXT,    lPart-1, s)
        VOID = sendMessage( id, SB_SETTIPTEXT, lPart-1, s)

    elsif find(ctrl_Type[id], {MenuItem, MenuSpacer, Menu}) then
        -- Get Menu's handle

        owner = ctrl_Parent[id]
        lHandle = ctrl_Menu[id][1]
        lMenu = ctrl_Menu[id][3]

        VOID = w32Func(xModifyMenu, {lHandle, lMenu, MF_BYCOMMAND, lMenu, s})
        VOID = w32Func(xDrawMenuBar, { getHandle(findParentWindow( id)) } )

    elsif ctrl_Type[id] = TreeView then

        if lPart > 0 and lPart <= length(tvitem_data) then
            w32release_mem(tvitem_data[lPart][ktv_TextAddr])
            tvitem_data[lPart][ktv_TextAddr] = w32acquire_mem(0, s )
            tvitem_data[lPart][ktv_TextSize] = length(s)
        end if

    elsif ctrl_Type[id] = TabItem then

        owner = ctrl_Parent[id]
        tabNumber = find(id, ctrl_Tabitems[ owner ]) - 1
        if tabNumber >= 0 then
            -- Allocate a tab structure
            lTCMITEM = w32acquire_mem( 0, SIZEOF_TC_ITEM )

            -- set the items
            w32store( lTCMITEM, TC_ITEM_mask,       TCIF_TEXT )
            w32store( lTCMITEM, TC_ITEM_pszText,    s )
            w32store( lTCMITEM, TC_ITEM_cchTextMax, length(s) )
            -- Change text in tabitem
            VOID = sendMessage( owner, TCM_SETITEM, tabNumber, lTCMITEM )
            w32release_mem(lTCMITEM)

            repaintWindow(0)

        end if

    elsif find(ctrl_Type[id], {CheckBox, TriCheckBox, Radio}) then
        lPosn = -1
        if equal(s,"0") then
            lPosn = 0
        elsif equal(s,"2") then
            lPosn = 2
        elsif equal(s,"1") then
            lPosn = 1
        end if
        if lPosn >= 0 then
            VOID = sendMessage( id, BM_SETCHECK, lPosn, 0 )
        else
            VOID = w32Func( xSetWindowText, { getHandle( id ), s } )
        end if

    else
        -- For Mle, change single LF to CRLF
        if ctrl_Type[id] = MleText then
            lPosn = 1
            while w32True do
                if lPosn > length(s) then
                    exit
                end if
                if s[lPosn] = 10 then
                    if lPosn = 1 or
                        s[lPosn-1] != 13 then
                        s = s[1 .. lPosn-1] & 13 & s[lPosn..length(s)]
                        lPosn += 1
                    end if
                end if

                lPosn += 1
            end while
        end if
        -- set the window text
        VOID = w32Func( xSetWindowText, { getHandle( id ), s } )

    end if

end procedure
r_setText = routine_id("setText")

-----------------------------------------------------------------------------
--/topic Values
--/proc setSelectedText( integer object, sequence text )
--/desc Replaces the selected text in /i object with /i text.
-- This only works with edit text controls.
--
-- Example:
--
--/code
--      -- add HTML formatting to the selected text
--      text = /getSelectedText( TheMle )
--      /setSelectedText( TheMle, "~<I>" & text & "~</I>" )
--/endcode
global procedure setSelectedText( integer id, sequence text )

    atom addrText, result

    -- is there any text selected?
    result = sendMessage( id, EM_GETSEL, NULL, NULL )
    if result != -1 and w32lo_word( result ) <= w32hi_word( result ) then

        -- convert to lpsz
        addrText = w32acquire_mem(0, text )

        -- replace selection; w32True means allow undo
        result = sendMessage( id, EM_REPLACESEL, w32True, addrText )

        -- Free the string
        w32release_mem( addrText )

    end if

end procedure


-----------------------------------------------------------------------------
--/topic Text
--/func drawText(integer id, sequence text, object rect, object flags, integer tabsize, integer left, integer right)
--/desc Places the text into the rectangle (/i rect) wrapping words if necessary.
--/ret SEQUENCE: {height, count, {left, top, right, bottom} }
-- This returns a sequence of three values: The height, in pixels, of the text drawn, and
-- the number of characters used that could fit into the rectangle specified, and the
-- dimensions of the rectangle used. This rectangle is returned in the same format as
-- the input parameter /i rect
--
--Example:
--/code
--          sequence result
--          sequence rect
--          result = drawText(myWind, "Fourscore and twenty years ago, our fathers, ...",
--                   {5,5,140, 75}, DT_WORDBREAK, 4, 0, 0)
--          textheight = result[1]
--          textcnt= result[2]
--          rect = result[3]
--/endcode

global function drawText(integer id, object text, object rect,
                         object flags, integer tabsize,integer left,integer right)
    atom hdc, lRect, lDT, memset
    integer sLen
    atom lHeight
    sequence result
    sequence lBorders


    -- Check for formatting
    if atom(text) then
        text = sprintf("%g", text)
        sLen = length( text )
    elsif length(text) = 2 and sequence(text[1]) then
        text = sprintf(text[1], text[2])
        sLen = length( text )
    elsif length(text) >= 2 and atom(text[1]) and text[1] = -1 and atom(text[2]) then
        if length(text) = 3 then
            sLen = text[3]
        else
            sLen = -1 -- Let windows find out.
        end if

        text = text[2] -- RAM address of text.
    else
        sLen = length( text )
    end if

    -- set the font

    hdc = assignFont( id)

    memset = w32new_memset()
    lRect = w32acquire_mem(memset, SIZEOF_RECT)
    lDT = w32acquire_mem(memset, SIZEOF_DRAWTEXTPARAMS)


    if atom(rect) then
        rect = getClientRect(id)
        lBorders = {0,0,0,0}
    elsif length(rect) = 2 then
        lBorders = rect[2]
        if atom(rect[1]) then
            rect = getClientRect(id)
        else
            rect = rect[1]
        end if
    else
        lBorders = {0,0,0,0}
    end if
    poke4(lRect, rect[1..4]+lBorders)

    w32store(lDT, DTP_cbSize, SIZEOF_DRAWTEXTPARAMS)
    w32store(lDT, DTP_iTabLength, tabsize)
    w32store(lDT, DTP_iLeftMargin, left)
    w32store(lDT, DTP_iRightMargin, right)

    if sequence(flags) then
        flags = w32or_all(flags)
    end if
    -- display the text in the buffer
    lHeight = w32Func( xDrawTextEx, { hdc, text, sLen,
                lRect, flags, lDT
                } )

    -- release the device context
    releaseDC( id )

    result = {lHeight, w32fetch(lDT, DTP_uiLengthDrawn),peek4u({lRect,4})}
    w32release_mem(memset)

    return result
end function

-----------------------------------------------------------------------------
--/topic Text
--/func textRect(integer id,sequence text,object rect,object flags,integer tabsize,integer left,integer right)
--/desc Calculates the RECT structure need to draw all the text.
--/ret SEQUENCE: {left, top, right, bottom}
--/l rect defines the left, top and maximum right pixel (for multiple line text)
--Example:
--/code
--          sequence result
--          result = textRect(myWind, "Fourscore and twenty years ago, our fathers, ...",
--                   {5,5,140, 75}, DT_WORDBREAK, 4, 0, 0)
--/endcode
global function textRect(integer id, object text, object rect,
                         object flags, integer tabsize,integer left,integer right)

    atom hdc, lRect, lDT, memset
    integer sLen
    atom lHeight
    sequence result
    sequence lBorders

    -- Check for formatting
    if atom(text) then
        text = sprintf("%g", text)
        sLen = length( text )
    elsif length(text) = 2 and sequence(text[1]) then
        text = sprintf(text[1], text[2])
        sLen = length( text )
    elsif length(text) >= 2 and atom(text[1]) and text[1] = -1 and atom(text[2]) then
        if length(text) = 3 then
            sLen = text[3]
        else
            sLen = -1 -- Let windows find out.
        end if

        text = text[2] -- RAM address of text.
    else
        sLen = length( text )
    end if

    -- set the font
    hdc = assignFont( id)

    memset = w32new_memset()
    lRect = w32acquire_mem(memset, SIZEOF_RECT)
    lDT = w32acquire_mem(memset, SIZEOF_DRAWTEXTPARAMS)

    if atom(rect) then
        rect = getClientRect(id)
        lBorders = {0,0,0,0}
    elsif length(rect) = 2 then
        lBorders = rect[2]
        if atom(rect[1]) then
            rect = getClientRect(id)
        else
            rect = rect[1]
        end if
    else
        lBorders = {0,0,0,0}
    end if
    poke4(lRect, rect[1..4]+lBorders)

    w32store(lDT, DTP_cbSize, SIZEOF_DRAWTEXTPARAMS)
    w32store(lDT, DTP_iTabLength, tabsize)
    w32store(lDT, DTP_iLeftMargin, left)
    w32store(lDT, DTP_iRightMargin, right)

    if sequence(flags) then
        flags = w32or_all(flags)
    end if
    flags = or_bits(flags , DT_CALCRECT)
    -- calc the rect needed for the text in the buffer
    lHeight = w32Func( xDrawTextEx, { hdc, text, sLen,
                lRect, flags, lDT
                } )

    -- release the device context
    releaseDC( id )

    result = {lHeight, w32fetch(lDT, DTP_uiLengthDrawn),peek4u({lRect,4})}
    w32release_mem(memset)

    return result
end function

--/topic Values
--/func getCaption( integer id)
--/desc This returns any caption text associated with /i id
--/ret SEQUENCE: The caption text.
--The type of controls that have caption text are windows, menus, labels, and buttons.
-- Other controls will return "".
--
--Example:
--/code
--      sequence ctext
--      sequence clst
--      clst = {Btn1, Btn2, MenuItem3, Radio1, Checkbox2}
--      for i = 1 to length(ctext) do
--          ctext[i] = ReplaceText(getCaption(clst[i]), "all", "some")
--          setCaption(clst[i], ctext[i])
--      end for
--/endcode

global function getCaption(integer pId)
    sequence lCapText
    integer at, iLength, result, id, lPart, lNumParts
    atom buffer, lGetMsg, lLenMsg, lHandle
    sequence text
    atom lmh


    lCapText = ""

    if find(ctrl_Type[pId], {MenuItem, MenuSpacer, Menu}) then

        -- Get Menu's handle
        lHandle = ctrl_Menu[pId][1]
        lmh = ctrl_Menu[pId][3]
        -- Get the buffer size required
        lLenMsg = w32Func(xGetMenuString, {lHandle, lmh, 0, 0, MF_BYCOMMAND})+1
        if lLenMsg <= 1 then
            lLenMsg = w32Func(xGetMenuString, {lHandle, pId, 0, 0, MF_BYCOMMAND})+1
            lmh = pId
        end if
        -- Allocate enough room
        buffer = w32acquire_mem(0, lLenMsg)
        -- Get the current menu item lCapText
        VOID = w32Func(xGetMenuString, {lHandle, lmh, buffer, lLenMsg,
                        MF_BYCOMMAND})
        lCapText = w32peek_string(buffer)
        w32release_mem(buffer)


    elsif find(ctrl_Family[pId], {WINDOW, BUTTON, STATIC}) then
        iLength = sendMessage( pId, WM_GETTEXTLENGTH, 0, 0 )
        if iLength > 0 then
            iLength += 1
            buffer = w32acquire_mem(0, iLength )

            iLength = sendMessage( pId, WM_GETTEXT, iLength, buffer )
            lCapText = peek( {buffer, iLength} )
            w32release_mem( buffer )

        end if

    end if

    return lCapText
end function
r_getCaption = routine_id("getCaption")

--/topic Values
--/func getData( object id)
--/desc This returns any data value associated with /i id
--/ret SEQUENCE: The data as a text string.
-- Note that Menuitems, Radio, Checkbox and TriCheckbox controls
-- return a single character string of "0", "1", or "2" for
-- Unchecked, Checked, and Neither respectively.
--
-- For statusbars and treeviews, /i id can be a 2-element sequence containing
-- {ControlID, Panel#} to get the value of a specific sub-panel
-- of the statusbar, or treeview item.
--
-- For /i RichEdit controls, this returns the selected text only.
--
-- For ListView controls, this returns a sequence that contains one element
-- for each selected item in the ListView. Each element is itself a sequence
-- that contains an string element for each column in the ListView. /n
-- /i "ListView example:" /b
--/code
--      sequence text
--      text = getData(myListView)
--      -- If two rows were selected then the returned value
--      -- may look like this ...
--  { { "Col 1 data", "Col 2 data", "Col 3 data", ...}, -- 1st selected row
--    { "Col 1 data", "Col 2 data", "Col 3 data", ...}  -- 2nd selected row
--  }
--/endcode
--
-- For /i StatusBar controls, /i object can be a two-element sequence,
-- the /b first is the control's id, and the /b second is the section of
-- the status bar (this is zero-based). Also, this returns two-elements: /n
-- ~s~s[1] is the text, /n
-- ~s~s[2] is the rendering method. /n
--/define
--/term 0
--The text is drawn with a border to appear lower than the plane of the window.
--/term SBT_NOBORDERS
-- The text is drawn without borders.
--/term SBT_POPOUT
--The text is drawn with a border to appear higher than the plane of the window.
--/term SBT_RTLREADING
--The text will be displayed in the opposite direction to the text in the parent window.
--/enddefine
--
-- For /i /TreeView controls, /i id takes the form {TV, TVItemID}. Where /i TVItemID is the
-- id returned by /addTVItem(). To get the currently selected treeview item, use zero for
-- the /i TVItemID.
--
--Example:
--/code
--      sequence text
--      text[i] = getData(EditFld1)
--/endcode
global function getData(object pID)
    integer at, iLength, result, id, lPart, lNumParts
    atom buffer, lGetMsg, lLenMsg, lHandle
    sequence text
    atom lmh
    sequence items

    if atom(pID) then
        id = pID
        lPart = 0
    else
        -- Get sub-item for statusbar and treeview
        id = pID[1]
        lPart = pID[2] - 1
    end if
    text = ""

    if and_bits(classAttr[ ctrl_Type[id]], w32PictCtrl ) != 0
      or
       (ctrl_Parent[id] != 0
           and
        ctrl_Type[ ctrl_Parent[id] ] = FlatToolBar
       ) then
        -- Picture controls and things on a flattoolbar don't any data.
        return text
    end if

    -- edit controls
    -- get the text size

    if ctrl_Type[ id ] = RichEdit then
        -- return selection
        buffer = struct_CHARRANGE( 0, 0)
        VOID = sendMessage( id, EM_EXGETSEL, 0, buffer )
        result = w32fetch( buffer, CHARRANGE_cpMax ) -
  	                w32fetch( buffer, CHARRANGE_cpMin )
        w32release_mem(buffer)

        if result > 0 then
            buffer = w32acquire_mem(0, result + 1 ) --  add 1 for '/0' character.
            iLength = sendMessage( id, EM_GETSELTEXT, 0, buffer )
            text = peek( {buffer , iLength})
            w32release_mem( buffer )
        end if

    elsif ctrl_Type[ id ] = StatusBar then
        lNumParts = sendMessage( id, SB_GETPARTS, 0, 0 ) - 1
        if lPart < 0 or lPart > lNumParts then
            lPart = 0
        end if
        iLength = sendMessage( id, SB_GETTEXTLENGTH, lPart, 0 )
        if iLength > 0 then
            iLength += 1
            buffer = w32acquire_mem(0, iLength )

            result = sendMessage( id, SB_GETTEXT, lPart, buffer )
            iLength = w32lo_word( result )
            lPart   = w32hi_word( result )
            text = peek( {buffer, iLength} )
            w32release_mem( buffer )

        end if

    elsif find(ctrl_Type[id], {MenuItem, MenuSpacer, Menu}) then
            if call_func(r_isChecked,{id}) then
                text = "1"
            else
                text = "0"
            end if

    elsif ctrl_Type[id] = TreeView then
        lPart += 1
        if lPart = 0 then
            return getTVSelectedText(id)
        else
            return getTVText(lPart)
        end if

    elsif find(ctrl_Type[id], {Combo, SortedCombo, SimpleCombo, DropDownList,
                                  ComboBoxEx} ) and
           vWMI > 0 and vWinMsg[vWMI][3] = WM_COMMAND
           and w32hi_word(vWinMsg[vWMI][4]) = CBN_SELCHANGE then
            -- Get the selected item rather than the old value in edit box.
            return call_func(r_getItem,{id, 0})

    elsif find(ctrl_Type[id], {SortedList, List}) then
        return call_func(r_getItem,{id,0})

    elsif find(ctrl_Type[id], {ListView}) then
        -- Get a list of all the selected items.
        items = call_func(r_getIndex,{id})
        -- Get each row of data from the selected items
        text = {}
        for i = 1 to length(items) do
            text = append(text, call_func(r_getLVItemText,{id, items[i], -1}))
        end for

    elsif find(ctrl_Type[id], {CheckBox, TriCheckBox, Radio}) then
        -- Get its checked value
        iLength = sendMessage( id, BM_GETCHECK, 0, 0 )
        text = sprintf("%d", iLength)

    else
        iLength = sendMessage( id, WM_GETTEXTLENGTH, 0, 0 )
        if iLength > 0 then
            iLength += 1
            buffer = w32acquire_mem(0, iLength )

            iLength = sendMessage( id, WM_GETTEXT, iLength, buffer )
            text = peek( {buffer, iLength} )
            w32release_mem( buffer )

        end if

    end if

    return text

end function
r_getData = routine_id("getData")

-----------------------------------------------------------------------------
--/topic Values
--/func getText( object id)
--/desc Get the text in /i object.
--/ret Text in id's caption or text area.
-- This returns the control's caption if it has one, otherwise it returns
-- its value.
--
-- See also: /getCaption and /getData
--
-- Example:
--
--/code
--      -- get the text from TheTextEdit
--      sequence text
--
--      text = /getText( TheTextEdit )
--      tvtext = /getText ( {myTreeView, itemid} )
--      tvselectedtext = /getText ( {myTreeView, 0} )
--      -- get the contents of the second panel in the statusbar.
--      sbtext = /getText( {StatBar, 2})
--
--      btnCaption = getText( myBtn )
--/endcode

global function getText( object pID )

    sequence text

    if atom(pID) then
        text = getCaption(pID)
        if length(text) = 0 then
            text = getData(pID)
        end if
    else
        text = getData(pID)
    end if


    return text

end function
r_getText = routine_id("getText")

--/topic Values
--/func getValues( integer Context, sequence Ids)
--/desc Gets the values from one or more specified controls.
--/ret SEQUENCE: A list of values, in the same order as the controls in /i Ids
--This gets the values for each of the controls specified in /i Ids. The
--controls can be specified as either a control ID (integer) or a control name.
--
--If your application has multiple controls with the same name, you can specify
--a context for this routine to limit the search to. This is usually the Window
--that the requested controls belong to.
--
--Example:
--/code
--      sequence lValues
--      lValues = getValues(CustWin, {"Name", "Address", "ZIP", "Telephone"})
--/endcode
global function getValues(integer pContext, sequence pIds)
    sequence lKids
    sequence lFldName
    sequence lValues

    lValues = repeat(0, length(pIds))
    if pContext <= 0 then
        -- No context specified
        for j = 1 to length(pIds) do
            if sequence(pIds[j]) then
                -- Convert a name to an id.
                pIds[j] = getNameId(pIds[j])
            end if
            lValues[j] = getText(pIds[j])
        end for
    else
        lKids = ctrl_Group[pContext]
        for i = 1 to length(lKids) do
            lFldName = getIdName(lKids[i])
            for j = 1 to length(pIds) do
                if sequence(pIds[j]) then
                    if equal(lFldName, pIds[j]) then
                        lValues[j] = getText(lKids[i])
                        exit
                    end if
                elsif find(pIds[j], lKids) then
                    lValues[j] = getText(pIds[j])
                    exit
                end if
            end for
        end for
    end if

    return lValues
end function


-----------------------------------------------------------------------------
--/topic Values
--/func getNumber( object )
--/desc Get the numeric value of text from /i object.
--/ret Numeric value of the control's text/caption value.
--
-- This uses /w32TextToNumber() function to do the conversion. /n
-- If the text value cannot be converted to a numeric value, zero is return.
--
-- Example:
--/code
--      -- get the numeric value from TheTextEdit
--      atom number
--
--      number = /getNumber( TheTextEdit )
--/endcode

global function getNumber( integer id )
    -- get the numeric value of text
    sequence text, result

    -- convert the value of the text
    return w32TextToNumber( getData( id ) )
end function


-----------------------------------------------------------------------------
--/topic Values
--/func getSelectedText( object )
--/desc Get the selected text in /i object.
--/ret Selected text, or empty sequence if nothing is selected.
-- This only works with text edit controls.
--
-- Example:
--
--/code
--      -- get the selected text from TheTextEdit
--      sequence text
--
--      text = /getSelectedText( TheTextEdit )
--/endcode
global function getSelectedText( integer id )

   integer firstPos, lastPos
   atom result
   sequence text

   -- get the range of selected text
    if ctrl_Type[id] = RichEdit then
        return getText( id )
    end if

   result = sendMessage( id, EM_GETSEL, NULL, NULL )
   firstPos = w32lo_word( result )
   lastPos  = w32hi_word( result )

   -- is any text selected?
   if firstPos < lastPos then

    -- get all the text text from the mle
    text = getText( id )

    -- get the selected portion of the text
    return text[firstPos+1 .. lastPos]

    else
    -- no text selected
    return ""

   end if


end function

--/topic Attributes
--/proc addToBand( id, band )
--/desc Add a control /i id to a /RebarBand /i band

global procedure addToBand( integer id, integer band )
    atom rb, bandIndex
    sequence size
    atom hWndRebar

    size = getCtlSize( id )

    hWndRebar = getHandle(ctrl_Parent[band])
    bandIndex = w32Func(xSendMessage,{hWndRebar, RB_IDTOINDEX, band, 0})

    rb = struct_REBARBANDINFO(
        w32or_all( {RBBIM_CHILD, RBBIM_CHILDSIZE,RBBIM_TEXT} ), -- fMask
        0,          -- fStyle
        0,          -- clrFore
        0,          -- clrBack
        getText( id ), -- lpText
        0,          -- iImage
        ctrl_Handle[ id ],  -- hwndChild
        0,          -- cxMinChild
        size[2],    -- cyMinChild
        size[1],    -- cx
        0,          -- hbmBack
        id,         -- wID
        0,          -- cyChild
        0,          -- cyMaxChild
        0,          -- cyIntegral
        0,          -- cxIdeal
        0,          -- lParam
        0 )         -- cxHeader

    VOID = w32Func(xSendMessage,{ hWndRebar, RB_SETBANDINFO, bandIndex, rb })

    w32release_mem( rb )

end procedure
r_addToBand = routine_id("addToBand")

--/topic Utilities
--/func struct_SYSTEMTIME(year,month,dayofweek,day,hour,minute,second,milliseconds)
global function struct_SYSTEMTIME( integer year, integer month,
    integer dayofweek, integer day, integer hour, integer minute,
    integer second, integer milliseconds )

    atom st

    st = w32acquire_mem(0,  SIZEOF_SYSTEMTIME )

    w32store( st, SYSTEMTIME_wYear, year )
    w32store( st, SYSTEMTIME_wMonth, month )
    w32store( st, SYSTEMTIME_wDayOfWeek, dayofweek )
    w32store( st, SYSTEMTIME_wDay, day )
    w32store( st, SYSTEMTIME_wHour, hour )
    w32store( st, SYSTEMTIME_wMinute, minute )
    w32store( st, SYSTEMTIME_wSecond, second )
    w32store( st, SYSTEMTIME_wMilliseconds, milliseconds )

    return st

end function

--/topic Utilities
--/func fetch_SYSTEMTIME(atom SYSTEMTIME)
global function fetch_SYSTEMTIME( atom st )
    return {
	    w32fetch( st, SYSTEMTIME_wYear ),
	    w32fetch( st, SYSTEMTIME_wMonth ),
	    w32fetch( st, SYSTEMTIME_wDayOfWeek ) + 1,
	    w32fetch( st, SYSTEMTIME_wDay ),
	    w32fetch( st, SYSTEMTIME_wHour ),
	    w32fetch( st, SYSTEMTIME_wMinute ),
	    w32fetch( st, SYSTEMTIME_wSecond ),
	    w32fetch( st, SYSTEMTIME_wMilliseconds)
        }
end function

--/topic Utilities
--/func getSystemTime()
--/desc Gets the date and time as UTC (a.k.a. GMT)
--/ret SEQUENCE: The date and time (See below for details)
--This does not need any parameters. The date and time are returned
-- as UTC (Coordinated Universal Time) which is the old Greenwich Mean Time.
--
--The return sequence has eight elements arranged thus /n
--/li      Year
--/li      Month
--/li      DayOfWeek
--/li      Day
--/li      Hour
--/li      Minute
--/li      Second
--/li      Milliseconds
--
--Example:
--/code
--      sequence tm
--      tm = getSystemTime()
--/endcode

global function getSystemTime()
    atom lST
    sequence lResult

    lST = w32acquire_mem(0, SIZEOF_SYSTEMTIME)
    w32Proc(xGetSystemTime,{lST})

    lResult = fetch_SYSTEMTIME(lST)
    w32release_mem(lST)
    return lResult

end function

--/topic Utilities
--/func getLocalTime()
--/desc Gets the date and time according to your timezone settings.
--/ret SEQUENCE: The date and time (See below for details)
-- This does not need any parameters. The date and time are returned
-- based on your system's current timezone settings.
--
--The return sequence has eight elements arranged thus /n
--/li      Year
--/li      Month
--/li      DayOfWeek
--/li      Day
--/li      Hour
--/li      Minute
--/li      Second
--/li      Milliseconds
--
--Example:
--/code
--      sequence tm
--      tm = getLocalTime()
--/endcode

global function getLocalTime()
    atom lST
    sequence lResult

    lST = w32acquire_mem(0, SIZEOF_SYSTEMTIME)
    w32Proc(xGetLocalTime,{lST})

    lResult = fetch_SYSTEMTIME(lST)
    w32release_mem(lST)
    return lResult

end function

--/topic MonthCalendar Control
--/func getSelectedDate( id )
--/desc Get the selected date in a /MonthCalendar Control
--/ret { Year, Month, DayOfWeek, Day, }
-- This cannot be used with a /MonthCalendar control with style /b MCS_MULTISELECT.
global function getSelectedDate( integer id )
    sequence DATE
    atom ok
    sequence result

    DATE = { w32acquire_mem(0,  SIZEOF_SYSTEMTIME * 2 ), SIZEOF_SYSTEMTIME }

    DATE[2] += DATE[1]
    ok = sendMessage( id, MCM_GETCURSEL, 0, DATE[1] )

    if not ok then
        ok = sendMessage( id, MCM_GETSELRANGE, 0, DATE[1] )
        if ok = 0 then
            return {}
        end if
    end if

    result = fetch_SYSTEMTIME( DATE[1] )
    w32release_mem( DATE[1] )

    return result[1 .. 4]

end function

--/topic MonthCalendar Control
--/proc setSelectedDate( id, year, month, day )
--/desc Set the selection in a /MonthCalendar Control
-- This cannot be used with a /MonthCalendar control with style /b MCS_MULTISELECT.
global procedure setSelectedDate( integer id, integer year, integer month,
    integer day )
    atom st

    st = struct_SYSTEMTIME( year, month, 0, day, 0, 0, 0, 0)
    VOID = sendMessage( id, MCM_SETCURSEL, 0, st )

    w32release_mem( st )
end procedure

--/topic MonthCalendar Control
--/func getSelectedDateRange( id )
--/desc Get selected range of dates in a /MonthCalendar Control
--/ret { beginDate, endDate }
-- /i beginDate, /i endDate are sequences of the form:
-- { year, month, dayofweek, day }
--
global function getSelectedDateRange( integer id)
    sequence result, DATE

    DATE = { w32acquire_mem(0,  SIZEOF_SYSTEMTIME * 2 ), SIZEOF_SYSTEMTIME }

    DATE[2] += DATE[1]

    VOID = sendMessage( id, MCM_GETSELRANGE, 0, DATE[1] )

    if VOID = 0 then
        VOID = sendMessage( id, MCM_GETCURSEL, 0, DATE[1] )
        if VOID = 0 then
            return {}
        end if
        DATE[2] = DATE[1]
    end if

    result = {  fetch_SYSTEMTIME( DATE[1] ),
	    fetch_SYSTEMTIME( DATE[2] ) }

    result[1] = result[1][1 .. 4]
    result[2] = result[2][1 .. 4]

    w32release_mem( DATE[1] )

    return result
end function

--/topic MonthCalendar Control
--/proc setSelectedDateRange( id, beginDate, endDate )
--/desc Set the selected range in a /MonthCalendar Control.
-- This can only be used with a /MonthCalendar control with style /b MCS_MULTISELECT.
global procedure setSelectedDateRange( integer id, sequence d1, sequence d2 )
    sequence st, DATE

    DATE = { d1, d2 }
    st = { w32acquire_mem(0, SIZEOF_SYSTEMTIME * 2 ), SIZEOF_SYSTEMTIME }
    st[2] += st[1]

    for i = 1 to 2 do
    w32store( st[i], SYSTEMTIME_wYear, DATE[i][1] )
    w32store( st[i], SYSTEMTIME_wMonth, DATE[i][2] )
    w32store( st[i], SYSTEMTIME_wDayOfWeek, DATE[i][3] )
    w32store( st[i], SYSTEMTIME_wDay, DATE[i][4] )
    end for

    VOID = sendMessage( id, MCM_SETSELRANGE, 0, st[1] )

    w32release_mem( st[1] )

end procedure

--/topic MonthCalendar Control
--/proc setMaxDateRange( id, range )
--/desc Sets the maximum number of days that can be selected.
-- This can only be used with a /MonthCalendar control with style /b MCS_MULTISELECT.
global procedure setMaxDateRange( integer id, integer r )
    VOID = sendMessage( id, MCM_SETMAXSELCOUNT, r, 0 )
end procedure

--/topic MonthCalendar Control
--/proc setMonthColor( integer id, object iColor, atom Flag )
--/desc Change color of a /MonthCalendar Control
-- /i Flag must be one of the folowing values:
-- /li /b MCSC_BACKGROUND
-- /li /b MCSC_TEXT
-- /li /b MCSC_TITLEBK
-- /li /b MCSC_TITLETEXT
-- /li /b MCSC_MONTHBK
-- /li /b MCSC_TRAILINGTEXT
global procedure setMonthColor( integer id, object iColor, atom cr )
    VOID = sendMessage( id, MCM_SETCOLOR, colorValue(iColor), cr )
end procedure

global constant
ShortDate = 0,      -- 7/31/00
LongDate = 1,       -- Monday, July 31, 2000
MediumDate = 2      -- 31-Jul-00

--/topic MonthCalendar Control
--/func formatDate( date, format )
--/desc Format a system date as returned by /getSelectedDate, /getSelectedDateRange
--/ret Formatted date
-- /i format must be one of the following:
-- /li /b ShortDate:    "7/31/00"
-- /li /b MediumDate:   "31-Jul-00"
-- /li /b LongDate:     "Monday, July 31, 2000"
global function formatDate( sequence d, integer f )
    sequence result, temp

    if f = ShortDate then
    temp = sprint( d[1] )
    result = sprint( d[2] ) & "/" & sprint( d[4] ) & "/" &
	        temp[length(temp)-1 .. length(temp)]

    elsif f = LongDate then
    result = Days[ d[3] ] & ", " & Months[LongMonths][ d[2] ] &
        " " & sprint( d[4] ) & ", " & sprint( d[1] )

    elsif f = MediumDate then
    temp = sprint( d[1] )
    result = sprint( d[4] ) & "-" & Months[ShortMonths][ d[2] ] &
	        "-" & temp[length(temp)-1 .. length(temp)]

    end if

    return result
end function

--/topic MonthCalendar Control
--/func getToday( integer id )
--/desc Returns today's date from the MonthCalendar control /i id
--ret SEQUENCE: { Year, Month, Day, DayOfWeek }
--
--Example:
--/code
--      sequence td
--      td = getToday( myMC )
--      setText(flddate, {"%02d/%02d/%4d", td[1..3]})
--/endcode

global function getToday( integer id )
    atom lSysTime
    sequence lToday

    lSysTime = w32acquire_mem(0, SIZEOF_SYSTEMTIME )
    lToday = repeat(0, 4)

    if sendMessage( id, MCM_GETTODAY, 0, lSysTime ) then

        lToday[1] = w32fetch( lSysTime, SYSTEMTIME_wYear )
        lToday[2] = w32fetch( lSysTime, SYSTEMTIME_wMonth )
        lToday[3] = w32fetch( lSysTime, SYSTEMTIME_wDay )
        lToday[4] = w32fetch( lSysTime, SYSTEMTIME_wDayOfWeek )

    end if

    w32release_mem( lSysTime )
    return lToday
end function


--/topic MonthCalendar Control
--/proc setToday( integer id, integer pYear, integer pMonth, integer pDay )
--/desc Set the 'today' date in the MonthCalendar control /i id
--
--Example:
--/code
--      Set the date to 23rd of November, 2004
--      setToday( myMC , 2004, 11, 23)
--/endcode
global procedure setToday( integer id, integer pYear, integer pMonth, integer pDay )
    atom lSysTime

    lSysTime = w32acquire_mem(0, SIZEOF_SYSTEMTIME )
    w32store( lSysTime, SYSTEMTIME_wYear,  pYear )
    w32store( lSysTime, SYSTEMTIME_wMonth, pMonth )
    w32store( lSysTime, SYSTEMTIME_wDay,   pDay )

    VOID = sendMessage( id, MCM_SETTODAY, 0, lSysTime )
    w32release_mem( lSysTime )

end procedure

--/topic Updown Control
--/proc setBuddy( id, buddy )
--/desc Set the buddy control of an /UpDown control
global procedure setBuddy( integer id, integer buddy )
    VOID = sendMessage( id, UDM_SETBUDDY, getHandle( buddy ), 0)
end procedure
r_setBuddy = routine_id("setBuddy")


-----------------------------------------------------------------------------
--/topic Attributes
--/proc setVisible( object id, atom flag )
--/desc Make /i id visible or invisible.
-- /i id can also be a sequence of control ids.
-- Example:
--/code
--          -- make TheButton invisible
--          /setVisible( TheButton, w32False )
--          -- Hide lists one and two.
--          /setVisible( {List1, List2}, w32False )
--          -- Show lists three and four.
--          /setVisible( {List3, List4}, w32True )
--/endcode
--
-- /b Note: If /i object is a /Window being made visible, it will trigger
-- an /onOpen event. However, if it is a /Window being made invisible, it
-- will not trigger any event. This should probably be corrected.

global procedure setVisible( object id, atom flag )

    if flag then
        -- show a window
        flag = SW_SHOWNORMAL
    else
        -- hide a window
        flag = SW_HIDE
    end if

    if sequence(id) then
        for i = 1 to length(id) do
            setVisible(id[i], flag)
        end for
        return
    end if
    if validId(id) then
        VOID = w32Func( xShowWindow, { getHandle( id ), flag } )
    end if

end procedure
r_setVisible = routine_id("setVisible")

-----------------------------------------------------------------------------
--/topic Attributes
--/proc isVisible( object )
--/desc Returns the visibility state of /i object.
-- /b Note: A TabItem is always visible.
-- Example:
--/code
--          -- is TheButton visible?
--          integer flag
--
--          flag = /isVisible( TheButton )
--/endcode

global function isVisible( integer id )

    if not validId(id) then
        return w32False
    end if

    if ctrl_Type[ id ] = TabItem then
        -- always visible
        return w32True
    else
        -- return hidden state of control
        return (w32Func( xIsWindowVisible, { getHandle( id ) } ) != 0)

    end if

end function
r_isVisible = routine_id("isVisible")

-----------------------------------------------------------------------------
--/topic Attributes
--/proc setEnable( object id, atom flag )
--/desc Enable or disable /i id.
-- /i id can be a sequence of control ids.
--
-- Example:
--/code
--          -- disable TheButton
--          /setEnable( TheButton, w32False )
--          -- Disable lists one and two.
--          /setEnable( {List1, List2}, w32False )
--          -- Enable lists three and four.
--          /setEnable( {List3, List4}, w32True )
--/endcode

global procedure setEnable( object id, atom flag )
    -- enable/disable an item
    sequence lKids
    atom lHandle
    integer lControl

    if sequence(id) then
        for i = 1 to length(id) do
            setEnable(id[i], flag)
        end for
        return
    end if


    lHandle = getHandle( id )
    if ctrl_Family[ id ] = MENU
    or ctrl_Family[ id ] = MENUITEM then

        -- convert the flag
        flag = w32iff( flag, MF_ENABLED, w32or_all( {MF_DISABLED, MF_GRAYED} ) )

        -- enable/disable the menu
        if w32Func( xEnableMenuItem, {
    	        lHandle,        -- menu handle
    	        id,                     -- id
    	        flag} )= #FFFFFFFF      -- enable/disble
        then
            -- item does not exist
            warnErr( Err_SETENABLE )
        end if

        -- if menubar, need to redraw
        if ctrl_Family[ id ] = MENU then
            VOID = w32Func( xDrawMenuBar, { ctrl_Parent[ id ] } )
        end if

    elsif ctrl_Family[id] = BUTTON
        and ctrl_Type[ctrl_Parent[id]] = FlatToolBar then
            flag = sendMessage( ctrl_Parent[id], TB_ENABLEBUTTON, id, flag )

    else
        if find(ctrl_Type[id],{ FlatToolBar, ToolBar}) then
            lKids = findChildren(id)
            for i = 1 to length(lKids) do
                setEnable(lKids[i][1], flag)
            end for
        end if
        -- enable/disable the window
        w32Proc( xEnableWindow, { lHandle, flag } )

        -- Show visualisation of enabled/disabled control
        if flag = 0  then
            if (findParent(id) != 0) and  (not and_bits(classAttr[ctrl_Type[id]], w32NoRenderDisabled)) then
                setWindowBackColor(id, ctrl_Bg_Color[findParent(id)])
            end if
        else
            lControl = ctrl_Type[id]
            if equal(classBGColor[lControl], w32BGTransparent) then
                if findParent(id) = 0 then
                    lControl = id
                else
                    lControl = findParent(id)
                end if
                setWindowBackColor( id, ctrl_Bg_Color[lControl])
            else
                setWindowBackColor( id, classBGColor[ lControl])
            end if

        end if

    end if

end procedure
r_setEnable = routine_id("setEnable")

-----------------------------------------------------------------------------
--/topic Attributes
--/func isEnabled( integer id )
--/desc Returns the enabled state of /i object.
--/ret INTEGER: Zero if no enabled, Non-zero if enabled.
-- /b Note: A TabItem is always enabled.
-- Example:
--/code
--          -- is TheButton enabled?
--          integer flag
--
--          flag = /isEnabled( TheButton )
--/endcode
global function isEnabled( integer id )

    -- return enabled state of control
    atom result
    if not validId(id) then
        return w32False
    end if


    if ctrl_Family[ id ] = MENU
    or ctrl_Family[ id ] = MENUITEM then
    -- true if not disabled
    return not and_bits( getMenuState(id), MF_DISABLED )

    elsif ctrl_Type[ id ] = TabItem then
        -- always enabled
        return w32True

    else
    -- control
    return (w32Func( xIsWindowEnabled, { getHandle( id ) } ) != 0)

    end if

end function

-----------------------------------------------------------------------------
--/topic Attributes
--/func isMinimized( object )
--/desc Used to see if the window /i object is minimized (iconic) or not.
-- Example:
--/code
--          -- Restore a minimized window?
--          if isMinimized( myWindow ) then
--             /showWindow( myWindow, SW_RESTORE)
--          end if
--/endcode
global function isMinimized( integer id )

    -- return enabled state of control
    integer result

    if   validId( id )
     and ctrl_Family[ id ] = WINDOW  then
        -- true if minimized, false otherwise
        return (w32Func(xIsIconic, {getHandle(id)}) != 0)
    else
        return 0
    end if

end function

-----------------------------------------------------------------------------
--/topic Attributes
--/func isMaximized( object )
--/desc Used to see if the window /i object is maximized (zoomed) or not.
-- Example:
--/code
--          -- Restore a maximized window?
--          if isMaximized( myWindow ) then
--             /showWindow( myWindow, SW_RESTORE)
--          end if
--/endcode
global function isMaximized( integer id )

    -- return enabled state of control
    integer result

    if   validId( id )
     and ctrl_Family[ id ] = WINDOW  then
        -- true if minimized, false otherwise
        return (w32Func(xIsZoomed, {getHandle(id)}) != 0)
    else
        return 0
    end if

end function

--/topic Menus
--/func struct_MENUITEMINFO()
--/desc Returns the RAM address of an empty MENUITEMINFO structure
--
-- You are required to release this memory when you have finished with it.
--
--Example:
--/code
--  atom hMII
--  hMII = struct_MENUITEMINFO()
--  . . .
--  w32release_mem(hMII)
--/endcode
global function struct_MENUITEMINFO()
    atom hMII

    hMII = w32acquire_mem(0, SIZEOF_MENUITEMINFO)
    w32store(hMII, MENUITEMINFO_cbSize, SIZEOF_MENUITEMINFO)
    return hMII
end function

--/topic Menus
--/proc defineMenuRadioGroup( sequence ids)
--/desc Defines a set of menu items that form a radio-group
-- /i ids is a list of menuitems that form a logical group of items,
-- in which only one can be marked witha 'radio-button' icon. /n
-- This routine ensures that only one item from the group will be
-- marked. Any that were previously marked will be 'turned off'
--
-- Note 1. The items do not have to be in the same menu. /n
-- Note 2. A given menu item can only be in one radio group.
--
-- Example:
--/code
--      -- set the current loudness level.
--      /defineMenuRadioGroup({miPianissimo, miPiano, piModerato,
--                             miForte, miFortissimo})
--      . . .
--      /setCheck( miForte, w32True)
--/endcode
sequence vMenuItemGroups vMenuItemGroups = {}
global procedure defineMenuRadioGroup ( sequence ids )
    integer x
    if length(ids) = 0 then
        return
    end if

    -- Ensure that only valid menuitems are supplied.
    -- and remove all the ids from existing groups.
    for i = 1 to length(ids) do
        if validId(ids[i]) and find(ctrl_Type[ids[i]], {MenuItem, MenuSpacer}) then
            for j = 1 to length(vMenuItemGroups) do
                x = find(ids[i], vMenuItemGroups[j])
                if x != 0 then
                    vMenuItemGroups[j] = w32removeIndex(x, vMenuItemGroups[j])
                end if
            end for
        end if
    end for

    -- Delete any empty groups
    for i = 1 to length(vMenuItemGroups) do
        if length(vMenuItemGroups[i]) = 0 then
            vMenuItemGroups = w32removeIndex(i, vMenuItemGroups)
        end if
    end for

    -- Add this new group
    vMenuItemGroups = append(vMenuItemGroups, ids)
end procedure

-----------------------------------------------------------------------------
--/topic Values
--/proc setCheck( object id, checked flag )
--/desc Check or uncheck /i id.
-- This works for /MenuItems and toggle controls
-- such as /Radio, /CheckBox and /ToggleButton, and for ListViews
--
--Note that /i id can be either a single control id or
-- a list of control ids.
--
-- Example:
--/code
--      -- set a check on the SyntaxColoring option
--      /setCheck( SyntaxColoring, w32True )
--      /setCheck( {TBtn1, TBtn2, TBtn3}, w32False)
--/endcode
--
-- /b Note: For ListViews, the /i id is actually in the form {{id,row}}
-- so it knows which row to check. Take note of the double sequence syntax.
--/code
--      -- Add a check mark to row 2.
--      /setCheck( {{myLV, 2}}, w32True)
--/endcode
--
-- /b Note If /i id is a menu item which has been defined as being in
-- a menu item group (/defineMenuItemGroup), this routine turns on that
-- menu item.
-- This routine ensures that only one item from a menu radio group will be
-- marked. Any that were previously marked will be 'turned off'
--
-- Example:
--/code
--      -- set the current loudness level.
--      /defineMenuRadioGroup({miPianissimo, miPiano, piModerato,
--                             miForte, miFortissimo})
--      . . .
--      /setCheck( miForte, w32True)
--/endcode


global procedure setCheck( object  pControls, integer flag )
    atom hMII
    atom lType
    integer id
    integer row
    atom TV_ITEM, state, lFlags, mask

    if not sequence(pControls) then
        pControls = {pControls}
    end if

    for k = 1 to length(pControls) do
        if sequence(pControls[k]) then
            row = pControls[k][2]
            pControls[k] = pControls[k][1]
        end if

        id = pControls[k]

        if ctrl_Family[ id ] = MENU
        or ctrl_Family[ id ] = MENUITEM then
            hMII = 0
            -- First check for Radio Group membership
            for i = 1 to length(vMenuItemGroups) do
                if find(id, vMenuItemGroups[i]) then
                    -- First turn off all other items
                    if hMII = 0 then
                        hMII = struct_MENUITEMINFO()
                    end if

                    for j = 1 to length(vMenuItemGroups[i]) do
                        w32store(hMII, MENUITEMINFO_fMask,MIIM_STATE)
                        w32store(hMII, MENUITEMINFO_fState, MFS_UNCHECKED)
                        VOID = w32Func(xSetMenuItemInfo, {
                                       getHandle(vMenuItemGroups[i][j]),
                                       vMenuItemGroups[i][j],
                                       0, hMII})
                    end for

                    -- Turn the selected item on, if required to.
                    if flag then
                        -- Get the current fType bits
                        w32store(hMII, MENUITEMINFO_fMask,w32or_all({MIIM_FTYPE}))
                        VOID = w32Func(xGetMenuItemInfo, {
                                       getHandle(id),
                                       id,
                                       0, hMII})
                        lType = w32fetch(hMII, MENUITEMINFO_fType)
                        -- Set the new state and type.
                        w32store(hMII, MENUITEMINFO_fMask,w32or_all({MIIM_STATE,
                                                                 MIIM_FTYPE}))
                        w32store(hMII, MENUITEMINFO_fState, MFS_CHECKED)
                        w32store(hMII, MENUITEMINFO_fType,
                                or_bits(lType, MFT_RADIOCHECK))
                        VOID = w32Func(xSetMenuItemInfo, {
                                       getHandle(id),
                                       id,
                                       0, hMII})
                    end if
                    w32release_mem(hMII)
                    return
                end if
            end for

            -- convert the flag
            flag = w32iff( flag, MF_CHECKED, MF_UNCHECKED )

            -- set the check in the menu
            if w32Func( xCheckMenuItem, {
        	        getHandle( id ),        -- owner's menu handle
        	        id,                     -- use the id
        	        flag} )= #FFFFFFFF      -- check/uncheck
            then
                -- item does not exist
                warnErr( Err_SETCHECK )
            end if

            -- if menubar, need to redraw
            if ctrl_Family[ id ] = MENU then
                VOID = w32Func( xDrawMenuBar, { ctrl_Parent[ id ] } )
            end if

        elsif ctrl_Type[id] = ListView then
            setLVChecked(id, row, flag)

        elsif ctrl_Type[id] = TreeView then
            mask = w32or_all({TVIF_HANDLE, TVIF_STATE})
            if flag then
                state = TVIS_SELECTED_MASK
            else
                state = TVIS_DESELECTED_MASK
            end if

            TV_ITEM = struct_TVITEM( mask, tvitem_handle[row], state, TVIS_STATEIMAGEMASK, 0, 0, 0, 0, 0)
            VOID = sendMessage( id, TVM_SETITEM, 0, TV_ITEM )
            w32release_mem(TV_ITEM)

        else

            -- toggle the control
            if id != Screen then
            VOID = sendMessage( id, BM_SETCHECK, flag, 0 )
            end if
        end if
    end for

end procedure
r_setCheck = routine_id("setCheck")

-----------------------------------------------------------------------------
--/topic Values
--/func isChecked( object id )
--/ret INTEGER: w32True or w32False
--/desc Gets the checked state of /i id.
--
-- This can be used on MenuItems, ListView, TreeView, Radio, and Checkboxes.
--
-- /b Note for TreeView, the /i id takes the form {id, item} /n
--
-- /b Note for ListViews, the /i id normally takes to form {id, row}.
-- But if you just use /i id, then the row with focus is examined.
--
-- Example:
--/code
--          integer flag
--
--          -- is TheRadio1 checked?
--          flag = /isChecked( TheRadio1 )
--          -- Is row 3 checked.
--          flag = isChecked ({myLV, 3})
--/endcode

global function isChecked( object pId )
    atom lRes
    integer id
    integer row
    atom TV_ITEM, state, mask

    -- return checked state of control

    if sequence(pId) then
        row = pId[2]
        id = pId[1]
    else
        id = pId
        if ctrl_Type[id] = ListView then
            row = 1 + sendMessage(id, LVM_GETHOTITEM, 0, 0)
        end if
    end if

    if ctrl_Family[ id ] = MENU
    or ctrl_Family[ id ] = MENUITEM then

        -- true if not disabled
        lRes = and_bits( getMenuState(id), MF_CHECKED)
    elsif ctrl_Type[id] = ListView then
        lRes = getLVChecked(id, row)

    elsif ctrl_Type[id] = TreeView then
        mask = w32or_all({TVIF_HANDLE, TVIF_STATE})

        TV_ITEM = struct_TVITEM( mask, tvitem_handle[row], 0, TVIS_STATEIMAGEMASK, 0, 0, 0, 0, 0)

        VOID = sendMessage( id, TVM_GETITEM, 0, TV_ITEM )
        state = w32fetch( TV_ITEM, TVITEM_state )
        w32release_mem(TV_ITEM)

        lRes = and_bits(state , TVIS_SELECTED_MASK )

    else
        -- controls
        lRes = sendMessage( id, BM_GETCHECK, 0, 0 )

    end if

    return (lRes != 0)
end function
r_isChecked = routine_id("isChecked")

-----------------------------------------------------------------------------
--/topic Edit Control
--/proc limitText( object, size )
--/desc Limits the amount of text a user can enter into an Edit control.
-- Example:
--/code
--      aTextBox = create( EditText, "", aWindow, x1, y1, width1, height1, 0 )
--      aEditor  = create( RichEdit, "", aWindow, x2, y2, width2, height2, 0 )
--      limitText( aTextBox, 50 )   -- No more than 50 characters allowed.
--      limitText( aEditor, 50000 ) -- No more than 50,000 characters allowed.
--
--/endcode
global procedure limitText( integer id, integer pSize )
atom lMsgType
   -- Limit the amount of text the user can enter.
   if validId(id) then
        if find(ctrl_Type[id], {EditText, MleText, RichEdit}) != 0 then
            if ctrl_Type[id] = RichEdit
                and
               pSize >= #10000 then -- 64K
                lMsgType = EM_EXLIMITTEXT
            else
                lMsgType = EM_LIMITTEXT
            end if
            VOID = sendMessage( id, lMsgType, pSize, NULL )
        end if
   end if
end procedure

-----------------------------------------------------------------------------
--/topic Edit Control
--/func autoSelect( object id, integer Flag )
--/ret OBJECT: Current AutoSelect status.
--/desc Turns on and off an edit control's auto-selection property.
-- If /i flag is /b w32True, the edit control /i id is set to have Auto-Selection,
-- otherwise it is set off.
--
-- If /i id is a single control id, then the return value is a integer. /n
-- If /i id is a sequence of controls, then the return value is a sequence
-- containing one status flag per control referenced in /i id.
--
-- /i id can be either a single control id or a list of ids in a sequence.
--
-- Auto-selection means that when the edit control gets focus, all its contents
-- is selected automatically for you.
--
-- Example:
--/code
--      sequence asv
--      fldName = create( EditText, "", aWindow, x1, y1, width1, height1, 0 )
--      fldAddress = create( EditText, "", aWindow, x1, y2, width1, height1, 0 )
--      asv = autoSelect({fldName, fldAddress}, w32True)
--/endcode
global function autoSelect( object id, integer pFlag )
    sequence lAutoSelect
    object lReturnVal
    integer lSingle


    if atom(id) then
        lSingle = w32True
        id = {id}
    else
        lSingle = w32False
    end if
    lReturnVal = {}

    -- Standardise the flag value to w32True or w32False.
    pFlag = not equal(pFlag,0)

    for i = 1 to length(id) do
        if validId(id[i]) then
            if find(ctrl_Type[id[i]], {EditText, MleText, RichEdit}) != 0 then
                lAutoSelect = getUserProperty(id[i], vAutoSelect)
                if length(lAutoSelect) = 0 then
                    lReturnVal &= 0
                else
                    lReturnVal &= lAutoSelect[1]
                end if
                setUserProperty(id[i], vAutoSelect, pFlag)
                if pFlag then
                    call_proc (r_setIndex,{id[i], {1,0}})
                else
                    call_proc (r_setIndex,{id[i], call_func(r_getIndex,{id[i]})})
                end if
            end if
        end if
    end for

    if lSingle then
        if length(lReturnVal) = 1 then
            lReturnVal = lReturnVal[1]
        else
            lReturnVal = w32False -- Defaults to w32False
        end if
    end if

    return lReturnVal
end function

--/topic Attributes
--/func canFocus( object id, integer Flag )
--/ret OBJECT: Current canFocus status.
--/desc Turns on and off a control's CanFocus property.
-- If /i flag is /b w32True, the control /i id is set to have CanFocus,
-- otherwise it is set off. The default for controls is /b on.
--
-- If /i id is a single control id, then the return value is a integer. /n
-- If /i id is a sequence of controls, then the return value is a sequence
-- containing one status flag per control referenced in /i id.
--
-- /i id can be either a single control id or a list of ids in a sequence.
--
-- CanFocus means that when the control gets focus, and if it's CanFocus
-- property is /b off, then the focus is not set.
--
-- Example:
--/code
--      sequence asv
--      asv = canFocus({fldName, fldAddress}, w32False)
--/endcode
global function canFocus( object id, integer pFlag )
    sequence lCanFocus
    object lReturnVal
    integer lSingle


    if atom(id) then
        lSingle = w32True
        id = {id}
    else
        lSingle = w32False
    end if
    lReturnVal = {}

    -- Standardise the flag value to w32True or w32False.
    pFlag = not equal(pFlag,0)

    for i = 1 to length(id) do
        if validId(id[i]) then
            lCanFocus = getUserProperty(id[i], vCanFocus)
            if length(lCanFocus) = 0 then
                lReturnVal &= w32True
            else
                lReturnVal &= lCanFocus[1]
            end if
            setUserProperty(id[i], vCanFocus, pFlag)
        end if
    end for

    if lSingle then
        if length(lReturnVal) = 1 then
            lReturnVal = lReturnVal[1]
        else
            lReturnVal = w32True -- Defaults to w32True
        end if
    end if

    return lReturnVal
end function

-----------------------------------------------------------------------------
--/topic System Attributes
--/proc classAutoSelect( object type, integer Flag )
--/desc Turns on and off edit controls' default auto-selection property.
-- If /i flag is /b w32True, controls of /i type are set to have Auto-Selection,
-- otherwise they do not have Auto-Selection behaviour by default when created.
--
-- /i type can be either a single control type or a list of types in a sequence.
--
-- Auto-selection means that when the edit control gets focus, all its contents
-- is selected automatically for you.
--
-- Example:
--/code
--      -- Set the default for EditText fields.
--      classAutoSelect(EditText, w32True)
--/endcode
global procedure classAutoSelect( object pType, integer pFlag )
    sequence lAutoSelect

    if atom(pType) then
        pType = {pType}
    end if

    -- Standardise the flag value to w32True or w32False.
    pFlag = not equal(pFlag,0)

    for i = 1 to length(pType) do
        if find(pType[i], {EditText, MleText, RichEdit}) then
            if pFlag then
                classAttr[pType[i]] = or_bits(classAttr[pType[i]], w32AutoSelect)
            else
                classAttr[pType[i]] = and_bits(classAttr[pType[i]], not_bits(w32AutoSelect))
            end if
        end if
    end for

end procedure

-----------------------------------------------------------------------------
--/topic Edit Control
--/proc cut( object )
--/desc Cut any selected text from /i object and place in the clipboard.
-- Example:
--/code
--          -- cut text from TheTextEdit
--          /cut( TheTextEdit )
--/endcode

global procedure cut( integer id )

    -- send a cut request to a window
    VOID = sendMessage( id, WM_CUT, 0, 0 )

end procedure


-----------------------------------------------------------------------------
--/topic Edit Control
--/proc copy( object )
--/desc Copy any selected text from /i object and place in the clipboard.
-- Example:
--/code
--          -- copy text from TheTextEdit into the clipboard
--          /copy( TheTextEdit )
--/endcode

global procedure copy( integer id )

    -- send a copy request to a window
    VOID = sendMessage( id, WM_COPY, 0, 0 )

end procedure

-----------------------------------------------------------------------------
--/topic Edit Control
--/proc paste( object )
--/desc Paste text from the clipboard to /i object.
-- Example:
--/code
--          -- paste text from clipboard to TheTextEdit
--          /paste( TheTextEdit )
--/endcode

global procedure paste( integer id )

    -- send a paste request to a window
    VOID = sendMessage( id, WM_PASTE, 0, 0 )

end procedure

-----------------------------------------------------------------------------
--/topic Edit Control
--/proc clear( object )
--/desc Clear selected text from /i object.
-- Example:
--/code
--          -- clear selected text in TheTextEdit
--          /clear( TheTextEdit )
--/endcode

global procedure clear( integer id )

    -- send a clear request to a window
    VOID = sendMessage( id, WM_CLEAR, 0, 0 )

end procedure


-----------------------------------------------------------------------------
--/topic Edit Control
--/proc undo( object )
--/desc Undo last edit in /i object.
-- Example:
--/code
--          -- undo last edit in TheTextEdit
--          /undo( TheTextEdit )
--/endcode

global procedure undo( integer id )

    -- send a undo request to a window
    VOID = sendMessage( id, WM_UNDO, 0, 0 )

end procedure

-----------------------------------------------------------------------------
-- LISTS
--
-----------------------------------------------------------------------------
--/topic List Control
--/proc addItem( integer control, sequence text )
--/desc Add /i text to the end of /i control's list.
--
-- see also: /insertItem()
--
-- Example:
--/code
--          -- add "Apples" to TheList
--          /addItem( TheList, "Apples" )
--
--          -- add fruit list to TheList
--          /addItem( TheList, {"Oranges", "Pears", "Bananas", "Mangoes" })
--/endcode
--
-- addItem is also used to add items to ComboBoxEx controls by packing
-- several params into text.
-- Example:
--/code
--          -- add "Apples" to TheListEx with unselected image
--          -- i1 and selected image i2 where, i1 and i2
--          -- were values returned from /addIcon()
--          /addItem( TheListEx, {"Apples", i1, i2})
--          /addItem( TheListEx, {
--                                {"Oranges", i3, i2},
--                                {"Pears",   i4, i2},
--                                {"Bananas", i5, i2},
--                                {"Mangoes", i6, i2}
--                               })
--/endcode
--
-- See also /"Image Lists" for details on using images
global procedure addItem( integer id, sequence pTextItems )
    -- add an item to a list

    sequence text, lMsgCodes
    integer msg, lBufsz
    atom hWnd, flags
    atom cbi, pstr
    integer lPos

    if   ctrl_Type[id] = ComboBoxEx then

        if length(pTextItems) = 3 and
           sequence(pTextItems[1]) and
           atom(pTextItems[2]) and
           atom(pTextItems[3])
        then
            pTextItems = {pTextItems}
        end if

        -- Find longest text item
        lBufsz = 0
        for i = 1 to length(pTextItems) do

            if atom(pTextItems[i]) then
                pTextItems[i] = sprintf("%g", pTextItems[i])
            end if

            if length(pTextItems[i]) != 3 or
               atom(pTextItems[i][1]) or
               sequence(pTextItems[i][2]) or
               sequence(pTextItems[i][3])
            then
    	    warnErr(sprintf("Parameter %d to ComboboxEx is not valid",i))
    	    return
            end if

            if lBufsz < length(pTextItems[i][1]) then
    	    lBufsz = length(pTextItems[i][1])
            end if
        end for

        -- Grab enough RAM for the text string conversion.
        pstr = w32acquire_mem(0, lBufsz)
        -- Get the windows handle for this control
        hWnd = getHandle(id)

        cbi = w32acquire_mem(0, SIZEOF_COMBOBOXEXITEM )
        for i = 1 to length(pTextItems) do

            text = pTextItems[i]
            -- convert the text sequence to a 'C'-style string
            poke (pstr, text[1])

            w32store( cbi, COMBOBOXEXITEM_iItem, -1 )
            w32store( cbi, COMBOBOXEXITEM_pszText, pstr )
            w32store( cbi, COMBOBOXEXITEM_cchTextMax, length(text[1]) )

            flags = CBEIF_TEXT

            if text[2] then
    	       w32store( cbi, COMBOBOXEXITEM_iImage, text[2] - 1 )
    	       flags = or_bits( flags, CBEIF_IMAGE )
            end if

            if text[3] then
    	       w32store( cbi, COMBOBOXEXITEM_iSelectedImage, text[3] - 1 )
    	       flags = or_bits( flags, CBEIF_SELECTEDIMAGE )
            end if

            w32store( cbi, COMBOBOXEXITEM_mask, flags )

            lPos = w32Func(xSendMessage, { hWnd, CBEM_INSERTITEM, 0, cbi} )
            if lPos >= 0 then
                VOID = invokeHandler(id, w32HDataChange, {w32CHG_Add, lPos+1})
            end if
        end for

        w32release_mem(cbi)
        w32release_mem(pstr)

        return
    end if

    -- what control is it?
    lMsgCodes = {0, LB_ADDSTRING, CB_ADDSTRING}
    msg = lMsgCodes[ find(ctrl_Family[ id ], {LISTBOX, COMBO}) + 1 ]
    if msg = 0 then
        -- This routine doesn't apply to this type of control.
        return
    end if

    -- Convert a single text sequence into a list of text sequences
    if length(pTextItems) = 0 or atom(pTextItems[1]) then
        pTextItems = {pTextItems}
    end if

    -- Find longest text item
    lBufsz = 0
    for i = 1 to length(pTextItems) do
        if atom(pTextItems[i]) then
            pTextItems[i] = sprintf("%g", pTextItems[i])
        end if
        if lBufsz < length(pTextItems[i]) then
            lBufsz = length(pTextItems[i])
        end if
    end for

    -- Grab enough RAM for the text string conversion.
    pstr = w32acquire_mem(0, 1 + lBufsz)
    -- Get the windows handle for this control
    hWnd = getHandle(id)

    -- add each item to the list.
    for i = 1 to length(pTextItems) do
        -- convert the text sequence to a 'C'-style string
        poke (pstr, pTextItems[i])
        poke (pstr + length(pTextItems[i]), 0)
        -- send the 'add' message
        lPos = w32Func(xSendMessage, {hWnd, msg, 0, pstr} )
        if lPos != LB_ERR and lPos != LB_ERRSPACE then
            lPos = invokeHandler(id, w32HDataChange, {w32CHG_Add,  lPos+1})
        end if
    end for

    -- Free the string RAM
    w32release_mem(pstr)

end procedure
r_addItem = routine_id("addItem")

-----------------------------------------------------------------------------
--/topic List Control
--/func setListHScroll(integer id)
--/desc Recalculates the size of a horizontal scroll bar on a listbox.
--/ret INTEGER: The length, in characters, of the longest item in the list.
--Note that it returns -1 if the /i id used is not a list box.
-- Example:
--/code
--      -- Redraw the horizontal scroll bar
--      res = setListHScroll(mylist)
--/endcode

global function setListHScroll( atom id)
    integer lLongest
    integer lWidth
    sequence lExtent
    integer lCount
    sequence lText
    sequence lLongText

    -- Set the horizontal scroll trigger for List Boxes.
    if ctrl_Family[id] != LISTBOX then
        return -1
    end if

    lCount = call_func(r_getCount,{id})
    if lCount = 0 then
        return 0
    end if

    lLongest = -1

    for i = 1 to lCount do
        lText = call_func(r_getItem,{id, i})
        if length(lText) > lLongest then
            lLongText = lText
            lLongest = length(lText)
        end if
    end for

    lWidth = call_func(r_getTextWidth,{id, '_' & lLongText})
    lExtent = getCtlSize(id)
    if lWidth < lExtent[2] then
        return lLongest
    end if

    -- Ensure that it has a scroll bar

    call_proc(r_addStyle, {id, WS_HSCROLL})

    VOID = sendMessage(id,LB_SETHORIZONTALEXTENT,lWidth, 0)

    return lLongest
end function

-----------------------------------------------------------------------------
--/topic List Control
--/func insertItem( integer list, sequence text, integer position )
--/desc Insert /i text into /i list at /i position.
--/ret INTEGER: The position actually used by Windows. Zero is returned if it fails.
-- The /i position starts at 1, but if you use zero, it adds it to the
-- end of the list.
--
-- see also: /addItem()
--
-- Example:
--/code
--          -- insert "Bananas" at position 2 in TheList
--          /insertItem( TheList, "Bananas", 2 )
--          -- insert "Mangoes" to the end of TheList
--          /insertItem( TheList, "Mangoes", 0 )
--/endcode

global function insertItem( integer id, sequence text, integer pos )

    -- inserts string to list

    integer msg, posn
    atom pstr

    -- get the message, based on control type
    if    ctrl_Family[ id ] = LISTBOX  then
        msg = LB_INSERTSTRING
    elsif ctrl_Family[ id ] = COMBO    then
        msg = CB_INSERTSTRING
    else
        return 0
    end if

    -- send a message; subtract because it's zero based
    pstr = w32acquire_mem(0, text)
    posn = sendMessage( id, msg, pos-1, pstr)
    if posn = LB_ERR or posn = LB_ERRSPACE then
        posn = -1
    else
        VOID = invokeHandler(id, w32HDataChange, {w32CHG_Add, posn+1})
    end if
    -- Free the string
    w32release_mem(pstr)

    -- return position
    return posn+1

end function


procedure removeTVItem( integer iItem )
    integer iParent
    -- Free up memory taken for the item
    if tvitem_data[iItem][ktv_TextAddr] then
        w32release_mem( tvitem_data[iItem][ktv_TextAddr] )
    end if

    tvitem_data[iItem] = ktv_Blank
    tvitem_owner[iItem] = -1 -- Remove link to owner

    iParent = tvitem_parent[iItem]
    tvitem_parent[iItem] = 0
    if not find(iParent, tvitem_parent) then
        tvitem_data[iParent][ktv_HasChildren] = 0
        -- Need to reset cChildren flag
        setTVParent( iParent, 0 )
    end if

    -- Remove this from the internal table if it is the end one.
    if iItem = length(tvitem_data) then
        tvitem_data   = tvitem_data  [1 .. length(tvitem_data)-1]
        tvitem_owner  = tvitem_owner [1 .. length(tvitem_owner)-1]
        tvitem_parent = tvitem_parent[1 .. length(tvitem_parent)-1]
        tvitem_handle = tvitem_handle[1 .. length(tvitem_handle)-1]
    end if
end procedure


--/topic List Control
--/const w32AllItems
--/desc This signifies that all items are to be deleted.
--
--/code
--      atom rc
--      rc = deleteItem(myCombo, w32AllItems)
--/endcode
global constant w32AllItems = -1

-----------------------------------------------------------------------------
--/topic List Control
--/func deleteItem( list, position )
--/desc Delete item from /i list's list at position /i.
--/ret ATOM: 0 indicates failure.
-- The /i position starts at 1.
--
-- Example:
--/code
--          -- delete item 2 from the list
--          /deleteItem( TheList, 2 )
--/endcode
--
-- /deleteItem() also works with list view and tree view controls.
-- /i position should be the item id returned when the item was
-- created.  To delete all items in a list view or tree view,
-- /i position should be -1.

global function deleteItem( atom id, integer pos )

    -- deletes an item at position

    integer msg
    atom lRC
    sequence lExtra
    integer lEventType

    atom lParam, iItem

    lParam = 0
    lExtra = {w32CHG_Del}

    -- get the message, based on control type
    if      ctrl_Family[ id ] = LISTBOX then
        lEventType = w32HDataChange
        if pos = w32AllItems then
            msg = LB_RESETCONTENT
            pos = 1
            lExtra &= 0
        else
            msg = LB_DELETESTRING
            lExtra &= pos
        end if

    elsif   ctrl_Family[ id ] = COMBO
      or ctrl_Type[id] = ComboBoxEx      then
        lEventType = w32HDataChange
        if pos = w32AllItems then
            msg = CB_RESETCONTENT
            pos = 1
            lExtra &= 0
        else
            msg = CB_DELETESTRING
            lExtra &= pos
        end if

    elsif ctrl_Type[ id ] = ListView then
        lEventType = w32HChange
        if pos = w32AllItems then
            msg = LVM_DELETEALLITEMS
            pos = 1

        else
            msg = LVM_DELETEITEM
            lExtra &= pos
        end if

    elsif ctrl_Type[ id ] = TreeView then
        lEventType = w32HChange
        msg = TVM_DELETEITEM
        if pos = w32AllItems then
            lParam = TVI_ROOT
            pos = 1
            -- changed to only delete items in the treeview specified
            iItem = 1
            lExtra &= 0
            while iItem <= length( tvitem_owner ) do
                if tvitem_owner[iItem] = id then
                    removeTVItem( iItem )
                    if iItem <= length(tvitem_owner) then
                        iItem += 1
                    end if
                else
                    iItem += 1
                end if

            end while
        else
            -- take care of any children
            iItem = find(pos, tvitem_parent)
            while iItem do
	            VOID = deleteItem( id, iItem )
    	        iItem = find(pos, tvitem_parent)
            end while

            lParam = tvitem_handle[pos]
            removeTVItem( pos )
            lExtra &= pos
        end if
        pos = 1


    end if


    lRC =  sendMessage( id, msg, pos-1, lParam )

    VOID = invokeHandler(id, lEventType, lExtra)

    return lRC
end function

-----------------------------------------------------------------------------
--/topic List Control
--/func getCount( list )
--/desc Get the count of items in /i list ( /List of /Combo )
--/ret Count of items, or zero if control's list is empty.
--
--This returns zero if /i list is not an appropriate control type.
--
-- Example:
--/code
--          -- count size of TheList
--          integer count
--
--          count = /getCount( TheList )
--/endcode
-- /getCount also works with /ListView controls.
global function getCount( atom id )

    -- get count of items in list

    integer msg

    -- get the message, based on control type
    if      ctrl_Family[ id ] = LISTBOX then
        msg = LB_GETCOUNT

    elsif   ctrl_Family[ id ] = COMBO
       or ctrl_Type[id] = ComboBoxEx then
        msg = CB_GETCOUNT

    elsif ctrl_Type[id] = ListView then
        msg = LVM_GETITEMCOUNT

    else
        return 0
    end if

    return sendMessage( id, msg, 0, 0 )

end function
r_getCount = routine_id("getCount")


--/topic Controls
--/func getEdit( integer ComboId )
--/desc Get the control id of the /i ComboId control's edit box.
--/ret INTEGER: The EditBox control Id. Zero if the /i ComboId is not a type of combo box.
--A combo box is made up of two parts, a listbox and an editbox. The editbox is
-- normally never directly used as it is handled by Windows. However, it is sometimes
-- useful for your application to handle the editbox's events directly. /n
--The control id for the editbox is automatically assigned by Win32lib when the
-- combobox is created. This function is used to fetch it.
--
-- Example:
--/code
--  procedure keytrap(integer self, integer event, sequence parms)
--      if parms[1] = VK_ESCAPE then
--         -- move to the first item.
--         setIndex(getParent(self), 1)
--      elsif parms[1] = VK_ENTER then
--         -- Ignore the Enter key
--         returnValue(-1)
--      end if
--  end procedure
--  setHandler(getEdit(MyCombo), w32HKeyPress, routine_id("keytrap"))
--/endcode

global function getEdit(integer id)
    if ctrl_Family[id] = COMBO
        or ctrl_Type[id] = ComboBoxEx then
        return find( id, ctrl_Parent )
    else
        return 0
    end if
end function
r_getEdit = routine_id("getEdit")

-----------------------------------------------------------------------------
--/topic List Control
--/func getIndex( list )
--/desc Get the index of the selected item(s), or cursor position in an edit control.
--/ret INTEGER: Index of selected item, or zero if no item is selected.
-- For ListView and TreeView, this returns a sequence of all selected items.
--
-- For MleEdit, EditText and RichEdit, this returns the cursor position.
--
-- For Combos this returns
--
-- For List, this returns the index of the currently selected item.
--
-- For Window, VScroll, HScroll, VTrackBar, HTrackBar, ProgressBar, UpDown this
-- returns the current scroll position.
--
-- Example:
--/code
--          -- get index of selected item in TheList
--          integer index
--          index = getIndex( TheList )
--
--          integer CPos
--          CPos = getIndex( myRichEdit )
--/endcode

global function getIndex( atom id )

    -- get index of selected list item

    atom msg
    atom CR, start, TV_ITEM, item, state, lParam, count, check
    sequence selections

    -- get the message, based on control type
    if      ctrl_Family[ id ] = LISTBOX then
        msg = LB_GETCURSEL

    elsif   ctrl_Family[ id ] = COMBO
      or ctrl_Type[id] = ComboBoxEx then
        msg = CB_GETCURSEL

    elsif ctrl_Type[ id ] = RichEdit
      or  ctrl_Family[id] = EDIT then
        CR = struct_CHARRANGE( 0, 0 )
        VOID = sendMessage( id, EM_GETSEL, CR, CR + 4 )
        msg = w32fetch( CR, CHARRANGE_cpMin ) + 1
        w32release_mem( CR )
        return msg

    elsif ctrl_Type[id] = ListView then
        return getLVSelected(id)

    elsif find(ctrl_Type[id],{Window,VScroll,HScroll,VTrackBar,HTrackBar,ProgressBar,UpDown}) then
        return call_func(r_getScrollPos,{id})

    elsif ctrl_Type[id] = TreeView then
        TV_ITEM = struct_TVITEM( 0, 0,
	            0, TVIS_SELECTED, "", 0, 0, 0, 0)

        count = sendMessage( id, TVM_GETCOUNT, 0, 0 )

        lParam = 0
        item = sendMessage( id, TVM_GETNEXTITEM, 0, TVGN_ROOT )
        w32store( TV_ITEM, TVITEM_hItem, item )
        VOID = sendMessage( id, TVM_GETITEM, 0, TV_ITEM )
        for i = 1 to count do
            state = w32fetch( TV_ITEM, TVITEM_state )

            if and_bits(state, TVIS_SELECTED) then
	            lParam = w32fetch( TV_ITEM, TVITEM_lParam)
	            exit
            end if
            item = sendMessage( id, TVM_GETNEXTITEM, TVGN_NEXTVISIBLE, item )
            w32store( TV_ITEM, TVITEM_hItem, item )
            VOID = sendMessage( id, TVM_GETITEM, 0, TV_ITEM )
        end for

        w32release_mem( TV_ITEM )

        return lParam
    else
        return 0
    end if

    return sendMessage( id, msg, 0, 0 )+1

end function
r_getIndex = routine_id("getIndex")

--/topic RichEdit Control
--/func getSelection( RE )
--/desc Gets the character range of any selected text.
--/ret A sequence {first, last} of the characters selected.
-- Example:
--/code
--          -- Find out what is selected
--          sequence posn
--
--          posn = /getSelection( myRE )
--/endcode
global function getSelection( atom id )

    -- get selected text range

    sequence msg
    atom CR

    if validId(id) = w32True
    and
    ( ctrl_Type[ id ] = RichEdit
       or ctrl_Family[id] = EDIT) then
        CR = struct_CHARRANGE( 0, 0 )
        VOID = sendMessage( id, EM_GETSEL, CR, CR + 4 )
        msg = {w32fetch( CR, CHARRANGE_cpMin ), w32fetch( CR, CHARRANGE_cpMax )} + 1
        w32release_mem( CR )
        return msg
    else
        return {0, 0}
    end if
end function

-----------------------------------------------------------------------------
--/topic List Control
--/proc setIndex( atom list, object index )
--/desc Set the selected item on the list to /i index.
-- This is used for Lists, Combo, and Treeview controls.
--
-- Use 0 to set the index to 'unselected.' /n
-- Use -1 to set the index to the last item. /n
-- /b Note that if /i index is greater than the number of items in the list
-- then the last item will be selected.
--
-- Example:
--/code
--          -- select the first item on the list
--          /setIndex( TheList, 1 )
--          -- select the last item on the list
--          /setIndex( TheList, -1 )
--
--          -- deselect all items in the treeview
--          /setIndex( MyTreeView, 0)
--/endcode

--/topic RichEdit Control
--/proc setIndex( atom list, object index )
--/desc Select characters in the control. /n
-- This is used for Edit and RichEdit controls. /n
-- /i index is either a single integer of the position you are selecting, or
-- a two-element sequence in the form : {low_posn, high_posn}. If the /i high_posn
-- is zero, everything up to, and including, the last item is selected.
--
-- Use 0 to deselect the current selection.
--
--For ListView controls, /i index can be set to /b w32SelectAll to
--select all items.
--
-- For Window, VScroll, HScroll, VTrackBar, HTrackBar, ProgressBar, UpDown this
-- set the current scroll position.
--
-- Example:
--/code
--          -- select characters 30 thru 43 inclusive
--          /setIndex( TheEdit, {30, 43} )
--          -- select all characters
--          /setIndex( TheEdit, {1, 0} )
--          -- select all characters from position 78
--          /setIndex( TheEdit, {78, 0} )
--          -- move insertion point to char 50
--          /setIndex( TheEdit, 50 )
--/endcode

global constant w32SelectAll = {1,0}
global procedure setIndex( atom id, object index )

    -- set index of list
    integer lCnt
    integer msg
    atom result
    atom hWnd
    atom lFlags
    atom lParam
    atom wParam
    atom LV_ITEM
    atom lCR
    -- get the message, based on control type
    if atom(index) then
        wParam = index - 1
        lParam = 0

    end if

    if ctrl_Family[ id ] = LISTBOX    then
        lFlags = w32Func(xGetWindowLong, {getHandle(id), GWL_STYLE})
        if and_bits(lFlags, LBS_MULTIPLESEL) != 0 then
            if sequence( index ) then
                if length(index) = 2 then
                    msg = LB_SELITEMRANGEEX
                    wParam = index[1] - 1
                    lParam = index[2] - 1
                else
                    msg = LB_SELITEMRANGE
                    if index = -1 then
                        index = call_func(r_getCount,{id})
                    end if
                    index -= 1
                    lParam = w32pack_word(index[1], index[2])
                    wParam = (index[3] != 0)
                end if
            else
                msg = LB_SETSEL
                if index = -1 then
                    index = call_func(r_getCount,{id}) - 1
                end if
                lParam = index - 1
                wParam = (index != 0)
            end if
        else
            msg = LB_SETCURSEL
            lCnt = call_func(r_getCount,{id})
            if index < 0 or index > lCnt then
                -- Find last item.
                wParam = call_func(r_getCount,{id}) - 1
            end if
        end if

    elsif ctrl_Type[id] = TreeView then
        hWnd = getHandle(id)
        if index >= 1 and index <= length(tvitem_handle) then
            VOID = w32Func( xSendMessage, {hWnd, TVM_SELECTITEM, TVGN_FIRSTVISIBLE, tvitem_handle[index]})
            VOID = w32Func( xSendMessage, {hWnd, TVM_SELECTITEM, TVGN_CARET, tvitem_handle[index]})
        else
            VOID = w32Func( xSendMessage, {hWnd, TVM_SELECTITEM, TVGN_CARET, 0})
        end if
        return

    elsif ctrl_Type[id] = ListView then
        hWnd = getHandle(id)
        if equal(index, w32SelectAll) then
            -- deselect all items
            VOID = w32Func( xSendMessage, {hWnd, LVM_SETHOTITEM, -1, 0})
            wParam = w32Func(xSendMessage,{hWnd, LVM_GETITEMCOUNT, 0, 0}) - 1
            LV_ITEM = w32acquire_mem(0,  SIZEOF_LVITEM )
            w32store( LV_ITEM, LVITEM_mask, LVIF_STATE )
            w32store( LV_ITEM, LVITEM_stateMask, LVIS_SELECTED )
            w32store( LV_ITEM, LVITEM_state, LVIS_SELECTED)
            for i = 0 to wParam do
                w32store( LV_ITEM, LVITEM_iItem, i)
                VOID = w32Func(xSendMessage,{hWnd, LVM_SETITEM, 0, LV_ITEM} )
            end for
            w32release_mem(LV_ITEM)
        elsif index >= 1 then
            VOID = w32Func( xSendMessage, {hWnd, LVM_SETHOTITEM, index-1, 0})
            VOID = w32Func( xSendMessage, {hWnd, LVM_ENSUREVISIBLE, index-1, 0})
            setLVItem(id, LVIF_STATE, index, 0, or_bits(LVIS_SELECTED,LVIS_FOCUSED),
                            or_bits(LVIS_SELECTED,LVIS_FOCUSED), 0, 0, 0)
        else
            -- deselect all items
            VOID = w32Func( xSendMessage, {hWnd, LVM_SETHOTITEM, -1, 0})
            wParam = w32Func(xSendMessage,{hWnd, LVM_GETITEMCOUNT, 0, 0}) - 1
            LV_ITEM = w32acquire_mem(0,  SIZEOF_LVITEM )
            w32store( LV_ITEM, LVITEM_mask, LVIF_STATE )
            w32store( LV_ITEM, LVITEM_stateMask, LVIS_SELECTED )
            for i = 0 to wParam do
                w32store( LV_ITEM, LVITEM_iItem, i)
                VOID = w32Func(xSendMessage,{hWnd, LVM_SETITEM, 0, LV_ITEM} )
            end for
            w32release_mem(LV_ITEM)
        end if
        return

    elsif ctrl_Family[ id ] = COMBO
       or ctrl_Type[id] = ComboBoxEx  then
        msg = CB_SETCURSEL

    elsif find(ctrl_Type[id],{Window,VScroll,HScroll,VTrackBar,HTrackBar,ProgressBar,UpDown}) then
        call_proc(r_setScrollPos,{id, index})
        return

    elsif ctrl_Type[ id ] = RichEdit then
        if atom( index ) then
            index = repeat( index, 2 )
        end if

        index -= 1
        lCR = struct_CHARRANGE(index[1], index[2])
        VOID = sendMessage( id, EM_EXSETSEL, 0, lCR )
        w32release_mem(lCR)

        return

    elsif ctrl_Family[ id ] = EDIT  then

        if atom( index ) then
            index = repeat( index, 2 )
        end if

        index -= 1
        VOID = sendMessage( id, EM_SETSEL, index[1], index[2] )
        return
    else
        -- has no effect on any other type of control.
        return
    end if

    -- Don't report an error if index is *supposed* to be -1

    VOID = sendMessage( id, msg, wParam, lParam )
end procedure
r_setIndex = routine_id("setIndex")

--/topic List Control
--/proc setSelection( atom list, object index )
--/desc An alias for /setIndex


--/topic RichEdit Control
--/proc setSelection( atom list, object index )
--/desc An alias for /setIndex

global procedure setSelection(atom id, object index )
    setIndex(id, index)
end procedure

--/topic RichEdit Control
--/func getRichText( id, range )
--/desc Get text from a /RichEdit control
--/ret Text in the given range.
-- If /i range is an atom, any selected text is returned. However
-- if there is no selected text and /i range is -1 then all the text is returned. /n
-- If /i range is a sequence, /i range should be a 2-element sequence with the
-- first element the starting index to be retrieved, and the
-- second element the last index. /n To always retrieve all the text
-- in the control, set the range to {0, 0}.

global function getRichText( integer pID, object pRange )
sequence
     lText
atom
   lStruct_TR,
   lStruct_GTL,
   lStruct_GT,
   lTextLength,
   lBuffer,
   lBufferLen

   if atom( pRange ) then
      -- return selection
      lText = getText(pID)
      if length(lText) = 0
        and
         pRange = -1
      then
         return getRichText(pID, {0,0})
      else
        return lText
      end if
   end if

   lText = ""
   lBufferLen = #1000

   if  pRange[1] = 0
     and
       pRange[2] = 0
   then
      lStruct_TR = w32acquire_mem(0, SIZEOF_TEXTRANGE + lBufferLen + 1 )
      lBuffer    = lStruct_TR + SIZEOF_TEXTRANGE
      w32store(lStruct_TR, TEXTRANGE_lpstrText, lBuffer)

      pRange[2] = lBufferLen
      while 1 do
         w32store(lStruct_TR, TEXTRANGE_chrgcpMin, pRange[1])
         w32store(lStruct_TR, TEXTRANGE_chrgcpMax, pRange[2])

         lTextLength = sendMessage( pID, EM_GETTEXTRANGE, 0, lStruct_TR )
         if lTextLength = 0 then
            exit
         end if

        lText &= w32fetch( lStruct_TR, TEXTRANGE_lpstrText )
        pRange[1] = pRange[2]
        pRange[2] += lBufferLen

        if lTextLength < lBufferLen then
            exit
         end if
      end while

   else  -- return specified range
      pRange -= 1  -- translate to zero base
      if pRange[1] < 0 then
        pRange[1] = 0
      end if
      if pRange[2] < 0 then
        pRange[2] = #FFFF
      end if

      lStruct_TR = struct_TEXTRANGE( pRange[1], pRange[2] )

      VOID = sendMessage( pID, EM_GETTEXTRANGE, 0, lStruct_TR )

      lText = w32fetch( lStruct_TR, TEXTRANGE_lpstrText )
   end if

   w32release_mem( lStruct_TR )
   return lText

end function

global constant
    FORMATRANGE_hdc         = w32allot(ULong),
    FORMATRANGE_hdcTarget   = w32allot(ULong),
    FORMATRANGE_rcLeft      = w32allot( Long ),
    FORMATRANGE_rcTop       = w32allot( Long ),
    FORMATRANGE_rcRight     = w32allot( Long ),
    FORMATRANGE_rcBottom    = w32allot( Long ),
    FORMATRANGE_rcPageLeft  = w32allot( Long ),
    FORMATRANGE_rcPageTop   = w32allot( Long ),
    FORMATRANGE_rcPageRight = w32allot( Long ),
    FORMATRANGE_rcPageBottom= w32allot( Long ),
    FORMATRANGE_chrgStart   = w32allot( Long ),
    FORMATRANGE_chrgEnd     = w32allot( Long ),
    SIZEOF_FORMATRANGE      = w32allotted_size()

--/topic RichEdit Control
--/proc printRichText(integer OutId, integer InId, integer Start, integer End, sequence Box, integer Render)
--/desc Prints some or all the contents of a rich edit control.
--/i OutId is the control Id where the text is displayed. Usually 'Printer' but can be
-- a Window or Pixmap. If not a printer, this can be used to do a print-preview display. /n
--/i InId is the RichText control /n
--/i Start is the first position in the RichEdit to start from
--/i End is the last position in the RichEdit control. Use /b "-1" to include all text up
-- to the end of the control. /n
--/i Box is the area in the output control that will receive the formatted text. It is in the form
-- {Left, Top, Right, Bottom, Scale}, where /i Scale is one of ... /n
--/li w32InchScale : values are in inches
--/li w32MillScale : values are in millimeters
--/li w32PixelScale : values are in pixels
--/li w32TwipsScale : values are in twips (1/1440th of an inch)
--
--/i Render is w32True if you wish to actually output the text, w32False to format it but
-- not print it.
--
--Example:
--/code
--    if length(getPrinter()) > 0 then
--        VOID = startDoc("RichText Printer Test")
--        VOID = startPage()
--        printRichText(Printer, RE, 0, -1, {0.5, 0.5, 2.5, 3, w32InchScale}, w32True)
--        VOID = endPage()
--        VOID = endDoc()
--
--        releasePrinter()
--        repaintWindow(PPV)
--    end if
--/endcode
global procedure printRichText(integer pOutId, integer pInId, integer pStart, integer pEnd, sequence pBox, integer pRender)
    atom lFR
    atom lOldMode
    atom lIDDC
    atom lHScale
    atom lVScale

    if pOutId = Printer then
        lIDDC = printerDC
    else
        lIDDC = getDC(pOutId)
    end if
    lOldMode = w32Func(xGetMapMode, {lIDDC})
    VOID = w32Func(xSetMapMode, {lIDDC, MM_TEXT})

    lFR = w32acquire_mem(0, SIZEOF_FORMATRANGE)

    if length(pBox) = 5 then
        if pBox[5] = w32InchScale then
            -- Inches supplied
            lHScale = 1440
            lVScale = 1440

        elsif pBox[5] = w32MillScale then
            -- Millimeters supplied
            lHScale = 1440 / 24.5
            lVScale = 1440 / 24.5

        elsif pBox[5] = w32PixelScale then
            -- Pixels supplied
            lHScale = 1440 / w32Func(xGetDeviceCaps,{lIDDC, LOGPIXELSX})
            lVScale = 1440 / w32Func(xGetDeviceCaps,{lIDDC, LOGPIXELSY})

        else
            -- Twips supplied
            lHScale = 1
            lVScale = 1
        end if
    else
        -- Pixels supplied
        lHScale = 1440 / w32Func(xGetDeviceCaps,{lIDDC, LOGPIXELSX})
        lVScale = 1440 / w32Func(xGetDeviceCaps,{lIDDC, LOGPIXELSY})
    end if
    w32store(lFR, FORMATRANGE_hdc, lIDDC)
    w32store(lFR, FORMATRANGE_hdcTarget, lIDDC)
    w32store(lFR, FORMATRANGE_rcLeft,
            floor( pBox[1] * lHScale)
         )
    w32store(lFR, FORMATRANGE_rcTop,
            floor( pBox[2] * lVScale)
         )
    w32store(lFR, FORMATRANGE_rcRight,
            floor( pBox[3] * lHScale)
         )
    w32store(lFR, FORMATRANGE_rcBottom,
            floor( pBox[4] * lVScale)
          )
    w32store(lFR, FORMATRANGE_rcPageLeft,0)
    w32store(lFR, FORMATRANGE_rcPageTop,0)
    w32store(lFR, FORMATRANGE_rcPageRight,
                floor( w32Func(xGetDeviceCaps,{lIDDC, HORZRES}) * lHScale))

    w32store(lFR, FORMATRANGE_rcPageBottom,
                floor( w32Func(xGetDeviceCaps,{lIDDC, VERTRES}) * lVScale ))

    w32store(lFR, FORMATRANGE_chrgStart, pStart)
    w32store(lFR, FORMATRANGE_chrgEnd, pEnd)

    VOID = sendMessage(pInId, EM_FORMATRANGE, pRender, lFR)

    -- Release cached formatting.
    VOID = sendMessage(pInId, EM_FORMATRANGE, 0, 0)

    w32release_mem(lFR)
    if lIDDC != printerDC then
        releaseDC(pOutId)
    end if
    VOID = w32Func(xSetMapMode, {lIDDC, lOldMode})

end procedure

global constant
    w32RP_Print     = 'P',
    w32RP_LastPage  = 'L',
    w32RP_Skip      = 'S',
    w32RP_SkipAll   = 'A',
    w32RP_Cancel    = 'C',
    w32RP_Build     = 'b',
    w32RP_Output    = 'o'

--/topic RichEdit Control
--/proc printRichTextPages(integer InId, integer pCallBack, object pUserData)
--/desc Prints the contents of a RichText control.
--/i InId is the RichText control /n
--/i pCallBack is a routine_id of a user defined function that is called before each page
-- is built and again just before each page is output. If this is not a valid routine_id
-- (eg. -1) then this routine will assume a 0.5 inch margin and print the entire RichText
-- document, using multiple pages if required./n
--
-- The function will be passed a two parameters.
--<ul>
--/li An integer that will either have the value w32RP_Build or w32RP_Output
--/li A sequence that contains ...
--<ul>
-- /li the Page number,
-- /li the Index into the richedit control for the first element on the page,
-- /li the value -1 (for w32RP_Build) or the Index into the richedit control
-- for the last element on the page (for w32RP_Output)
--/li the Page Size in pixels { Width, Height }
--/li the /i pUserData parameter
--</ul>
--</ul>
-- When the function is called using w32RP_Build, the function must return one of ...
--/li w32RP_SkipAll ==> Do not build this page, just end the document.
--/li w32RP_Cancel ==> Do not build this page, just cancel the document.
--/li {Left, Top, Right, Bottom, Scale} ==> the area in the page that will receive the formatted text.
--
--/i Left and /i Top indicate an offset from the left and top edges of the page, respectively. /n
--/i Right and /i Bottom, if positive values are also offsets from the left and top
-- edges respectively, but if negative, they are offsets from the right and bottom
--edges. /n
--/i Scale is one of ... /n
--<ul>
--/li w32InchScale : values are in inches
--/li w32MillScale : values are in millimeters
--/li w32PixelScale : values are in pixels
--/li w32TwipsScale : values are in twips (1/1440th of an inch)
--</ul>
--
-- When the function is called using w32RP_Output, the function must return one of ...
--/li w32RP_Print ==> Print the page
--/li w32RP_LastPage ==> Print the page and then end the document.
--/li w32RP_Skip ==> Skip this page and go on to the next page.
--/li w32RP_SkipAll ==> Do not print this page or any others, just end the document.
--/li w32RP_Cancel ==> Do not print this page but cancel the document.
--
--/b Note that you need to set the Printer device context before calling this. That can be
-- done by calling getPrinter() or getPrintChoice().
--
--Example:
--/code
--    function RTPager(integer pCode, sequence pParms)
--      if pCode = w32RP_Build then
--         -- Return the printable page area
--         -- which is different for odd
--         -- and even pages.
--         if and_bits(pParms[1], 1) then
--            return {0.25, 1, -0.75, -0.5, w32InchScale}
--         else
--            return {0.75, 1, -0.25, -0.5, w32InchScale}
--         end if
--      end if
--
--      if pCode = w32RP_Output then
--          -- The page has been built with text from the richedit control, so now
--          -- I can add my own touches...
--
--         -- Display the title text on the top left corner.
--         wPuts( {Printer, 0, 0}, pParms[5] )
--
--          -- Display the page number on the bottom-right of the page.
--         lFooter = sprintf(" Page %d", pParms[1])
--         wPuts( {Printer, lParms[4][1] -  getTextWidth(lFooter),
--                          lParms[4][2] - (getTextHeight(lFooter) * 2)}, lFooter )
--
--         -- Tell win32lib to output the page now.
--         return w32RP_Print
--      end if
--    end function
--
--    . . .
--
--    if length(getPrinter()) > 0 then
--        printRichTextPages(RE, routine_id("RTPager"), "This Is The Title")
--        releasePrinter()
--    end if
--/endcode

global procedure printRichTextPages( integer pInId, sequence pDocName, integer pCallBack, object pUserData)
    atom lFR
    atom lOldMode
    atom lHScale
    atom lVScale
    integer lOutId
    integer lStart
    integer lEnd
    object lBox
    integer lRender
    integer lPageNo
    atom lNextElem
    integer lDocStarted
    integer lTextPrinted
    integer lTextLength
    sequence lPageSizePixels
    sequence lPageSizeTwips
    integer lResponse

    if printerDC = 0 then
        return
    end if

    lOldMode = w32Func(xGetMapMode, {printerDC})
    if lOldMode != MM_TEXT then
        VOID = w32Func(xSetMapMode, {printerDC, MM_TEXT})
    end if

    lHScale = 1440 / w32Func(xGetDeviceCaps,{printerDC, LOGPIXELSX})
    lVScale = 1440 / w32Func(xGetDeviceCaps,{printerDC, LOGPIXELSY})
    lPageSizeTwips = {floor( w32Func(xGetDeviceCaps,{printerDC, HORZRES}) * lHScale),
                 floor( w32Func(xGetDeviceCaps,{printerDC, VERTRES}) * lVScale )
                }
    lPageSizePixels = {w32Func(xGetDeviceCaps,{printerDC, HORZRES}) - w32Func(xGetDeviceCaps,{printerDC, PHYSICALOFFSETX}),
                       w32Func(xGetDeviceCaps,{printerDC, VERTRES}) - w32Func(xGetDeviceCaps,{printerDC, PHYSICALOFFSETY})
                      }
    lFR = w32acquire_mem(0, SIZEOF_FORMATRANGE)
    w32store(lFR, FORMATRANGE_hdc, printerDC)
    w32store(lFR, FORMATRANGE_hdcTarget, printerDC)
    w32store(lFR, FORMATRANGE_rcPageLeft,0)
    w32store(lFR, FORMATRANGE_rcPageTop,0)
    w32store(lFR, FORMATRANGE_rcPageRight,  lPageSizeTwips[1])
    w32store(lFR, FORMATRANGE_rcPageBottom, lPageSizeTwips[2])

    lPageNo = 0
    lNextElem = 0
    lTextPrinted = 0
    lTextLength = sendMessage(pInId, WM_GETTEXTLENGTH, 0, 0)

    VOID = startDoc(pDocName)
    lDocStarted = w32True

    while lTextPrinted < lTextLength do
        lPageNo += 1
        lStart = lNextElem
        if pCallBack >= 0 then
            lBox = call_func(pCallBack, {w32RP_Build, {lPageNo, lStart, -1, lPageSizePixels,  pUserData}})
            if equal(lBox, w32RP_SkipAll) then
                exit
            elsif equal(lBox, w32RP_Cancel) then
                abortDoc()
                lDocStarted = w32False
                exit
            end if

        else
            lBox = {0.5, 0.5, -0.5, -0.5, w32InchScale}
        end if

        if length(lBox) = 5 then
            if lBox[5] = w32InchScale then
                -- Inches supplied
                lHScale = 1440
                lVScale = 1440

            elsif lBox[5] = w32MillScale then
                -- Millimeters supplied
                lHScale = 1440 / 24.5
                lVScale = 1440 / 24.5

            elsif lBox[5] = w32PixelScale then
                -- Pixels supplied
                lHScale = 1440 / w32Func(xGetDeviceCaps,{printerDC, LOGPIXELSX})
                lVScale = 1440 / w32Func(xGetDeviceCaps,{printerDC, LOGPIXELSY})

            else
                -- Twips supplied
                lHScale = 1
                lVScale = 1
            end if
        else
            -- Pixels supplied
            lHScale = 1440 / w32Func(xGetDeviceCaps,{printerDC, LOGPIXELSX})
            lVScale = 1440 / w32Func(xGetDeviceCaps,{printerDC, LOGPIXELSY})
        end if
        w32store(lFR, FORMATRANGE_rcLeft,
                floor( lBox[1] * lHScale)
             )
        w32store(lFR, FORMATRANGE_rcTop,
                floor( lBox[2] * lVScale)
             )
        if lBox[3] < 0 then
            w32store(lFR, FORMATRANGE_rcRight,
                lPageSizeTwips[1] + floor( lBox[3] * lHScale)
             )
        else
            w32store(lFR, FORMATRANGE_rcRight,
                floor( lBox[3] * lHScale)
             )
        end if

        if lBox[4] < 0 then
            w32store(lFR, FORMATRANGE_rcBottom,
                lPageSizeTwips[2] + floor( lBox[4] * lVScale)
             )
        else
            w32store(lFR, FORMATRANGE_rcBottom,
                floor( lBox[4] * lVScale)
              )
        end if

        w32store(lFR, FORMATRANGE_chrgStart, lStart)
        w32store(lFR, FORMATRANGE_chrgEnd, -1)

        if pCallBack >= 0 then
            lNextElem = sendMessage(pInId, EM_FORMATRANGE, 0, lFR)
            if lNextElem > lTextPrinted then
                lResponse = call_func(pCallBack, {w32RP_Output, {lPageNo, lStart, lNextElem-1, lPageSizePixels, pUserData} })

                if find(lResponse, {w32RP_Print, w32RP_LastPage} ) then
                    VOID = startPage()
                    VOID = sendMessage(pInId, EM_DISPLAYBAND, 0, w32ElemAddr( lFR, FORMATRANGE_rcLeft ) )
                    VOID = endPage()

                    if equal(lResponse, w32RP_LastPage) then
                        -- Pretend we are at the end.
                        lNextElem = lTextLength + 1
                    end if
            end if

            elsif equal(lResponse, w32RP_Skip) then
                -- Don't bother printing it.

            elsif equal(lResponse, w32RP_SkipAll) then
                -- Pretend we are at the end.
                lNextElem = lTextLength + 1

            elsif equal(lResponse, w32RP_Cancel) then
                -- Pretend we are at the end.
                lNextElem = lTextLength + 1
                abortDoc()
                lDocStarted = w32False
            end if
        else
            -- Default is to print the page.
            lNextElem = sendMessage(pInId, EM_FORMATRANGE, 0, lFR)
            if lNextElem > lTextPrinted then
                VOID = startPage()
                VOID = sendMessage(pInId, EM_DISPLAYBAND, 0, w32ElemAddr( lFR, FORMATRANGE_rcLeft ) )
                VOID = endPage()
            end if
        end if

        if lNextElem <= lTextPrinted then
            -- Nothing happened?!
            exit
        end if

        lTextPrinted = lNextElem

    end while

    if lDocStarted = w32True then
        -- That's all folks.
        VOID = endDoc()
    end if

    -- Release cached formatting.
    VOID = sendMessage(pInId, EM_FORMATRANGE, 0, 0)

    w32release_mem(lFR)
    if lOldMode != MM_TEXT then
        VOID = w32Func(xSetMapMode, {printerDC, lOldMode})
    end if

end procedure



--------------------------------------------------------------
function setFindSel( integer id, atom flag, atom fr )
    object index, range

    index = getIndex( id ) - 1
    range = w32fetch( fr, FINDREPLACE_lpstrFindWhat )

    if and_bits( flag, FR_DOWN ) then
    index = { index, #FFFF }
    else
    index = { 0, index }
    end if

    range = { findText( id, range, index, flag ) , length(range)}
    range[2] += range[1]

    setIndex( id, range )
    return range[1]
end function

-----------------------------------------------------------------------------
--/topic List Control
--/func getItem( integer list, integer index )
--/desc Return the text of item at /i index in /i list.
--/ret Text of item, or "" if fails.
-- /b Note, getItem() will return the text from all columns of a /ListView.
--
--If /i index is zero, the currently selected item is used.
--
-- Example:
--/code
--          -- get the text of the third item in TheList
--          sequence text
--
--          -- get the text of the third item.
--          text = /getItem( TheList, 3 )
--          -- get the text of the current item.
--          text = /getItem( TheList, 0 )
--/endcode
constant kLenMsg = {CB_GETLBTEXTLEN, -- Combo
                    CB_GETLBTEXTLEN, -- SortedCombo
                    CB_GETLBTEXTLEN, -- SimpleCombo
                    CB_GETLBTEXTLEN, -- DropDownList
                    CB_GETLBTEXTLEN, -- ComboBoxEx
                    LB_GETTEXTLEN, -- SortedList
                    LB_GETTEXTLEN  -- List
                    }

constant kTxtMsg = {CB_GETLBTEXT, -- Combo
                    CB_GETLBTEXT, -- SortedCombo
                    CB_GETLBTEXT, -- SimpleCombo
                    CB_GETLBTEXT, -- DropDownList
                    CB_GETLBTEXT, -- ComboBoxEx
                    LB_GETTEXT, -- SortedList
                    LB_GETTEXT  -- List
                    }

global function getItem( atom id, object item )

    -- get text of requested item

    integer msg, iLength
    atom buffer
    sequence text
    integer ctype

     -- correct class?
    ctype = find(ctrl_Type[ id ], {Combo, SortedCombo, SimpleCombo,
                                     DropDownList, ComboBoxEx,
                                     SortedList, List,
                                     ListView} )
    if ctype = 0 then
        return ""
    end if

    if item = 0 then
        item = getIndex(id)
    end if

    -- ListView returns all columns.
    if ctrl_Type[id] = ListView then
        return getLVItemText(id, item, -1)
    end if

    -- get the text size; add 1 for /0
    iLength = sendMessage( id, kLenMsg[ctype], item-1, 0 ) + 1

    -- no item?
    if iLength = 0 then
        return ""
    end if

    -- Allocate a buffer
    buffer = w32acquire_mem(0, iLength )

    -- move the text to a buffer
    -- value returned is length without 0 terminator
    iLength = sendMessage( id, kTxtMsg[ctype], item-1, buffer )

    -- get the text
    text = peek( {buffer, iLength} )

    -- release the buffer
    w32release_mem( buffer )

    return text

end function
r_getItem = routine_id("getItem")

--/topic Events
--/func getLastMsg( object option )
--/desc Gets information about the Windows message(s) being processed.
--/ret SEQUENCE: The message data sent by Windows. INTEGER: Depth
--This is used by advanced users. It can be used to determine the triggering event for
-- the current event handler. For example, you can use this to find out if a w32HClick
-- event was triggered by a keypress or a mousepress. Or if a paint event was triggered
-- by a scroll action or not.
--
--What this returns depends on the /i option value.
--/li "" Returns the most recent message { pSource, hWnd, iMsg, wParam, lParam }
--/li "all" Returns all the messages being processed. { /i Mes, ... } where each /i Mes has the form above.
--/li "depth" Returns the current number of messages being processed.
--/li "maxdepth" Returns the maximum number of simultaneous messages processed so far.
--
--This returns an empty list if there are no windows messages being processed.
--
--Example:
--/code
--      sequence msg
--      msg = getLastMsg( "" )
--/endcode
global function getLastMsg(object option)

    if equal(option, "depth") then
        return vWMI
    end if

    if equal(option, "maxdepth") then
        return find(0, vWinMsg)-1
    end if

    if vWMI > 0 then
        if equal(option, "all") then
            return vWinMsg
        else
            return {vWinMsg[vWMI]}
        end if
    else
        return {}
    end if
end function

-----------------------------------------------------------------------------
--/topic List Control
--/func findItem( integer list, sequence text, integer startpos )
--/desc Locates /i text in the /i list, starting from index /i startpos
--/ret integer: The index in the /i list where /i text was found. Zero if not found.
-- /b Note, findItem will only check the first column of a /ListView.  /n
--If /istartpos is negative, the list is scanned from the last item such that -1 means
-- start at the last item, -2 from the second last item etc... A value of 0 means
-- that all occurances are returned in a sequence.
-- Example:
--/code
--
--          integer ipos
--          sequence allpos
--
--          -- See if new value already exists.
--          ipos = /findItem( TheList, NewValue, 1 )
--          -- Get all occurances of "cat"
--          allpos = findItem( TheList, "cat", 0)
--          -- Get last occurance of "dog"
--          ipos = findItem( TheList, "dog", -1)
--/endcode
global function findItem( atom id, sequence ptext, integer item )

    -- find the requested text

    integer msg, iLength
    atom buffer, buflen
    sequence text
    object lResult
    integer ctype
    integer lStart, lEnd, lIncr

    if item = 0 then
        lResult = {}
    else
        lResult = 0
    end if

    -- correct class?
    ctype = find(ctrl_Type[ id ], {Combo, SortedCombo, SimpleCombo,
                                    DropDownList, ComboBoxEx,
                                    SortedList, List,
                                    ListView} )
    if ctype = 0 then
        return lResult
    end if

    if item < 0 then
        lIncr = -1
        lEnd = 0
        lStart = getCount(id) + item
    else
        lIncr = 1
        if item = 0 then
            lStart = 0
        else
            lStart = item - 1
        end if
        lEnd = getCount(id)-1
    end if

    buflen = 1000
    buffer = w32acquire_mem(0, buflen)

    for i = lStart to lEnd by lIncr do

        if ctrl_Type[id] = ListView then
            -- Get the text from column #1
            text = getLVItemText(id, i+1, 1)
        else

            -- get the text size
            iLength = sendMessage( id, kLenMsg[ctype], i, 0 )

            -- no item?
            if iLength = -1 then
                exit
            end if

            -- Only bother getting the actual text if the lengths are the same.
            if iLength = length(ptext) then
                -- Allocate a buffer
                if iLength >= buflen then
                    w32release_mem(buffer)
                    buflen = iLength+1  -- account for string terminator
                    buffer = w32acquire_mem(0, buflen )
                end if
                -- move the text to a buffer
                -- value returned is length without 0 terminator
                VOID = sendMessage( id, kTxtMsg[ctype], i, buffer )

                -- get the text
                text = peek( {buffer, iLength} )
            else
                text = ""
            end if
        end if

        if equal(text, ptext) then
            if item = 0 then
                lResult &= i+1
            else
                lResult = i+1
                exit
            end if
        end if
    end for

    w32release_mem(buffer)
    return lResult
end function


--/topic List Control
--/func getMultIndices( id )
--/desc Get indices of multiple selections in a multi-selection list
--/ret Sequence of indices. {} is returned if there are none selected.
global function getMultIndices( atom id )
    atom buffer, items
    sequence selections
    selections = {}

    items = sendMessage(id, LB_GETSELCOUNT, 0 ,0)
    if items > 0  then
        buffer = w32acquire_mem(0, items*4)
        items = sendMessage(id, LB_GETSELITEMS, items, buffer)

        selections = peek4u( {buffer, items } ) + 1
        w32release_mem(buffer)
    end if

    return selections
end function

--/topic List Control
--/func getMultItems( id )
--/desc Get text of multiple selections in a multi-selection list
--/ret Sequence of strings. {} is return if nothing is selected.
global function getMultItems( atom id )

    sequence selections
    selections = getMultIndices( id )

    for i = 1 to length(selections) do
        selections[i] = getItem(id, selections[i] )
    end for

    return selections
end function

-----------------------------------------------------------------------------
--/topic List Control
--/proc eraseItems( list )
--/desc Remove all items from /i list.
-- Example:
--/code
--          -- erase items from TheList
--          /eraseItems( TheList )
--/endcode
-- Also works with /ComboBox  /ListView and /TreeView controls.
global procedure eraseItems( atom id )

    -- clear a list
    VOID = deleteItem( id, w32AllItems )

end procedure




-----------------------------------------------------------------------------
-- SCROLL BARS
--
-----------------------------------------------------------------------------
--/topic Scroll Control
--/proc setScrollChange( id, linesize, pagesize )
--/desc Adjust the amount that a scroll control will change.
-- The /i linesize is the amount that the /i id will adjust
-- when the up/down arrow is selected, and the /i pagesize is
-- used when the page up/page down is selected.
--
-- For trackbars, the /i pagesize is used to determine the distance
-- between the tick marks.
--
-- The default values are {1,10}.
--
-- Example:
--/code
--          -- set change amount for TheScroll
--          /setScrollChange( TheScroll, 1, 10 )
--/endcode

global procedure setScrollChange( object id, atom low, atom high )

    -- set the "line" and "page" change amount
    atom result
    atom lWhich

    if sequence(id) then
        if id[2] = SB_HORZ then
            lWhich = 2
        else
            lWhich = 1
        end if
        id = id[1]
    else
        lWhich = 1
    end if

    -- save value
    ctrl_Scroll[id][lWhich] = { low, high }

-- NEW! 0.45f trackbar support
    if ctrl_Type[id] = HTrackBar
    or ctrl_Type[id] = VTrackBar then

        -- new page size
        result = sendMessage( id, TBM_SETPAGESIZE, low, high )

        -- set tick frequency
        result = sendMessage( id, TBM_SETTICFREQ, high, 0 )

    end if

end procedure
r_setScrollChange = routine_id("setScrollChange")

-----------------------------------------------------------------------------
--/topic Scroll Control
--/func getScrollChange( scroll )
--/desc Returns the amount that /i scroll will change.
--/ret { line change, page change }
-- This value is set by /setScrollChange. The default value is {1,10},
-- indicating the small change and large change amounts.
--
-- Example:
--/code
--          -- get change amount for TheScroll
--          sequence change
--          change = /getScrollChange( TheScroll )
--/endcode

global function getScrollChange( object id )
    atom lWhich

    if sequence(id) then
        if id[2] = SB_HORZ then
            lWhich = 2
        else
            lWhich = 1
        end if
        id = id[1]
    else
        lWhich = 1
    end if

    return ctrl_Scroll[ id ][lWhich]

end function


--/topic Scroll Control
--/proc setWindowScrollRange( id, typeScroll, min, max, pageSize)
--/desc Set range of window scrollbar or normal scrollbar .
--/li /b id: specifies either the scrollbar or /Window with scrollbar
--/li /b typeScroll : specifies type of the scrollbar
--/li /b pageSize : specifies size of one page (allows to set size of proportional scrollbar)
-- If this is less than 1, it is ignored.
--
--typeScroll can be one of the following :
-- /li /b SB_HORZ : window's (specified by /i id) horizontal scrollbar
-- /li /b SB_VERT : window's (specified by /i id) vertical scrollbar
-- /li /b SB_CTL  : control (specified by /i id), either /HScroll or /VScroll
global procedure setWindowScrollRange(integer id, integer typeScroll, atom min, atom max, atom pageSize)
    -- Martin : sets scroll range for window scrolbar

    atom sif
    atom lMask
    sequence lChangeSize
    integer lType

    -- store value


    if ctrl_Type[ id ] != Window then
        typeScroll = SB_CTL
    elsif typeScroll != SB_HORZ then
        typeScroll = SB_VERT
    end if

    if typeScroll = SB_HORZ then
        ctrl_Range[id][2] = {min,max}
    else
        ctrl_Range[id][1] = {min,max}
    end if

    -- Allocate structure
    sif = w32acquire_mem(0, SIZEOF_SCROLLINFO )

    -- store values
    if pageSize < 1 then
        lMask = SIF_RANGE
    else
        lMask = w32or_all({SIF_RANGE,SIF_PAGE})
        lChangeSize = getScrollChange({id, typeScroll})
        setScrollChange({id, typeScroll}, lChangeSize[1], pageSize)
    end if

    w32store( sif, sifSize, SIZEOF_SCROLLINFO )
    w32store( sif, sifMask, lMask )
    w32store( sif, sifMin, min )
    w32store( sif, sifMax, max )
    w32store( sif, sifPage, pageSize)


    VOID = w32Func( xSetScrollInfo,
                    {getHandle( id ),            -- handle
                     typeScroll,                     --
                     sif,                        -- pointer to structure
                     1 } )                       -- redraw flag

    -- Free structure
    w32release_mem( sif )
end procedure
r_setWindowScrollRange = routine_id("setWindowScrollRange")

--/topic Scroll Control
--/proc setScrollRange( id, low, high )
--/desc Sets the range of values of a control.
-- /i id is the Id of the control to be affected. This must be either a... /n
--<ul>
--/li Window
--/li VScroll
--/li HScroll
--/li VTrackBar
--/li HTrackBar
--/li UpDown
--/li ProgressBar
--</ul>
-- /b Note that when /i id is a Window control, by default it refers to the vertical scrollbar.
-- Alternatively you can specify either vertical or horizontal by using the syntax {id, scrollbar}
-- where /i scrollbar is either /b SB_VERT or /b SB_HORZ. /n
-- The /i low value must be greater than zero.
--
-- The initial values when a control is created are low=0, high=100.
--
-- Example:
--/code
--          -- set range for TheScroll
--          /setScrollRange( TheScroll, 1, 100 )
--          -- set the horizontal scrollbar on a window.
--          /setScrollRange( {myWindow, SB_HORZ}, 1, 289)
--/endcode

global procedure setScrollRange( object id, atom min, atom max )

    -- set the allowable range for a scroll bar
    atom sif, result
    integer lMsgCode
    -- store value
    if sequence(id) then
        lMsgCode = w32iff(find(id[2], {SB_VERT,SB_HORZ}), id[2], SB_VERT)
        id = id[1]
    else
        lMsgCode = SB_VERT
    end if


    -- what type of control?
    if find(ctrl_Type[ id ], {HScroll, VScroll, Window}) then

        if ctrl_Type [ id ] != Window then
            lMsgCode = SB_CTL                     -- scroll bar control
        end if

        setWindowScrollRange(id, lMsgCode, min, max, 0)


    elsif find(ctrl_Type[id], { HTrackBar,VTrackBar}) then

        ctrl_Range[ id ][1] = { min, max }
        -- set the range and selection range
        VOID = sendMessage( id, TBM_SETRANGEMIN, w32False, min )
        VOID = sendMessage( id, TBM_SETRANGEMAX, w32True, max )
        VOID = sendMessage( id, TBM_SETSELSTART, w32False, min )
        VOID = sendMessage( id, TBM_SETSELEND, w32False, max )


    elsif ctrl_Type[id] = ProgressBar then

        if max > #7FFF or min < -#7FFF then
            VOID = sendMessage( id, PBM_SETRANGE32, min, max  )
        else
            VOID = sendMessage( id, PBM_SETRANGE, 0, w32pack_word(min, max)  )
        end if
        ctrl_Range[ id ][1] = { min, max }

    elsif ctrl_Type[id] = UpDown then
        if max > #7FFF or min < -#7FFF then
            VOID = sendMessage( id, UDM_SETRANGE32,  min, max )
        else
            VOID = sendMessage( id, UDM_SETRANGE,  0, w32pack_word(max,min) )
        end if

        ctrl_Range[ id ][1] = { min, max }
    end if


end procedure
r_setScrollRange = routine_id("setScrollRange")

-----------------------------------------------------------------------------
--/topic Scroll Control
--/func getScrollRange( id )
--/desc Returns /i id's range of values.
--/ret { low, high }
-- /b Note that when /i id is a Window control, by default it refers to the vertical scrollbar.
-- Alternatively you can specify either vertical or horizontal by using the syntax {id, scrollbar}
-- where /i scrollbar is either /b SB_VERT or /b SB_HORZ. /n
--
--
-- This value is set by /setScrollRange.
--
-- Example:
--/code
--          -- get range of TheScroll
--          sequence range
--          range = /getScrollRange( TheScroll )
--/endcode

global function getScrollRange( object id )

    -- Get the allowable range for a scroll bar
    atom lWhichBar

    if sequence(id) then
        lWhichBar = w32iff(find(id[2], {SB_VERT,SB_HORZ}), id[2], SB_VERT)
        id = id[1]
    else
        lWhichBar = SB_VERT
    end if

    if lWhichBar = SB_HORZ then
        return ctrl_Range[id][2]
    else
        return ctrl_Range[id][1]
    end if

end function


-----------------------------------------------------------------------------
--/topic Scroll Control
--/proc setScrollPos( id, position )
--/desc Sets the value of /i id.
--/i id is the Id of a control. The control must be one of... /n
--<ul>
--/li Window
--/li VScroll
--/li HScroll
--/li VTrackBar
--/li HTrackBar
--/li ProgressBar
--/li UpDown
--</ul>
-- /b Note that when /i id is a Window control, by default it refers to the vertical scrollbar.
-- Alternatively you can specify either vertical or horizontal by using the syntax {id, scrollbar}
-- where /i scrollbar is either /b SB_VERT or /b SB_HORZ. /n
--
--The value must be greater than zero.
--
--This routine will trigger an /onScroll event.
--
-- Example:
--/code
--          -- set value of the TheScroll
--          /setScrollPos( TheScroll, 20 )
--          -- set the horizontal scrollbar
--          /setScrollPos( {myWindow, SB_HORZ}, 17)
--/endcode

global procedure setScrollPos( object id, object pAction )

    -- return the value of the scroll bar
    object result
    atom min, max
    atom lWhichBar
    atom pos

    result = {}
    if sequence(id) then
        lWhichBar = w32iff(find(id[2], {SB_VERT,SB_HORZ}), id[2], SB_VERT)
        id = id[1]
    else
        lWhichBar = SB_VERT
    end if

    if sequence(pAction) then
        pos = floor(pAction[1])
        pAction = pAction[2]
        if sequence(pAction) or not integer(pAction) or pAction < SB_LINEUP or pAction > SB_ENDSCROLL then
            pAction = SB_UserDefined
        end if
    else
        pos = floor(pAction)
        pAction = SB_UserDefined
    end if

    if lWhichBar = SB_HORZ then
        min = ctrl_Range[id][2][1]
        max = ctrl_Range[id][2][2]
    else
        min = ctrl_Range[id][1][1]
        max = ctrl_Range[id][1][2]
    end if

    if pos < min then
        -- clip to minimum
        pos = min

    elsif pos > max then
        -- clip to maximum
        pos = max

    end if


    -- scrollbar?
    if ctrl_Type[ id ] = HScroll
    or ctrl_Type[ id ] = VScroll then

        -- call the function
        result =  w32Func( xSetScrollPos, {
	            getHandle( id ),        -- handle
	            SB_CTL,                 -- scroll bar specific
	            pos,                    -- new scroll bar position
	            w32True } )                -- redraw flag

    elsif ctrl_Type[ id ] = Window then
        -- call the function
        result =  w32Func( xSetScrollPos, {
	            getHandle( id ),        -- handle
	            lWhichBar,                -- scroll bar specific
	            pos,                    -- new scroll bar position
	            w32True } )                -- redraw flag

    elsif ctrl_Type[ id ] = HTrackBar
    or    ctrl_Type[ id ] = VTrackBar then

        -- send message
        result = sendMessage( id, TBM_SETPOS, w32True, pos )

    elsif ctrl_Type[ id ] = ProgressBar then

        -- send message
        result = sendMessage( id, PBM_SETPOS, pos, 0 )

    elsif ctrl_Type[ id ] = UpDown then

        -- send message
        result = sendMessage( id, UDM_SETPOS, pos, 0 )

    end if

    if atom(result) then
        -- run the event code, if any
        VOID = invokeHandler(id, w32HScroll, {pos, pAction, lWhichBar})
    end if

end procedure
r_setScrollPos = routine_id("setScrollPos")

-----------------------------------------------------------------------------
--/topic Scroll Control
--/proc setVScrollPos( window, position )
--/desc Sets the value of a window's vertical /i scroll.
-- The value must be greater than zero. This will trigger an
-- /onScroll event.
--
-- Example:
--/code
--          -- set value of the TheScroll
--          /setVScrollPos( myWindow, 20 )
--/endcode

global procedure setVScrollPos( integer id, atom pos )

    setScrollPos( {id, SB_VERT}, pos)

end procedure

-----------------------------------------------------------------------------
--/topic Scroll Control
--/proc setHScrollPos( window, position )
--/desc Sets the value of a window's horizontal /i scroll.
-- The value must be greater than zero. This will trigger an
-- /onScroll event.
--
-- Example:
--/code
--          -- set value of the TheScroll
--          /setHScrollPos( myWindow, 20 )
--/endcode

global procedure setHScrollPos( integer id, atom pos )

    setScrollPos( {id, SB_HORZ}, pos)


end procedure

-----------------------------------------------------------------------------
--/topic Scroll Control
--/func getScrollPos( object id)
--/desc Gets the value of a scroll control.
--/ret Position of the thumb on the scroll control.
--/i id is the Id of a control. The control must be one of... /n
--<ul>
--/li Window
--/li VScroll
--/li HScroll
--/li VTrackBar
--/li HTrackBar
--/li ProgressBar
--/li UpDown
--</ul>
-- For /b Window controls, the /i id parameter can also specify which of
-- the vertical or horizontal scrollbars you are referring to. To do this,
-- the form of /i id is { ctrl, bartype } where /i bartype is either
-- /b SB_VERT or /b SB_HORZ.
--
-- Example:
--/code
--          -- get value of TheScroll
--          integer pos,vpos,hpos
--          pos = /getScrollPos( TheScroll )
--          vpos = /getScrollPos( {MainWin, SB_VERT} )
--          hpos = /getScrollPos( {MainWin, SB_HORZ} )
--/endcode

global function getScrollPos( object id )
    integer lSBar
    -- return the value of the scroll bar


    if sequence(id) then
        lSBar = w32iff(find(id[2], {SB_VERT,SB_HORZ}), id[2], SB_VERT)
        id = id[1]
    else
        lSBar = SB_VERT
    end if

    if ctrl_Type[ id ] = Window then

        return w32Func( xGetScrollPos, { getHandle( id ), lSBar } )

    elsif  ctrl_Type[ id ] = HScroll
        or ctrl_Type[ id ] = VScroll  then
        -- call the function
        return w32Func( xGetScrollPos, {
            getHandle( id ),        -- handle
            SB_CTL } )              -- scroll bar specific

    elsif  ctrl_Type[ id ] = HTrackBar
       or  ctrl_Type[ id ] = VTrackBar then

        return sendMessage( id, TBM_GETPOS, 0, 0 )

    elsif ctrl_Type[ id ] = ProgressBar then

        return sendMessage( id, PBM_GETPOS, 0, 0 )

    elsif ctrl_Type[ id ] = UpDown then

        return w32shortInt(sendMessage( id, UDM_GETPOS, 0, 0))
    else
        return 0
    end if

end function
r_getScrollPos = routine_id("getScrollPos")
-----------------------------------------------------------------------------
--/topic Scroll Control
--/func getThumbPos( object id)
--/desc Gets the position of the scroll thumb while being dragged.
--/ret Position of the thumb on the scroll control.
--/i id is the Id of a control. The control must be one of... /n
--<ul>
--/li Window
--/li VScroll
--/li HScroll
--/li VTrackBar
--/li HTrackBar
--/li ProgressBar
--/li UpDown
--</ul>
-- For /b Window controls, the /i id parameter can also specify which of
-- the vertical or horizontal scrollbars you are referring to. To do this,
-- the form of /i id is { ctrl, bartype } where /i bartype is either
-- /b SB_VERT, /b SB_HORZ or /b SB_CTL (for /HScroll or VScroll controls).
--
-- Example:
--/code
--          -- get value of TheScroll
--          integer pos,vpos,hpos
--          pos = /getThumbPos( TheScroll )
--          vpos = /getThumbPos( {MainWin, SB_VERT} )
--          hpos = /getThumbPos( {MainWin, SB_HORZ} )
--/endcode

-- 2/19/04 mwl: added this to get the thumb position when dragged by the mouse
global function getThumbPos( object id )
	atom lSif, lPos

	integer lSBar
	-- return the value of the scroll bar


	if sequence(id) then
		lSBar = w32iff(find(id[2], {SB_VERT,SB_HORZ,SB_CTL}), id[2], SB_VERT)
		id = id[1]
	else
		lSBar = SB_CTL
	end if

    if find(ctrl_Type[id], {HTrackBar, VTrackBar}) then
        return sendMessage(id, TBM_GETPOS, 0 , 0)
    end if

	-- Allocate structure
	lSif = w32acquire_mem(0, SIZEOF_SCROLLINFO )

	-- store values
	w32store( lSif, sifSize, SIZEOF_SCROLLINFO )
	w32store( lSif, sifMask, SIF_TRACKPOS + SIF_POS )
	VOID = w32Func( xGetScrollInfo, {getHandle(id), lSBar, lSif})
	lPos = w32fetch( lSif, sifTrackPos )
	w32release_mem( lSif )

	return lPos

end function


-----------------------------------------------------------------------------
--/topic Scroll Control
--/func getVScrollPos( window )
--/desc Gets the value of a window's vertical scroll bar.
--/ret Position of the thumb on the scroll control.
--
-- Example:
--/code
--          -- get value of TheScroll
--          integer pos
--          pos = getVScrollPos( myWindow )
--/endcode

global function getVScrollPos( integer id )
    -- return the value of the scroll bar

    return getScrollPos( {id, SB_VERT})
end function

-----------------------------------------------------------------------------
--/topic Scroll Control
--/func getHScrollPos( window )
--/desc Gets the value of a window's horizontal scroll bar.
--/ret Position of the thumb on the scroll control.
--
-- Example:
--/code
--          -- get value of TheScroll
--          integer pos
--          pos = getHScrollPos( myWindow )
--/endcode

global function getHScrollPos( integer id )

    -- return the value of the scroll bar
    return getScrollPos( {id, SB_HORZ})
end function

-----------------------------------------------------------------------------
--/topic UpDown Control
--/proc setAcceleration( integer id, sequence Times )
--/desc Set the rate of change for an UpDown control
--The UpDown control specified by /i id will change it's values while the user holds
-- down the mouse button. You can alter the rate of the change by using this routine. /n
-- The /i Times parameter is a list of /b pairs of values, in which the first of a pair
-- is the number of seconds to elapse (from the time the button was pressed) before changing,
-- and the second is the (positive) increment to change the current value by.
--
--Example:
--/code
--      setAcceleration(myUpDown, {  {1,2}, {3,4}, {5, 8}, {7,16} } )
--/endcode

global procedure setAcceleration( integer id,  sequence pTimes)
    atom lAccel
    atom lAddr

    pTimes = sort(w32abs(floor(pTimes)))
    lAddr  = w32acquire_mem(0, length(pTimes) * 8)
    lAccel = lAddr

    for i = 1 to length(pTimes) do
        poke4(lAccel, pTimes[i])
        lAccel += 8
    end for
    VOID = sendMessage( id, UDM_SETACCEL, length(pTimes) , lAddr )

    w32release_mem(lAddr)
end procedure



-----------------------------------------------------------------------------
-- GRAPHICS
--

-----------------------------------------------------------------------------
--/topic Graphics
--/proc setBackColor( integer id, object color )
--/desc Set the color for used for the pen fill color in /i id.
-- When the pen mode is set to /b OPAQUE, this specifies the color
-- used to fill the 'gaps'.
--
-- When used on a MonthCalendar control, it changes the background color
-- imediately.
--
-- When used on a Pixmap control, it clears the entire Pixmap to the
-- specified color.
--
-- Example:
--/code
--      -- set pen opaque color
--      setPenBkMode( TheWindow, OPAQUE)
--      setBackColor( TheWindow, Red )
--      /wPuts( TheWindow, "This text is on red" )
--
--      -- Clear a pixmap
--      setBackColor( pixmap1, BrightWhite)
--/endcode

global procedure setBackColor( integer id, object color )

    -- set the background color for the window
    atom hdc
    sequence lRect
    object lSavedColor

    if equal(color, w32WinDefColor) then
        return
    end if

    if ctrl_Type[ id ] = MonthCalendar then
        setMonthColor( id, MCSC_BACKGROUND, color )
        return

    elsif ctrl_Type[id] = Pixmap then
        lRect = getRect(id)
        lSavedColor = ctrl_Pen[id][PenColor]
        ctrl_Pen[id][PenColor] = color
        call_proc(r_drawRectangle,{id, w32True, 0, 0, lRect[3], lRect[4]})
        ctrl_Pen[id][PenColor] = lSavedColor
        return

    end if

    hdc = getDC( id )
    if w32Func(xSetBkColor, {hdc, colorValue(color)} ) = CLR_INVALID then
        warnErr( "SetBkColor in setBackColor failed." )
    end if
    releaseDC(id)
end procedure
r_setBackColor = routine_id("setBackColor")


-----------------------------------------------------------------------------
global procedure createBrush( integer id, integer filled, atom hdc )

    -- create the appropriate brush for the filled shape
    -- 'filled' is the brush flag

    atom hBrush
    integer idx
    atom lColor

    if filled != 0 then
        -- create a pen
        if length(ctrl_Pen[id][PenBrushColor]) = 0 then
            lColor = colorValue( ctrl_Pen[id][PenColor])
        else
            lColor = colorValue( ctrl_Pen[id][PenBrushColor][1])
        end if
        hBrush = w32Func(xCreateSolidBrush, {lColor })

    else
        -- use null brush
        hBrush = NullBrushID
    end if

    -- replace the brush in the dc
    replaceObject( id, kBrushObject, hdc, hBrush, ForProgram )

end procedure
r_createBrush = routine_id("createBrush")

-----------------------------------------------------------------------------
procedure createPen( integer id, atom hdc )

    -- make sure the pen is set

    atom result, rop2, hPen
    integer lLifeTime
    integer idx
    sequence lPenDefn

    lPenDefn = {
    	    ctrl_Pen[id][PenStyle],
    	    ctrl_Pen[id][PenWidth],
    	    UseColor(ctrl_Pen[id][PenColor])
    	        }

    hPen = w32Func(xCreatePen, lPenDefn)

    -- select into the current device
    replaceObject( id, kPenObject, hdc, hPen, ForProgram )

    -- set the ROP2 style
    rop2 = ctrl_Pen[id][PenROP2]
    if rop2 then
        if not w32Func( xSetROP2, { hdc, rop2 } ) then
    	    warnErr( "SetROP2 in createPen failed." )
        end if
    end if

end procedure
r_createPen = routine_id("createPen")


-----------------------------------------------------------------------------
--/topic Graphics
--/proc setPenColor( window, color )
--/desc Set the the pen color used in /i window.
-- This is the color that is used by other graphics routines.
--
-- To set the color of text, use /setTextColor.
--
-- Example:
--/code
--          -- set pen color to red
--          /setPenColor( TheWindow, /Red )
--          -- draw a red line
--          /drawLine( TheWindow, 10, 10, 40, 40 )
--/endcode

global procedure setPenColor( integer id, object color )

    -- set a new pen color for the window

    -- save the color
    ctrl_Pen[id][PenColor] = color

end procedure
r_setPenColor = routine_id("setPenColor")

-----------------------------------------------------------------------------
--/topic Graphics
--/proc setPenWidth( window, pixel width )
--/desc Set the the pen width used in /i window.
-- The default thickness of the pen is 1 pixel.
--
-- Example:
--/code
--          -- set pen thickness of 3
--          /setPenWidth( TheWindow, 3 )
--          -- draw a thick line
--          /drawLine( TheWindow, 10, 10, 40, 40 )
--/endcode

global procedure setPenWidth( integer id, integer pixels )

    -- set a new pen thickness for the window

    -- save the thickness
    ctrl_Pen[id][PenWidth] = pixels

end procedure



-----------------------------------------------------------------------------
--/topic Graphics
--/proc setPenStyle( window, style )
--/desc Set the style that lines are drawn in.
-- This allows the creation of various dotted line styles.
-- Use /setBackColor to define the background fill used on the line.
--
-- The following styles are defined:
--
-- /li /b Solid
-- /li /b Dash
-- /li /b Dot
-- /li /b DashDot
-- /li /b DashDotDot
--
-- /b Note: This routine will probably be dropped in later releases.
--
-- Example:
--/code
--          -- set pen style
--          /setPenStyle( TheWindow, Dot )
--
--          -- draw a line using that pen style
--          /drawLine( TheWindow, 10, 10, 100, 100 )
--/endcode

global procedure setPenStyle( integer id, atom style )

    -- set a new pen style for the window

    -- save the style
    ctrl_Pen[id][PenStyle] = style

end procedure

-----------------------------------------------------------------------------
--/topic Graphics
--/proc setPenMode( integer id, integer mode )
--/desc Determines what mode graphics are drawn in.
-- The default value is /b R2_COPYPEN. The mode codes are:
--
-- /li /b R2_BLACK: Pixel is always 0.
-- /li /b R2_NOTMERGEPEN: Pixel is the inverse of the R2_MERGEPEN color.
-- /li /b R2_MASKNOTPEN: combination common screen and inverse of pen.
-- /li /b R2_NOTCOPYPEN: Pixel is the inverse of the pen color.
-- /li /b R2_MASKPENNOT: combination common to pen and inverse of screen.
-- /li /b R2_NOT: Pixel is the inverse of the screen color.
-- /li /b R2_XORPEN: Pixel is the inverse of the R2_XORPEN color.
-- /li /b R2_NOTMASKPEN: Pixel is the inverse of the R2_MASKPEN color.
-- /li /b R2_MASKPEN: combination common to pen and the screen.
-- /li /b R2_NOTXORPEN: combination of colors in pen and screen, but not in both.
-- /li /b R2_NOP: Pixel remains unchanged.
-- /li /b R2_MERGENOTPEN: combination of screen and inverse of pen.
-- /li /b R2_COPYPEN: Pixel is the pen color.
-- /li /b R2_MERGEPENNOT: combination of pen color and inverse of screen color.
-- /li /b R2_MERGEPEN: combination of pen color and the screen color.
-- /li /b R2_WHITE: Pixel is always 1.
--
-- Example:
--/code
--          -- draw an XOR line in TheWindow
--          /setPenMode( TheWindow, R2_XORPEN )
--          /drawLine( TheWindow, 10, 10, 100, 100 )
--/endcode

global procedure setPenMode( integer id, atom rop2 )
    -- sets the ROP2 mode for the window
    ctrl_Pen[id][PenROP2] = rop2
end procedure

-----------------------------------------------------------------------------
--/topic Graphics
--/proc setPenBkMode( window, mode )
--/desc Determines if the background color for lines and text.
-- Modes are:
--
-- /li /b OPAQUE: Draws using background color.
-- /li /b TRANSPARENT: Draws without background color.
--
-- If /i mode is /b OPAQUE, the color set in /setBackColor is used.
-- The default mode is /b TRANSPARENT.
--
--
-- Example:
--/code
--          -- draw an XOR line in TheWindow
--          /setPenBkMode( TheWindow, OPAQUE )
--          /drawLine( TheWindow, 10, 10, 100, 100 )
--/endcode

global procedure setPenBkMode( integer id, atom bkMode )
    -- sets the pen background mode
    -- default is transparent
    ctrl_Pen[id][PenBkMode] = bkMode
end procedure


--/topic Graphics
--/proc setPenBkColor( window, color )
--/desc Determines the background color for text.
--
-- Example:
--/code
--  setPenBkColor( Fld1, BrightCyan )
--/endcode

global procedure setPenBkColor( integer id, object color )
    ctrl_Pen[id][PenBkColor] = color
end procedure

--/topic Graphics
--/proc setPenBrushColor( window, color )
--/desc Determines the solid brush color for filled shapes.
--The current pen color is used until this is called for the first time.
--
-- Example:
--/code
--  setPenBrushColor( MyCanvas, Blue)
--/endcode

global procedure setPenBrushColor( integer id, object color )
    ctrl_Pen[id][PenBrushColor] = {color}
end procedure


-----------------------------------------------------------------------------
--/topic Graphics
--/func getPixel( window, x, y )
--/desc Get a pixel value from /i window's client area.
--/ret rgb value of point.
-- Example:
--
--/code
--      -- get a pixel color from {10,10} in TheWindow
--      atom rgb
--      rgb = /getPixel( TheWindow, 10, 10 )
--/endcode

-- NEW! 0.43b restored as global
global function getPixel( integer id, integer x, integer y )

    integer rgb
    atom hdc

    -- get the device context
    hdc = getDC( id )

    -- get pixel
    rgb = w32Func( xGetPixel, {hdc, x, y} )

    -- release the device context
    releaseDC( id )

    return rgb

end function
r_getPixel = routine_id("getPixel")

-----------------------------------------------------------------------------
--/topic Graphics
--/proc setPixel( window, x, y, rgb color )
--/desc Set a pixel value in /i window's client area.
--
-- Example:
--
--/code
--      -- set pixel at {10,10} to Red
--      /setPixel( TheWindow, 10, 10, Red )
--/endcode

global procedure setPixel( integer id, integer x, integer y, object rgbColor )

    -- returns RGB value from point
    atom hdc

    -- get the device context
    hdc = getDC( id )

    -- get pixel
    VOID = w32Func( xSetPixel, {hdc, x, y, colorValue(rgbColor) } )

    -- release the device context
    releaseDC( id )

end procedure


-----------------------------------------------------------------------------
--/topic Graphics
--/proc drawLine( window, pStartX, pStartY, pEndX, pEndY )
--/desc Draw a line.
-- The line is drawn in the current pen color between { /i pStartX, /i pStartY }
-- and { /i pEndX, /i pEndY }.
--
-- Example:
--
--/code
--      -- draw a line in TheWindow from {10,10} to {100,100}
--      /drawLine( TheWindow, 10, 10, 100, 100 )
--/endcode

global procedure drawLine( integer id, integer pStartX, integer pStartY, integer pEndX, integer pEndY )

    object hdc

    -- get the device context
    hdc = getDC( id )

    -- create a pen
    createPen( id, hdc )

    -- move to the first point
    VOID = w32Func(xMoveToEx, {hdc, pStartX, pStartY, NULL})

    -- draw the line
    VOID = w32Func(xLineTo, {hdc, pEndX, pEndY})

    -- release the device context
    releaseDC( id )

end procedure


--/topic Graphics
--/proc drawLines( integer id, sequence coords )
--/desc Draws zero or more lines.
-- The lines are drawn between the sets of coordinates in /i coords. /n
-- This sequence can contain Colors, Points, Lines, or Rects. /n
--/li A /b Color is a single atom that is a 24-bit color value. Subsequent lines use this color.
--/li A /b Point is a 2-element sequence {X,Y} that gives the X,Y position of the end-point
-- of a line. The line is drawn to this position from the last end-point supplied,
-- or if this is the first Point specified, the current pen position for the control.
-- See /setPenPos().
--/li A /b Line is a 4-element sequence {X1,Y1,X2,Y2} that specifies the X,Y position of a line's
-- starting point and the X,Y position of its end point. The line is drawn from X1,Y1
-- to X2,Y2.
-- /li A /b Rect is a 5-element sequence {Fill, X1,Y1,X2,Y2} that specifies a rectangle.
-- The first element is w32True for a filled rectangle and w32False for an outline only. The
-- X1,Y1 is the X,Y position of the top-left corner and X2,Y2 is the X,Y position of the
-- bottom-right corner.
--
-- If no color parameters are supplied, the current pen color for the control is used.
--
-- Example:
--
--/code
--      -- draw a shape in TheWindow
--      /drawLines( TheWindow, {White,{40,0,0,80},{80,80},{40,0},
--                              Blue,{40,5,0,85},{80,85},{40,5}
--                             } )
--/endcode
global procedure drawLines( integer id, sequence coords)
    integer x1, y1,
            x2, y2

    object hdc, result

    -- Initialize them to improbable values.
    x2 = -987654321
    y2 = -987654321

    -- get the device context
    hdc = getDC( id )

    -- create a pen
    if length(coords) > 0 and not atom(coords[1]) then
        -- Make sure we have a pen to start with.
        createPen( id, hdc )
    end if

    x1 = ctrl_X_Pos[id]
    y1 = ctrl_Y_Pos[id]

    for i = 1 to length(coords) do
        if atom(coords[i]) then
            setPenColor(id, coords[i])
            createPen( id, hdc )

        elsif length(coords[i]) = 5 then
            createBrush( id, coords[i][1], hdc )
            x1 = coords[i][2]
            y1 = coords[i][3]
            x2 = coords[i][4]
            y2 = coords[i][5]
            VOID = w32Func( xRectangle, {hdc, x1, y1, x2, y2 } )

        elsif length(coords[i]) = 4 then
                x1 = coords[i][1]
                y1 = coords[i][2]
                x2 = coords[i][3]
                y2 = coords[i][4]
                -- move to the first point
                VOID = w32Func(xMoveToEx, {hdc, x1, y1, NULL})

                -- draw the line
                VOID = w32Func(xLineTo, {hdc, x2, y2})

        elsif length(coords[i]) = 2 then
            if x2 != -987654321 or y2 != -987654321 then
                x1 = x2
                y1 = y2
            end if
            x2 = coords[i][1]
            y2 = coords[i][2]

            -- move to the first point
            VOID = w32Func(xMoveToEx, {hdc, x1, y1, NULL})

            -- draw the line
            VOID = w32Func(xLineTo, {hdc, x2, y2})
        end if
    end for

    -- release the device context
    releaseDC( id )

end procedure


-----------------------------------------------------------------------------
--/topic Graphics
--/proc drawRectangle( window, filled, x1, y1, x2, y2 )
--/desc Draw a rectangle.
-- Draws the rectangle in the current pen color from { /i x1, /i y1 }
-- to { /i x2, /i y2 }. If /i filled is true, the rectangle is filled
-- in the current pen color.
--
-- Example:
--
--/code
--      -- draw a filled green rectangle in TheWindow
--      /setPenColor( TheWindow, Green )
--      /drawRectangle( TheWindow, w32True, 10, 10, 100, 100 )
--/endcode

global procedure drawRectangle( integer id, integer filled,
	    	    integer x1, integer y1,
	    	    integer x2, integer y2 )

    -- draw a rectangle
    atom hdc
    atom lErr

    -- get the device context

    hdc = getDC( id )

    -- create a pen
    createPen( id, hdc )

    -- create the brush
    createBrush( id, filled, hdc )

    -- call Rectangle
    VOID = w32Func( xRectangle, {hdc, x1, y1, x2, y2 } )

    -- release the device context
    releaseDC( id )


end procedure
r_drawRectangle = routine_id("drawRectangle")

-----------------------------------------------------------------------------
--/topic Graphics
--/proc drawRoundRect( window, filled, x1, y1, x2, y2, xc, yc )
--/desc Draw a rounded rectangle.
-- Draws the rounded rectangle in the current pen color from { /i x1, /i y1 }
-- to { /i x2, /i y2 }. The ellipse corner width and height are specified
-- in /i xc and /i yc. If /i filled is true, the rectangle is filled
-- in the current pen color.
--
-- Example:
--
--/code
--      -- draw a filled blue round rectangle in TheWindow
--      /setPenColor( TheWindow, Green )
--      /drawRoundRect( TheWindow, w32True, 10, 10, 100, 100, 5, 5 )
--/endcode

global procedure drawRoundRect( integer id, integer filled,
	    	    integer x1, integer y1,
	    	    integer x2, integer y2,
	    	    integer xc, integer yc )

    -- draw a rounded rectangle
    -- xc = ellipse corner width
    -- yc = ellipse corner height
    atom hdc

    -- get the device context
    hdc = getDC( id )

    -- create a pen
    createPen( id, hdc )

    -- create the brush
    createBrush( id, filled, hdc )

    -- call RoundRect
    VOID = w32Func( xRoundRect, {hdc, x1, y1, x2, y2, xc, yc } )

    -- release the device context
    releaseDC( id )
end procedure



-----------------------------------------------------------------------------
--/topic Graphics
--/proc drawEllipse( window, filled, x1, y1, x2, y2 )
--/desc Draw an ellipse.
-- Draws the ellipse in the current pen color within the rectangle
-- bounded by { /i x1, /i y1 } and { /i x2, /i y2 }. If /i filled
-- is true, the ellipse is filled in the current pen color.
--
-- Example:
--
--/code
--      -- draw a black ellipse in TheWindow
--      /setPenColor( TheWindow, Black )
--      /drawEllipse( TheWindow, w32True, 10, 10, 100, 100 )
--/endcode

global procedure drawEllipse( integer id, integer filled,
	    	    integer x1, integer y1,
	    	    integer x2, integer y2 )

    -- draw an ellipse
    atom hdc

    -- get the device context
    hdc = getDC( id )

    -- create a pen
    createPen( id, hdc )

    -- create the brush
    createBrush( id, filled, hdc )

    -- call Ellipse
    VOID = w32Func( xEllipse, {hdc, x1, y1, x2, y2 } )

    -- release the device context
    releaseDC( id )

end procedure


-----------------------------------------------------------------------------
--/topic Graphics
--/proc drawArc( window, filled, x1, y1, x2, y2, xStart, yStart, xEnd, yEnd )
--/desc Draw an arc.
-- Draws the arc in the current pen color. The arc's bounding rectangle
-- is defined as { /i x1, /i y1 } to { /i x2, /i y2 }. If /i filled
-- is true, the ellipse is filled in the current pen color.
--
-- The arc is defined by the intersection between the radial start point
-- and radial end point. The radial start point is a line running from
-- the center of the bounding rectangle to { /i xStart, /i yStart }, and
-- radial end point by a line running from the center of the bounding
-- rectangle to { /i xEnd, /i yEnd }.
--
-- If /i filled is true, the arc will be filled.
--
-- Example:
--
--/code
--      -- draw a bright cyan filled arc in TheWindow
--      /setPenColor( TheWindow, BrightCyan )
--      /drawArc( TheWindow,
--                  w32True,           -- filled
--                  1, 1,           -- upper left boundary
--                  100, 100,       -- lower right boundary
--                  49, 1,          -- top center of rectangle
--                  100, 49 )       -- right center of rectangle
--/endcode

global procedure drawArc( integer id, integer filled,
	            integer x1, integer y1,
	            integer x2, integer y2,
	            integer xStart, integer yStart,
	            integer xEnd, integer yEnd )

    -- draw an arc
    -- xStart, yStart: start of arc; on imaginary line from center of arc
    -- xEnd, yEnd    : end of arc; on imaginary line from center of arc
    atom hdc

    -- get the device context
    hdc = getDC( id )

    -- create a pen
    createPen( id, hdc )

    -- create the brush
    createBrush( id, filled, hdc )

    -- call Arc
    VOID = w32Func( xArc, {hdc, x1, y1, x2, y2, xStart, yStart, xEnd, yEnd } )

    -- release the device context
    releaseDC( id )

end procedure


-----------------------------------------------------------------------------
--/topic Graphics
--/proc drawChord( window, filled, x1, y1, x2, y2, xStart, yStart, xEnd, yEnd )
--/desc Draw a chord.
-- Draws the chord in the current pen color.
--
-- A /i chord is a region bounded by the intersection of an ellipse and a
-- line segment. The ellipse is bounding rectangle is defined
-- { /i x1, /i y1 } to { /i x2, /i y2 }.  If /i filled is true, the
-- chord is filled in the current pen color.
--
-- The chord is defined by the intersection between the radial start point
-- and radial end point. The radial start point is a line running from
-- the center of the bounding rectangle to { /i xStart, /i yStart }, and
-- radial end point by a line running from the center of the bounding
-- rectangle to { /i xEnd, /i yEnd }.
--
-- If /i filled is true, the chord will be filled.
--
-- Example:
--
--/code
--      -- draw a yellow chord in TheWindow
--      /setPenColor( TheWindow, Yellow )
--      /drawChord( TheWindow,
--                  w32True,           -- filled
--                  1, 1,           -- upper left boundary
--                  100, 100,       -- lower right boundary
--                  49, 1,          -- top center of rectangle
--                  100, 49 )       -- right center of rectangle
--/endcode

global procedure drawChord( integer id, integer filled,
	    	    integer x1, integer y1,
	    	    integer x2, integer y2,
	    	    integer xStart, integer yStart,
	    	    integer xEnd, integer yEnd )

    -- draw an chord
    -- xStart, yStart: start of arc; on imaginary line from center of arc
    -- xEnd, yEnd    : end of arc; on imaginary line from center of arc
    atom hdc

    -- get the device context
    hdc = getDC( id )

    -- create a pen
    createPen( id, hdc )

    -- create the brush
    createBrush( id, filled, hdc )

    -- call Chord
    VOID = w32Func( xChord, {hdc, x1, y1, x2, y2, xStart, yStart, xEnd, yEnd } )

    -- release the device context
    releaseDC( id )

end procedure


-----------------------------------------------------------------------------
--/topic Graphics
--/proc drawPie( window, filled, x1, y1, x2, y2, xStart, yStart, xEnd, yEnd )
--/desc Draw a pie slice.
-- Draws the pie slice in the current pen color. The bounding rectangle
-- is defined as { /i x1, /i y1 } to { /i x2, /i y2 }. If /i filled
-- is true, the slice is filled in the current pen color.

--
-- The curve start and end points are defined by the intersection between
-- the radial start point and radial end point. The radial start point is
-- a line running from the center of the bounding rectangle to {
--  /i xStart, /i yStart }, and radial end point by a line running from
-- the center of the bounding rectangle to { /i xEnd, /i yEnd }.
--
-- If /i filled is true, the pie will be filled.
--
-- Example:
--
--/code
--      -- draw a blue filled arc in TheWindow
--      /setPenColor( TheWindow, Blue )
--      /drawPie( TheWindow,
--                  w32True,           -- filled
--                  1, 1,           -- upper left boundary
--                  100, 100,       -- lower right boundary
--                  49, 1,          -- top center of rectangle
--                  100, 49 )       -- right center of rectangle
--/endcode

global procedure drawPie( integer id, integer filled,
	            integer x1, integer y1,
	            integer x2, integer y2,
	            integer xStart, integer yStart,
	            integer xEnd, integer yEnd )

    -- draw a pie slice
    -- xStart, yStart: start of arc; on line from center of arc
    -- xEnd, yEnd    : end of arc; on line from center of arc
    atom hdc

    -- get the device context
    hdc = getDC( id )

    -- create a pen
    createPen( id, hdc )

    -- create the brush
    createBrush( id, filled, hdc )

    -- call DrawPie
    VOID = w32Func( xPie, {hdc, x1, y1, x2, y2, xStart, yStart, xEnd, yEnd } )

    -- release the device context
    releaseDC( id )

end procedure

-----------------------------------------------------------------------------
--/topic Graphics
--/proc drawPolygon( integer id, integer filled, sequence points )
--/desc Draw a polygon.
-- Draws the polygon in /i id in the current pen color using /i points.
-- If i/ filled is true, the polygon will be filled.
--
-- /i points is either a set of two-element co-ordinates or a list of alternating
-- x,y coordinates.
--
-- Example:
--
--/code
--      -- draw a blue filled triangle in TheWindow
--      sequence points
--
--      -- define the points
--      points = {  { 10, 10 },
--                  { 80, 40 },
--                  { 40, 80 } }
--
--      -- alternative method to define the points
--      points = {  10, 10,
--                  80, 40,
--                  40, 80  }
--      -- set pen color
--      /setPenColor( TheWindow, Blue )
--
--      -- draw a filled polygon using the points
--      /drawPolygon( TheWindow, w32True, points )
--/endcode

global procedure drawPolygon( integer id, integer filled, sequence points )

    -- draw a polygon
    integer count, offset
    atom hdc, address

    -- count of points
    count = length( points )
    if count = 0 then
        return
    end if

    if atom(points[1]) then
        -- Allocate room for points
        address = w32acquire_mem(0, count * 4 )
        poke4(address, points)
        count /= 2
    else
        -- Allocate room for points
        address = w32acquire_mem(0, count * 4 * 2 )
        -- poke the points
        offset = address
        for i = 1 to count do

            -- x,y point
            poke4( offset, points[i])
            -- increment offset
            offset += 8

        end for
    end if

    -- get the device context
    hdc = getDC( id )

    -- create a pen
    createPen( id, hdc )

    -- create the brush
    createBrush( id, filled, hdc )

    -- call Polygon
    VOID =  w32Func( xPolygon, {hdc, address, count } )

    -- release the device context
    releaseDC( id )

    -- release the memory
    w32release_mem( address )

end procedure

------------------------------------------------------------------------------
function loadBitmapFromFile2( sequence fileName )

    -- alternate version of loadBitmapFromFile
    -- this should work for NT and other versions not
    -- supporting LoadImage's load from file option.
    --
    -- this version is called if the default version fails

    atom        bmFile, bmInfoHeader, bmBits, bmColors, hdc, hDib
    integer     hFile, fSize, byte
    sequence    info


    hFile = w32FileOpen( fileName, "rb" )
    if hFile = -1 then
        -- warning
        warnErr( sprintf( "Unable to open '%s', in ReadDIB", {fileName} ) )
        return NULL
    end if

    -- Get the file size
    VOID = seek(hFile, -1)
    fSize = where(hFile)
    VOID = seek(hFile, 0)

    -- read the whole file
    bmFile = w32acquire_mem(0, fSize )
    for i = 0 to fSize-1 do

        -- get a byte from the file
        byte = getc( hFile )

        -- eof?
        if byte = -1 then

            -- Free memory
            w32release_mem( bmFile )

            -- warning
            warnErr( sprintf( "Early EOF in '%s', in ReadDIB", {fileName} ) )

            -- return failure
            return NULL

        else
            -- poke into structure
            poke( bmFile+i, byte )
        end if

    end for


    -- check header
    if compare( w32fetch( bmFile, bfType ), "BM" ) != 0 then
        close( hFile )
        w32release_mem( bmFile )
        -- warning
        warnErr( sprintf( "'%s' not a bitmap file, in ReadDIB", {fileName} ) )
        return NULL
    end if

    -- check header size against file size
    if w32fetch( bmFile, bfSize ) != fSize then
        -- warning
        warnErr( sprintf( "Bitmap '%s' is corrupt, in ReadDIB", {fileName} ) )
        -- correct header in memory
        w32store( bmFile, bfSize, fSize )
    end if

    -- address of BitmapInfoHeader
    bmInfoHeader = bmFile + SIZEOF_BITMAPFILEHEADER

    -- offset to bitmap data
    bmBits = bmFile + w32fetch( bmFile, bfOffBits )

    -- address of color information
    bmColors = bmInfoHeader + SIZEOF_BITMAPINFOHEADER

    -- Get the screen's device context.
    hdc = getDC( Screen )

    -- Create the DIB.
    hDib = w32Func( xCreateDIBitmap, {
	        hdc,                -- handle to device context
	        w32address( bmInfoHeader, bmiHeader ), -- pointer to BITMAPINFOHEADER
	        CBM_INIT,           -- initialization flag
	        bmBits,             -- address of initialization data
	        bmInfoHeader,       -- pointer to color data
	        DIB_RGB_COLORS} )   -- colors are RGB tuples

    -- release the screen dc
    releaseDC( Screen )

    -- Free memory
    w32release_mem( bmFile )

    return hDib

end function



-----------------------------------------------------------------------------
--/topic Graphics
--/func loadBitmapFromFile( file name )
--/desc Loads a bitmap file.
--/ret Win32 handle of bitmap, or /b Null if an error occured.
-- /b Note: The name /i bitmap is a bit confusing; it should be more
-- properly called /i loadDIBFromFile. At some point, the graphic
-- routines need to be renamed in a more consistant manner.
--
-- Example:
--
--/code
--          -- load a bitmap, and display in window
--          atom hBitmap
--
--          -- load the bitmap
--          hBitmap = /loadBitmapFromFile( "graphic.bmp" )
--
--          -- display the bitmap in TheWindow at {1,1}
--          /drawBitmap( theWindow, hBitmap, 1, 1 )
--
--/endcode

global function loadBitmapFromFile( sequence fName )

    -- loads a bitmap, returns the handle
    atom hImage
    atom lImageType
    integer lObjectType


    -- load it
    lImageType = IMAGE_BITMAP
    lObjectType = kBitmapObject
    fName = w32FindFile(fName)
    if match(".ico", lower(fName)) = length(fName) - 3 then
        lImageType = IMAGE_ICON
        lObjectType = kIconObject
    end if

    hImage = w32Func(xLoadImage,
        {NULL, fName, lImageType, 0, 0, LR_LOADFROMFILE})

    -- success?
    if hImage = NULL then
        -- try using alternate version
        hImage = loadBitmapFromFile2( fName )
        -- failed again?
        if hImage = NULL then
            warnErr( "LoadImage in loadBitmapFrom File failed." )
        end if
    end if

    trackObject( {-1, lObjectType}, hImage, ForProgram )

    return hImage

end function
r_loadBitmapFromFile = routine_id("loadBitmapFromFile")



-----------------------------------------------------------------------------
--/topic Graphics
--/proc drawBitmap( window, DIB handle, x, y )
--/desc Draws /i DIB (device independant bitmap) in /i window at { /i x, /i y }.
-- /b Note: The term /i bitmap is inconsistant; I expect to be renaming
-- these routines in the future.
--
-- Example:
--
--/code
--          -- load a bitmap, and display in window
--          atom hBitmap
--
--          -- load the bitmap
--          hBitmap = /loadBitmapFromFile( "graphic.bmp" )
--
--          -- display the bitmap in TheWindow at {1,1}
--          /drawBitmap( theWindow, hBitmap, 1, 1 )
--
--/endcode

global procedure drawBitmap( integer id, object bitmap,
	        integer xStart, integer yStart )

    -- Draw a bitmap onto the requested device
    atom lTargetDC, lSourceDC, lImageHandle
    atom mset, bm, ptSize, ptOrg
    atom lPrevBmp

    mset    = w32new_memset()
    bm      = w32acquire_mem(mset, SIZEOF_BITMAP )
    ptSize  = w32acquire_mem(mset, SIZEOF_POINT )
    ptOrg   = w32acquire_mem(mset, SIZEOF_POINT )


    -- need to load the bitmap?
    lImageHandle = 0
    if w32string( bitmap ) then
        -- passed a file name
        lImageHandle = loadBitmapFromFile( bitmap )

    elsif atom(bitmap) then
        lImageHandle = w32Func(xGetObjectType, {bitmap})
        if lImageHandle = 0 or lImageHandle = OBJ_BITMAP then
            -- passed handle
            lImageHandle = bitmap
        end if
    end if

    -- get the dimensions of the bitmap
    if not w32Func( xGetObject, {lImageHandle, SIZEOF_BITMAP, bm} ) then
        warnErr( "drawBitmap:GetObject failed." )
        w32release_mem(mset)
        return
    end if


    -- get the DC of the destination
    lTargetDC = getDC( id )

    -- create a memory device context based on the destination
    lSourceDC = w32Func( xCreateCompatibleDC, {lTargetDC} )
    if lSourceDC = NULL then
        warnErr( "drawBitmap:CreateCompatibleDC failed." )
        releaseDC(id)
        w32release_mem(mset)
        return
    end if

    -- select the bitmap into it
    lPrevBmp = w32Func( xSelectObject, {lSourceDC, lImageHandle} )

    -- set mapping mode to same as destination
    VOID = w32Func( xSetMapMode, {lSourceDC, w32Func( xGetMapMode, {lTargetDC} ) } )

    -- move the size into the point structure ptSize (logical coordinates)
    w32store( ptSize, ptX, w32fetch( bm, bmWidth ) )
    w32store( ptSize, ptY, w32fetch( bm, bmHeight ) )
    VOID = w32Func( xDPtoLP, {lTargetDC, ptSize, 1} )

    -- get the origin of the bitmap (logical coordinates)
    w32store( ptOrg, ptX, 0 )
    w32store( ptOrg, ptY, 0 )
    VOID = w32Func( xDPtoLP, {lTargetDC, ptOrg, 1} )

    -- copy bitmap to device context
    VOID = w32Func( xBitBlt, {
	        lTargetDC, xStart, yStart,
	        w32fetch( ptSize, ptX ), w32fetch( ptSize, ptY ),
	        lSourceDC,
	        w32fetch( ptOrg, ptX ), w32fetch( ptOrg, ptY ),
	        SRCCOPY} )

    -- release the device context
    VOID = w32Func( xSelectObject, {lSourceDC, lPrevBmp} )
    VOID = w32Func( xDeleteDC, {lSourceDC} )

    -- cleanup
    releaseDC( id )
    w32release_mem( mset )

end procedure



-----------------------------------------------------------------------------
function codeToBytes( sequence bits )
    -- Convert a sequence of text into bytes
    -- This is a support routine for createMonochromeBitmap
    -- Ex:  "1,1,1,1,1,1,1,1,0,0"
    --      --> { #FF, #00 }

    integer byte, extra
    sequence slice, bytes

    -- add extra bits: must be multiple of 16
    extra = remainder( length(bits), 16 )
    if extra then
        bits = bits & repeat( 1, 16-extra )
    end if

    -- convert bits to bytes
    bytes = {}

    for i = 1 to length( bits ) by 8 do
        -- get an 8 bit slice
        slice = bits[i..i+7]
        -- reverse it for conversion
        slice = reverse( slice )
        -- convert bits to a byte
        byte = bits_to_int( slice )
        -- add to list
        bytes = append( bytes, byte )
    end for
    return bytes
end function


-- NEW! 0.43 removed global
function createBitmap( sequence s )
    -- build a monochrome bitmap from text

    integer wide, high
    atom bitmapData, hBitmap
    sequence data

    -- get the size
    wide = length( s[1] )
    high = length( s )


    -- build the data
    data = {}
    for i = 1 to length( s ) do
        data = data & codeToBytes( s[i] )
    end for

    -- poke the bitmap into memory
    bitmapData = w32acquire_mem( 0, length( data ) )
    poke( bitmapData, data )

    -- create a bitmap
    hBitmap = w32Func( xCreateBitmap, {wide, high, 1, 1, bitmapData} )

    if hBitmap = 0 then
        warnErr( "CreateBitmap failed." )
    end if

    -- track resource for length of program
    trackObject( {-1,kBitmapObject}, hBitmap, ForProgram )

    -- release memory
    w32release_mem( bitmapData)

    return hBitmap

end function



-----------------------------------------------------------------------------
--/topic Graphics
--/func textToBitmap( text )
--/desc Converts a sequence of text into a monochrome bitmap.
--/ret Handle to Win32 bitmap, or /b Null on an error.
-- Spaces are converted to White pixels; all other characters are
-- converted to Black pixels.
--
-- /b Note: This routine should probably be deprecated, or at least
--          renames.
--
-- Example:
--
--/code
--          -- create a bitmap, and display it
--          atom hBitmap
--          sequence image
--
--          -- the image
--          image = {   " xxxxxx ",
--                      "x      x",
--                      "x x  x x",
--                      "x      x",
--                      "x x  x x",
--                      "x x  x x",
--                      "x xxxx x",
--                      " xxxxxx ",
--
--
--          -- create the bitmap
--          hBitmap = /textToBitmap( image )
--
--          -- display the bitmap in TheWindow at {1,1}
--          /drawBitmap( theWindow, hBitmap, 1, 1 )
--
--/endcode

global function textToBitmap( sequence s )

    -- build a monochrome bitmap from text

    -- all spaces become 1 and all non-spaces become 0.
    s = ( s = ' ' )

    -- create the bitmap
    return createBitmap( s )

end function

-----------------------------------------------------------------------------
function packScanLine( sequence pal, sequence pixels, integer bitsPer )
    -- convert a scanline of data into a packed scanline
    integer fill, bytes, byte, at, perByte, pixtemp
    sequence packed

-- NEW! 0.43 handled 24 bits
    if bitsPer = 24 then
    -- bytes in packed array
    bytes = length( pixels ) * 3

    -- packed pixels
    packed = repeat( 0, bytes )

    -- 3 byte triplet; blue, green, red
    at = 1
    for i = 1 to bytes/3 do
        pixtemp = pixels[i] + 1
        packed[at]   = pal[ pixtemp ][3]
        packed[at+1] = pal[ pixtemp ][2]
        packed[at+2] = pal[ pixtemp ][1]
        -- move to start of next triplet
        at += 3
    end for

-- NEW! 0.43 changed >= to =
    elsif bitsPer = 8 then -- 1:1
    packed = pixels

    elsif bitsPer = 4 then -- 4:1

    -- pad to even length
    pixels = pixels & repeat( 0, 1 )  ---- 3

    -- bytes in packed array
    bytes = floor( length( pixels ) / 2 )  ---- 4

    -- packed pixels
    packed = repeat( 0, bytes )

    -- 4 bits per; 2 numbers per byte
    at = 1
    for i = 1 to bytes*2 by 2 do  ---- 4

        -- build a byte
        packed[at] = (pixels[i] * 16)
	        + (pixels[i+1] * 1 ) ---- 4

        -- move to start of next byte
        at = at + 1

    end for

    elsif bitsPer = 1 then -- 8:1

    -- pad to even length
    pixels = pixels & repeat( 0, 7 )

    -- bytes in packed array
    bytes = floor( length( pixels ) / 8 )

    -- packed pixels
    packed = repeat( 0, bytes )

    -- 1 bits per; 8 numbers per byte
    at = 1
    for i = 1 to bytes*8 by 8 do

        -- build a byte
        packed[at] =  (pixels[i] *  128)
	        + (pixels[i+1] * 64)
	        + (pixels[i+2] * 32)
	        + (pixels[i+3] * 16)
	        + (pixels[i+4] * 8 )
	        + (pixels[i+5] * 4 )
	        + (pixels[i+6] * 2 )
	        +  pixels[i+7]

        -- move to next byte
        at = at + 1

    end for

    end if

    -- scanline needs to fall on an long boundary (4 bytes)
    fill = remainder( length( packed ), 4 )
    if fill then
    packed = packed & repeat( 0, 4-fill )
    end if

    return packed

end function


-----------------------------------------------------------------------------
--/topic Graphics
--/func createDIB( data )
--/ret Handle to Win32 bitmap, or /b Null on an error.
--/desc Converts a Euphoria bitmap format into a Win32 bitmap.
-- The data is in the form { pal, data }.
--
-- You only need to supply as many palette entries that are actually
-- used by the image. Pixel indexes into the palette start at 0 (to be
-- compatible with how Euphoria uses bitmaps)
--
-- Palette entries are color tuples in the form { r, g, b }, with each
-- color value ranging from 0 to 255.
--
-- Example:
--
--/code
--          -- create a bitmap, and display it
--          atom hBitmap
--          sequence pixels, pal
--
--          -- the pixels data
--          pixels = {
--              { 0,0,0,0 },        -- scan line 1
--              { 0,1,1,0 },        -- scan line 2
--              { 0,1,1,0 },        -- scan line 3
--              { 0,0,0,0 } }       -- scan line 4
--
--          -- the pal data (color tuples)
--          pal = {
--                { 255, 0, 0 },    -- color 0 is bright red
--                { 0, 0, 255 } }   -- color 1 is bright blue
--
--          -- create the DIB
--          hBitmap = /createDIB( {Pal, Pixels} )
--
--          -- display the bitmap in TheWindow at {1,1}
--          /drawBitmap( theWindow, hBitmap, 1, 1 )
--/endcode

-- NEW! 0.41 now is passed a Euphoria bitmap
global function createDIB( sequence euBmp )

    -- create a DIB (bitmap) from pixels and palette
    -- note that the sequence of pixels is *zero* based.

    integer colors, palSize, headerSize, bitsPer, h, w, fill
    sequence pal, pixels
    atom memBitmapInfo, memBits, at, hdc, hDIB, mset

    mset = w32new_memset()
    -- get values
    pal = euBmp[1]
    pixels = euBmp[2]

    -- number of colors
    colors = length( pal )

    -- palette and packing size
    if colors <= 2 then
        palSize = 2
        bitsPer = 1
    elsif colors <= 16 then
        palSize = 16
        bitsPer = 4
    elsif colors <= 256 then
        palSize = 256
        bitsPer = 8

    elsif colors <= 16777216 then
        palSize = colors
        bitsPer = 24
    end if

    -- size of bitmap
    w = length( pixels[1] )
    h = length( pixels )

    -- calculate the size of the BITMAPINFO header
    headerSize = SIZEOF_BITMAPINFOHEADER + (SIZEOF_RGBQUAD * palSize )

    -- Allocate memory for DIB
    memBitmapInfo = w32acquire_mem(mset, headerSize )

    -- build the bitmap info header
    w32store( memBitmapInfo, biSize, SIZEOF_BITMAPINFOHEADER )
    w32store( memBitmapInfo, biWidth, w )            -- Width in pixels.
    w32store( memBitmapInfo, biHeight, -h )          -- Height in pixels.
    w32store( memBitmapInfo, biPlanes, 1 )           -- 1 color plane.
    w32store( memBitmapInfo, biBitCount, bitsPer )   -- bits per pixel.
    w32store( memBitmapInfo, biCompression, 0 )      -- No compression.
    w32store( memBitmapInfo, biSizeImage, 0 )        -- Unneeded with no compression.
    w32store( memBitmapInfo, biXPelsPerMeter, 0 )    -- Unneeded.
    w32store( memBitmapInfo, biYPelsPerMeter, 0 )    -- Unneeded.

    -- # colors in color table that are used by the image. 0 means all.
    w32store( memBitmapInfo, biClrUsed, colors )

    -- # important colors. 0 = all.
    w32store( memBitmapInfo, biClrImportant, 0 )

    -- pack the pixels
    for i = 1 to h do
        pixels[i] = packScanLine( pal, pixels[i], bitsPer )
    end for

    -- get bytes per scanline
    w = length( pixels[1] )

    -- Allocate storage
    memBits = w32acquire_mem(mset, h * w )

    -- copy pixels to memory
    at = memBits
    for i = 1 to h do
        poke( at, pixels[i] )
        at = at + w
    end for

    -- get the address of the first rgb tuple
    at = w32address( memBitmapInfo, bmiColors )

    -- copy the pal to memory
    for i = 1 to colors do

        -- store values
        w32store( at, rgbRed, pal[i][1] )
        w32store( at, rgbGreen, pal[i][2] )
        w32store( at, rgbBlue, pal[i][3] )
        w32store( at, rgbReserved, 0 )

        -- move to next quad
        at = at + SIZEOF_RGBQUAD

    end for

    -- Get the screen's device context.
    hdc = getDC( Screen )

    -- Create the DIB.
    hDIB = w32Func( xCreateDIBitmap, {
	        hdc,
	        w32address( memBitmapInfo, bmiHeader ),
	        CBM_INIT,
	        memBits,
	        memBitmapInfo,
	        DIB_RGB_COLORS} )


    -- release the screen dc
    releaseDC( Screen )

    -- Free memory
    w32release_mem( mset )

    trackObject( {-1,kBitmapObject}, hDIB, ForProgram )

    return hDIB


end function


-----------------------------------------------------------------------------
--/topic System Attributes
--/func loadIconFromFile( object iconfile )
--/desc Get an icon from a file.
--/ret ATOM: A handle to an icon
-- /i iconfile is the name of an icon file. This can be a ICO, EXE,
-- or DLL file. However, this will only fetch the first icon in that file. Some
-- icon files can contain multiple icons. To use one of the other icons in a
-- multi-icon file, you need to use the syntax {filename, icon#}. The /icon# is the
-- number of the icon to use. The first icon is 1, the second is 2, etc...
--
-- Example:
--
--/code
--      -- get the icon from a file
--      hIcon = loadIconFromFile("euphoria.ico" )
--
--      -- get the 3rd icon from a file
--      hIcon = loadIconFromFile({"applib.ico", 3} )
--/endcode

global function loadIconFromFile( object icon )
    atom handle
    integer lIconNum

    -- is the icon a string (pathname) or a constant?
    if sequence( icon ) then
        lIconNum = 0
        if length(icon) = 2 and sequence(icon[1]) then
            lIconNum = icon[2]-1
            icon = icon[1]
        end if
        -- get the icon handle
        icon = w32FindFile(icon)
        handle = w32Func(xExtractIcon, {instance(), icon, lIconNum})
        trackObject({-1,kIconObject}, handle, ForProgram)
    else
        handle = 0
    end if

    return handle
end function


-----------------------------------------------------------------------------
--/topic Values
--/proc setIcon( integer id, object icon )
--/desc Assign an icon to /i object.
-- /i id can be one of the following:
--
-- /li /Window
-- /li /Icon
-- /li /PictureButton
-- /li /TogglePicture
--
-- /i icon can represent a file name, a handle to an icon, or a predefined system
-- icon code. /n
--
-- To use an icon handle, you need to first get the handle using some other
-- method (eg /loadIconFromFile) and pass it to this routine as a
-- sequence that only contains the handle. For example:  /b"{hIcon}" /n
--
-- To use a system icon, you need to specify one of the names: /n
--<ul>
--/li IDI_APPLICATION
--/li IDI_HAND
--/li IDI_QUESTION
--/li IDI_EXCLAMATION
--/li IDI_ASTERISK
--/li IDI_WINLOGO
--</ul>
--
-- To use an icon from a file, just supply the file name. This can be a ICO, EXE,
-- or DLL file. However, this will only fetch the first icon in that file. Some
-- icon files can contain multiple icons. To use one of the other icons in a
-- multi-icon file, you need to use the syntax {filename, icon#}. The /icon# is the
-- number of the icon to use. The first icno is 1, the second is 2, etc...
--
-- Example:
--
--/code
--      -- assign an icon to the window
--      setIcon( TheWindow, "euphoria.ico" )
--
--      -- assign the third icon to a button
--      setIcon( pBtnStop, {"applib.ico", 3} )
--
--      -- Use a icon handle
--      hIcon = /loadIconFromFile({"applib.ico", 2})
--      setIcon( pBtnGo, {hIcon})
--
--      -- Use a system icon
--      setIcon( bBtnErr, IDI_ERROR )
--
--/endcode

global procedure setIcon( integer id, object icon )
    -- assign an icon to an window
    -- Credit: Pete Eberlein

    atom szFile, handle, pstr
    integer lIconNum

    -- is the icon a string (pathname) or a constant?
    if sequence( icon ) then
        if length(icon) = 1 and atom(icon[1]) then
            handle = icon[1]
        else
            lIconNum = 0
            if length(icon) = 2 and sequence(icon[1]) then
                lIconNum = icon[2]-1
                icon = icon[1]
            end if
            -- get the icon handle
            icon = w32FindFile(icon)
            handle = w32Func(xExtractIcon, {getHandle(id), icon, lIconNum})
        end if
    elsif ctrl_Family[id] = WINDOW then
        handle = icon

    elsif find(icon, WinIcons) then
        -- use LoadIcon to load a Windows icon resource
        handle = w32Func(xLoadIcon, {NULL, icon})

    else
        handle = icon

    end if

    if and_bits(classAttr[ ctrl_Type[id]], w32PictCtrl ) != 0 then
        VOID = sendMessage( id, BM_SETIMAGE, IMAGE_ICON, handle )

    elsif ctrl_Family[id] = WINDOW then
        -- WM_SETICON associates an icon with a window
        VOID = sendMessage( id, WM_SETICON, ICON_BIG, handle )
        VOID = sendMessage( id, WM_SETICON, ICON_SMALL, handle )

    else
        -- STM_SETICON associates an icon with a control
        VOID = sendMessage( id, STM_SETICON, handle, 0 )
    end if

end procedure
r_setIcon = routine_id("setIcon")


-----------------------------------------------------------------------------
--/topic Values
--/proc setBitmap( integer Object, object Bitmap )
--/desc Assign an bitmap to /i Object.
-- /i Object can be one of the following:
--
-- /li /Bitmap
-- /li /PictureButton
-- /li /TogglePicture
--
-- If /i Bitmap is a sequence, it will be assumed to be the name of an
-- bitmap file, and Win32Lib will attempt to load the bitmap.
--
-- Otherwise, /i bitmap is assumed to be the handle of a bitmap.
--
-- Example:
--
--/code
--          -- assign a bitmap to the picture button
--          /setBitmap( PictureButton1, "close.bmp" )
--/endcode

global procedure setBitmap( integer id, object bitmap )

    -- assign an bitmap to a control
    -- Credit: Pete Eberlein
    atom pstr
    atom lImageType
    atom lMsgCode
    sequence lTrackingDetails


    -- is it a constant, or a file path?
    if sequence( bitmap ) then
        -- it's a pathname. use LOADFROMFILE.
        bitmap = call_func(r_loadBitmapFromFile,{bitmap})

    elsif bitmap = 0 then
        return
    end if

    lTrackingDetails = getTrackedObject( bitmap)
    if length(lTrackingDetails) > 0 then
        if lTrackingDetails[ResObjType] = kBitmapObject then
            lImageType = IMAGE_BITMAP
        else
            lImageType = IMAGE_ICON
        end if
    else
        lImageType = IMAGE_BITMAP
    end if

    if and_bits(classAttr[ ctrl_Type[id]], w32PictCtrl ) != 0 then
	    lMsgCode= BM_SETIMAGE
    else
	    lMsgCode = STM_SETIMAGE
    end if

    VOID = sendMessage( id, lMsgCode,  lImageType, bitmap )

end procedure
r_setBitmap = routine_id("setBitmap")

-----------------------------------------------------------------------------
--/topic Values
--/proc setPixmap( pixmap, bitmap )
--/desc Assign a new value to a /Pixmap.
-- If /i bitmap is a sequence, it will be assumed to be the name of an
-- bitmap file, and Win32Lib will attempt to load the bitmap.
--
-- Otherwise, /i bitmap is assumed to be the handle of a bitmap.
--
-- Example:
--
--/code
--          -- assign a bitmap to the picture button
--          /setPixmap( Pixmap1, "spaceship.bmp" )
--/endcode

-- NEW! 0.45m bitmap is now passed as an object
global procedure setPixmap( integer id, object bitmap )

    -- assign a new value to a pixmap

    -- is there an old bitmap?
    if    ctrl_Handle[ id ] != 0
      and ctrl_Handle[ id ] != -1 then
        deleteObject( getHandle( id ) )
    end if

    -- file name or handle?
    if sequence( bitmap ) then
        -- try to load bitmap file
        ctrl_Handle[ id ] = loadBitmapFromFile( bitmap )
    else
        -- just assign to handle
        ctrl_Handle[ id ] = bitmap
    end if
    ctrl_Handle_type[ id ] = kht_Bitmap

end procedure


-----------------------------------------------------------------------------
--/topic Graphics
--/func copyToBitmapFile( window, fileName, x1, y1, x2, y2 )
--/desc Copies image from /i window to file /i fileName.
--/ret Returns 0 if succeeds.
--
-- /i x1 and /i y1 refer to the top left pixel corner of the image,
-- and /i x2 and /i y2 refer to the bottom right corner of the image.
--
-- There are a number of caveats:
--
-- /li It uses /getPixel , so it's slow.
-- /li It uses /b save_bitmap, so it's currently limited to 256 colors.
-- The error codes are the also the same as those returned by /b save_bitmap.
--
-- Example:
--
--/code
--          -- save {0,0} {100,100} on the screen to a file
--          /copyToBitmapFile( Screen, "screen.bmp", 0, 0, 100, 100 )
--/endcode

global function copyToBitmapFile( integer id, sequence fileName,
    integer x1, integer y1,
    integer x2, integer y2 )

    integer index, cx, cy, colors, r, g, b, row, column
    atom hdc, lColor
    sequence image, scanline, lPalette

    -- get DC of the control
    hdc = getDC( id )

    -- empty palette
    lPalette = {}

    -- calculate width (cx) and height (cy) of the bitmap
    cx = x2 - x1 + 1
    cy = y2 - y1 + 1

    -- empty scanline of width cx
    scanline = repeat(0, cx)

    -- empty image of height cy
    image = repeat(scanline, cy)

    -- start at row 1
    row = 1

    -- scan a cx*cy image from the window
    for y = y1 to y2 do

        -- start at column 1
        column = 1

        -- scan the x column
        for x = x1 to x2 do

            -- get the pixel
            lColor = w32Func( xGetPixel, {hdc, x, y} )

            -- is it in the palette yet?
            index = find( lColor, lPalette )
            if index = 0 then

                -- save the atom in the pixel palette
                lPalette = append( lPalette, lColor )

                -- index the last palette entry
                index = length( lPalette )

            end if

            -- add the palette index to the scanline
            scanline[column] = index

            -- go to the next column
            column += 1

        end for

        -- add the scanline to the image
        image[row] = scanline

        -- go to the next row
        row += 1

    end for

    -- The indexes are zero-based
    image -= 1

    -- release the DC of the control
    releaseDC( id )

    -- the palette size MUST be 2, 16 or 256, or Euphoria
    -- will not save the file.
    if length( lPalette ) <= 2 then
    colors = 2
    elsif length( lPalette ) <= 16 then
    colors = 16
    elsif length( lPalette ) <= 256 then
    colors = 256
    else
    -- error
    return BMP_INVALID_MODE
    end if

    -- Convert palette to RGB triplets
    for i = 1 to length(lPalette) do
        lPalette[i] = split_rgb(lPalette[i])
    end for

    -- pad the palette, if needed
    if length( lPalette ) < colors then
        lPalette &= repeat({0,0,0}, colors - length( lPalette ))
    end if

    -- write the bitmap
    return save_bitmap( {lPalette, image}, fileName )

end function

-----------------------------------------------------------------------------
--/topic Graphics
--/func copyToTrueColorBitmapFile( window, fileName, x1, y1, x2, y2 )
--/desc Copies image from /i window to file /i fileName.
--/ret Returns 0 if succeeds.
--
-- /i x1 and /i y1 refer to the top left pixel corner of the image,
-- and /i x2 and /i y2 refer to the bottom right corner of the image.
--
-- /b "Note 1:" It uses /getPixel , so it's slow. /n
-- /b "Note 2:" It uses the full 24-bit color range (16+ million colors). /n
--
-- Example:
--
--/code
--          -- save {0,0} {100,100} on the screen to a file
--          /copyToTrueColorBitmapFile( Screen, "screen.bmp", 0, 0, 100, 100 )
--/endcode

-------------------------------
global function copyToTrueColorBitmapFile(integer id, sequence fileName, integer x1, integer y1, integer x2, integer y2)
-------------------------------
    integer fn, width, height, index, r, g, b
    atom hdc, rgb
    sequence line

    width = x2 - x1 + 1 -- calculate the width of the bitmap
    height = y2 - y1 + 1 -- calculate the height of the bitmap
    fn = w32FileOpen(fileName, "wb") -- open the file for writing
    if fn = -1 then return 1 end if -- unable to open? return 1

    line = repeat(0, floor(((24 * width) + 31)/32) * 4) -- create an empty line

    -- write the bitmap-header
    puts(fn, "BM")
    puts(fn, int_to_bytes(54 + height * length(line)))
    puts(fn, {0, 0, 0, 0, 54, 0, 0, 0, 40, 0, 0, 0})
    puts(fn, int_to_bytes(width))
    puts(fn, int_to_bytes(height))
    puts(fn, {1, 0, 24, 0, 0, 0, 0, 0, 0, 0, 0, 0, 64, 11, 0, 0, 64, 11, 0, 0, 0,
              0, 0, 0, 0, 0, 0, 0})

    hdc = getDC(id) -- get the device context
    for y = y2 to y1 by -1 do -- the bitmap has to be saved bottom to top
        index = 1
        for x = x1 to x2 do
            rgb = w32Func(xGetPixel,{hdc, x, y}) -- get the pixel
            r = and_bits( rgb, #FF ) -- calculate r (red)
            rgb = floor( rgb / #100 )
            g = and_bits( rgb, #FF ) -- calculate g (green)
            b = floor( rgb / #100 ) -- calculate b (blue)
            line[index] = b -- each pixel is 3 bytes, each element in line is 1 byte
            index += 1 -- the color of a pixel has to be saved as #BBGGRR instead of #RRGGBB
            line[index] = g
            index += 1
            line[index] = r
            index += 1
        end for
        puts(fn, line) -- write the current line to the file
    end for
    releaseDC(id) -- release the device context
    close(fn) -- close the file
    return 0 -- return 0 if successful
end function


-----------------------------------------------------------------------------

-----------------------------------------------------------------------------
-----------------------------------------------------------------------------
-- BitBlt Support Routines

-----------------------------------------------------------------------------
--/topic Graphics
--/proc bitBlt( dst, dstX, dstY, src, srcX, srcY, wide, high, rop )
--/desc Copy image (or partial image) from source to destination.
-- The /bitBlt function can be used to rapidly copy images, or
-- portions of images.
--
-- If you want to copy the entire source image with the /b SRCCOPY
-- /b ROP code, /copyBlt does the same thing, but requires less
-- arguments.
--
-- To copy images with transparency, use /transBlt.
--
-- The arguments are:
--
-- /li /i dst: Image destination
-- /li /i dstX: X position in destination
-- /li /i dstY: Y position in destination
-- /li /i src: Image source
-- /li /i srcX: X position in source
-- /li /i srcY: Y position in source
-- /li /i wide: Width of image to copy
-- /li /i high: Height of image to copy
-- /li /i rop: Raster opeartion (ROP) code to apply
--
-- The /b ROP (raster operation) specifies how to combine the source with
-- the destination. The codes are:
--
-- /li /b SrcCopy     dest = source
-- /li /b SrcPaint    dest = source OR dest
-- /li /b SrcAnd      dest = source AND dest
-- /li /b SrcInvert   dest = source XOR dest
-- /li /b SrcErase    dest = source AND (NOT dest)
-- /li /b NotSrcCopy  dest = (NOT source)
-- /li /b NotSrcErase dest = (NOT src) AND (NOT dest)
-- /li /b MergeCopy   dest = (source AND pattern)
-- /li /b MergePaint  dest = (NOT source) OR dest
-- /li /b PatCopy     dest = pattern
-- /li /b PatPaint    dest = dest OR (pattern OR (NOT source))
-- /li /b PatInvert   dest = pattern XOR dest
-- /li /b DstInvert   dest = (NOT dest)
-- /li /b Blackness   dest = BLACK
-- /li /b Whiteness   dest = WHITE
--
-- /b Note: The coordinates are relative to zero.
--
--/b Note: The destination and source can be the same control.
--
-- Example:
--/code
--          -- draw a bitmap in a window
--          atom hDIB
--
--          -- load the bitmap
--          hDib = /loadBitmapFromFile( "lizard.bmp" )
--
--          -- copy 40x40 portion of source image to destination
--          /bitBlt( TheWindow,  -- copy to TheWindow
--                  10, 10,     -- put at {10,10} in TheWindow
--                  hDIB,        -- copy from loaded bitmap
--                  0, 0        -- upper left hand corner is {0,0}
--                  40, 40,     -- copy a 40x40 pixel portion
--                  SRCCOPY )   -- replace destination with image
--/endcode

global procedure bitBlt( atom dst, integer dstX, integer dstY,
	        atom src, integer srcX, integer srcY,
	        integer wide, integer high,
	        integer rop )


    -- wrapper to bitblt

    -- copy portion of window into bitmap
    atom srcDC, dstDC

    -- get the DCs
    srcDC = getDC( src )
    dstDC = getDC( dst )


    -- copy area, ignoring any errors.
    VOID = w32Func( xBitBlt, {
	        dstDC, dstX, dstY,
	        wide, high,
	        srcDC,
	        srcX, srcY,
	        rop} )

    -- release the DCs
    releaseDC( dst )
    releaseDC( src )

end procedure

-----------------------------------------------------------------------------
--/topic Graphics
--/proc copyBlt( dst, dstX, dstY, src )
--/desc Copy full image from source to destination.
-- If you only want to copy a portion of the source or need to combine
-- the source and destination, use /bitBlt.
--
-- To copy images with transparency, use /transBlt.
--
-- The arguments are:
--
-- /li /i dst: Image destination
-- /li /i dstX: X position in destination
-- /li /i dstY: Y position in destination
-- /li /i src: Image source
--
--
-- /b Note: At the moment, the coordinates are zero relative; this will
--          be changed in later releases.
-- Example:
--/code
--          -- draw a bitmap in a window
--          atom hDIB
--
--          -- load the bitmap
--          hDib = /loadBitmapFromFile( "shuttle.bmp" )
--
--          -- copy the entire image to TheWindow
--          /copyBlt( TheWindow, 10, 10, hDib )
--/endcode

global procedure copyBlt( atom dst, integer x, integer y, atom src )

    -- copy entire destination to source
    sequence size

    -- get the size of the pixmap
    size = getCtlSize( src )

    -- bitblt with scrCopy
    bitBlt( dst, x, y, src, 0, 0, size[1], size[2], SRCCOPY )

end procedure



-----------------------------------------------------------------------------
--/topic Graphics
--/proc transBlt( dst, dstX, dstY, src )
--/desc Copy full image from source to destination, with transparency.
-- TransBlt is typically used for displaying non-rectangular bitmaps -
-- /i sprites. It is a computationally expensive operation; if there
-- is no transparency in your image, you should use /copyBlt or /bitBlt
-- instead.
--
-- By default, /transBlt assumes that the color {255,0,255} is to be
-- treated as transparent. To change the transparent color, use
-- /setTransparentColor.
--
-- The arguments are:
--
-- /li /i dst: Image destination
-- /li /i dstX: X position in destination
-- /li /i dstY: Y position in destination
-- /li /i src: Image source
--
-- /b Note: At the moment, the coordinates are zero relative; this will
--          be changed in later releases.
-- Example:
--/code
--          -- draw a bitmap using transparency
--          atom hDIB
--          sequence size
--
--          -- get the size of TheWindow
--          size = getCtlSize( TheWindow )
--
--          -- load the bitmap
--          hDib = /loadBitmapFromFile( "shuttle.bmp" )
--
--          -- treat the color BrightWhite as transparent
--          /setTransparentColor( BrightWhite )
--
--          -- copy multiple images to TheWindow
--          for i = 1 to 20 do
--              /transBlt( TheWindow,       -- destination
--                  rand( size[1] ),        -- x position
--                  rand( size[2] ),        -- y position
--                  hDib )                  -- image to copy
--          end for
--/endcode
global procedure transBlt( atom dest, integer destX, integer destY,
	        object src )

    integer
    wide,           -- width of the source bitmap
    high,            -- height of the source bitmap
    xoff, yoff

    atom
    srcBmp,         -- source bitmap
    destDC,         -- device context of destination
    srcDC,          -- source bitmap (color)
    saveDC,         -- backup copy of source bitmap
    maskDC,         -- mask bitmap (monochrome)
    invDC,          -- inverse of mask bitmap (monochrome)
    resultDC,       -- combination of source bitmap & background
    hResultBmp,     -- Bitmap combination of source & background
    hSaveBmp,       -- Bitmap stores backup copy of source bitmap
    hMaskBmp,       -- Bitmap stores mask (monochrome)
    hInvBmp,        -- Bitmap holds inverse of mask (monochrome)
    hSrcPrevBmp,    -- Holds previous bitmap in source DC
    hSavePrevBmp,   -- Holds previous bitmap in saved DC
    hDestPrevBmp,   -- Holds previous bitmap in destination DC
    hMaskPrevBmp,   -- Holds previous bitmap in the mask DC
    hInvPrevBmp,    -- Holds previous bitmap in inverted mask DC
    OrigColor       -- Holds original background color from source DC

    sequence
    size            -- holder for size of source

    -- is the source a bitmap, or a pixmap?
    if sequence(src) then
        xoff = src[2]
        yoff = src[3]
        wide = src[4]
        high = src[5]
        src = src[1]
    else
        wide = -1
        high = -1
        xoff = 0
        yoff = 0
    end if

    if not validId( src ) then
        -- assume it's a bitmap
        srcBmp = src

    elsif ctrl_Family[ src ] = PIXMAP then

        -- get the handle
        srcBmp = getHandle( src )

        -- release resources for it
        releaseResourcesForID( {src, ForPaint} )

    else
        -- no good
        warnErr( "Source to transBlt must be bitmap or Pixmap" )
        return

    end if

    if wide = -1 then
        -- get the size of the bitmap
        size = getCtlSize( srcBmp )

        -- get the values from the bitmap
        wide = size[1]
        high = size[2]
    end if
    -- get the DC of the destintation
    destDC = getDC( dest )

    -- create DCs to hold temporary information
    srcDC = w32Func( xCreateCompatibleDC, {destDC} )
    saveDC = w32Func( xCreateCompatibleDC, {destDC} )
    maskDC = w32Func( xCreateCompatibleDC, {destDC} )
    invDC = w32Func( xCreateCompatibleDC, {destDC} )
    resultDC = w32Func( xCreateCompatibleDC, {destDC} )

    -- Create monochrome bitmaps for the mask-related bitmaps:
    hMaskBmp = w32Func( xCreateBitmap, {wide, high, 1, 1, 0} )
    hInvBmp = w32Func( xCreateBitmap, {wide, high, 1, 1, 0} )

    -- Create color bitmaps for final result & stored copy of source
    hResultBmp = w32Func( xCreateCompatibleBitmap, {destDC, wide, high} )
    hSaveBmp = w32Func( xCreateCompatibleBitmap, {destDC, wide, high} )

    -- select the bitmaps into the DCs
    hSrcPrevBmp = w32Func( xSelectObject, {srcDC, srcBmp} )
    hSavePrevBmp = w32Func( xSelectObject, {saveDC, hSaveBmp} )
    hMaskPrevBmp = w32Func( xSelectObject, {maskDC, hMaskBmp} )
    hInvPrevBmp = w32Func( xSelectObject, {invDC, hInvBmp} )
    hDestPrevBmp = w32Func( xSelectObject, {resultDC, hResultBmp} )

    -- Make backup of source bitmap to restore later
    VOID = w32Func( xBitBlt, {saveDC, 0, 0, wide, high, srcDC, xoff, yoff, SRCCOPY} )

    -- Create mask: set background color of source to transparent color.
    OrigColor = w32Func( xSetBkColor, {srcDC, UseColor(transColor)} )
    VOID = w32Func( xBitBlt, {maskDC, 0, 0, wide, high, srcDC, xoff, yoff, SRCCOPY} )

    -- restore the original color
    VOID = w32Func( xSetBkColor, {srcDC, OrigColor} )

    -- Create inverse of mask to AND w/ source & combine w/ background.
    VOID = w32Func( xBitBlt, {invDC, 0, 0, wide, high, maskDC, 0, 0, NOTSRCCOPY} )

    -- Copy background bitmap to result & create final transparent bitmap
    VOID = w32Func( xBitBlt, {resultDC, 0, 0, wide, high, destDC, destX, destY, SRCCOPY} )

    -- AND mask bitmap w/ result DC to punch hole in the background by
    -- painting black area for non-transparent portion of source bitmap.
    VOID = w32Func( xBitBlt, {resultDC, 0, 0, wide, high, maskDC, 0, 0, SRCAND} )

    -- AND inverse mask w/ source bitmap to turn off bits associated
    -- with transparent area of source bitmap by making it black.
    VOID = w32Func( xBitBlt, {srcDC, xoff, yoff, wide, high, invDC, 0, 0, SRCAND} )

    -- XOR result w/ source bitmap to make background show through.
    VOID = w32Func( xBitBlt, {resultDC, 0, 0, wide, high, srcDC, xoff, yoff, SRCPAINT} )

    -- Display transparent bitmap on backgrnd
    VOID = w32Func( xBitBlt, {destDC, destX, destY, wide, high, resultDC, 0, 0, SRCCOPY} )

    -- Restore backup of bitmap.
    VOID = w32Func( xBitBlt, {srcDC, xoff, yoff, wide, high, saveDC, 0, 0, SRCCOPY} )

    -- select the original objects
    VOID = w32Func( xSelectObject, {srcDC, hSrcPrevBmp} )
    VOID = w32Func( xSelectObject, {saveDC, hSavePrevBmp} )
    VOID = w32Func( xSelectObject, {resultDC, hDestPrevBmp} )
    VOID = w32Func( xSelectObject, {maskDC, hMaskPrevBmp} )
    VOID = w32Func( xSelectObject, {invDC, hInvPrevBmp} )

    -- remove system resources
    VOID = w32Func( xDeleteObject, {hSaveBmp} )
    VOID = w32Func( xDeleteObject, {hMaskBmp} )
    VOID = w32Func( xDeleteObject, {hInvBmp} )
    VOID = w32Func( xDeleteObject, {hResultBmp} )
    VOID = w32Func( xDeleteDC, {srcDC} )
    VOID = w32Func( xDeleteDC, {saveDC} )
    VOID = w32Func( xDeleteDC, {invDC} )
    VOID = w32Func( xDeleteDC, {maskDC} )
    VOID = w32Func( xDeleteDC, {resultDC} )

    -- release the DC of the destintation
    releaseDC( dest )

end procedure


-----------------------------------------------------------------------------
--/topic Graphics
--/proc stretchBlt( dst, dstX, dstY, dstWide, dstHigh, src, srcX, srcY, srcWide, srcHigh, rop )
--/desc Copy image (or partial image) from source to destination, changing its size as you go.
-- This is used to resize an image and/or create mirror images. If the dstWide and dstHigh
-- parameters are negative, the image is also reflected in the X-axis and Y-axis
-- respectively.
--
--
-- The arguments are:
--
-- /li /i dst: Image destination
-- /li /i dstX: X position in destination
-- /li /i dstY: Y position in destination
-- /li /i dstWide: Width of resulting image
-- /li /i dstHigh: Height of resulting image
-- /li /i src: Image source
-- /li /i srcX: X position in source
-- /li /i srcY: Y position in source
-- /li /i srcWide: Width of image to copy
-- /li /i srcHigh: Height of image to copy
-- /li /i rop: Raster opeartion (ROP) code to apply
--
-- The /b ROP (raster operation) specifies how to combine the source with
-- the destination. The codes are:
--
-- /li /b SrcCopy     dest = source
-- /li /b SrcPaint    dest = source OR dest
-- /li /b SrcAnd      dest = source AND dest
-- /li /b SrcInvert   dest = source XOR dest
-- /li /b SrcErase    dest = source AND (NOT dest)
-- /li /b NotSrcCopy  dest = (NOT source)
-- /li /b NotSrcErase dest = (NOT src) AND (NOT dest)
-- /li /b MergeCopy   dest = (source AND pattern)
-- /li /b MergePaint  dest = (NOT source) OR dest
-- /li /b PatCopy     dest = pattern
-- /li /b PatPaint    dest = dest OR (pattern OR (NOT source))
-- /li /b PatInvert   dest = pattern XOR dest
-- /li /b DstInvert   dest = (NOT dest)
-- /li /b Blackness   dest = BLACK
-- /li /b Whiteness   dest = WHITE
--
-- /b Note: The coordinates are relative to zero.
--
--/b Note: The destination and source can be the same control.
--
-- Example:
--/code
--          -- draw a bitmap in a window
--          atom hDIB
--
--          -- load the bitmap
--          hDib = /loadBitmapFromFile( "lizard.bmp" )
--
--          -- copy 40x40 portion of source image to destination
--          /stretchBlt( TheWindow,  -- copy to TheWindow
--                  10, 10,     -- put at {10,10} in TheWindow
--                  100, 50,    -- cause it to be this size
--                  hDIB,       -- copy from loaded bitmap
--                  0, 0        -- upper left hand corner is {0,0}
--                  40, 40,     -- copy a 40x40 pixel portion
--                  SRCCOPY )   -- replace destination with image
--/endcode

global procedure stretchBlt(
            atom dst, integer dstX, integer dstY,
	        integer dstWide, integer dstHigh,
	        atom src, integer srcX, integer srcY,
	        integer srcWide, integer srcHigh,
	        integer rop )


    -- wrapper to bitblt

    -- copy portion of window into bitmap
    atom srcDC, dstDC

    -- get the DCs
    srcDC = getDC( src )
    dstDC = getDC( dst )


    -- copy area, ignoring any errors.
    VOID = w32Func( xStretchBlt, {
	        dstDC, dstX, dstY, dstWide, dstHigh,
	        srcDC, srcX, srcY, srcWide, srcHigh,
	        rop} )

    -- release the DCs
    releaseDC( dst )
    releaseDC( src )

end procedure


-----------------------------------------------------------------------------
--/topic Attributes
--/proc setRect( control, left, top, width, height, repaint )
--/desc Move and resize /i control.
--
-- /i control is moved to /i x, /i y, and sized to /i cx, /i cy. If the
-- /i repaint flag is set, the window is repainted.
--
-- To find the current size and position of /i control, use /getRect.
--
-- Example:
--
--/code
--          -- move Button1 to 20x20
--          sequence size
--
--          -- get the current size
--          size = /getCtlSize( Button1 )
--
--          -- change the size and repaint
--          /setRect( Button1, 20, 20, size[1], size[2], w32True )
--/endcode

global procedure setRect( integer id, object left, object top,
	    	    object width, object height, integer repaint )
    sequence BBox
    integer lError

    -- move the given window

    if ctrl_Type[id] = Pixmap then
        call_proc(r_setCtlSize,{id, width,height})
        return
    end if
    BBox = convPctToPixel(id, left, top, width, height)
    left  = BBox[1]
    top  = BBox[2]
    width = BBox[3]
    height = BBox[4]

    if not w32Func( xMoveWindow, {getHandle( id ), left, top, width, height, repaint} ) then
        lError = w32Func(xGetLastError,{})
        warnErr( sprintf("setRect:Repositioning Control failed. %d",lError) )
    end if

    if ctrl_Type[id] = Window then
        w32Proc( xUpdateWindow, { getHWND(id) } )
    end if

end procedure
r_setRect = routine_id("setRect")

-----------------------------------------------------------------------------
--/topic Attributes
--/proc setCtlSize( integer control, object Width, object Height )
--/desc Resizes /i control to /i Width and /i Height.
--
--If either /i Width or /i Height has the value /b w32SameSize then
-- the dimension is unchanged.
--
-- Example:
--
--/code
--     -- size Button1 to 60 pixels wide by 32 pixels high
--     /setCtlSize( Button1, 60, 32 )
--     -- size Button2 to 60 pixels wide, leaving the height unchanged.
--     /setCtlSize( Button2, 60, w32SameSize )
--     -- size Button3 to 25 pixels high, leaving the width unchanged.
--     /setCtlSize( Button3, w32SameSize, 25 )
--
--/endcode

global procedure setCtlSize( integer id, object pWidth, object pHeight )

    -- resize the given item
    integer x, y
    atom oldBmp, srcDC, dstDC
    sequence size, BBox, posn

    if validId(id) = w32False then
        return
    end if

    if equal(pWidth, w32SameSize) or equal(pHeight, w32SameSize) then
        size = getRect(id)
        if equal(pWidth, w32SameSize) then
            pWidth = size[3] - size[1]
        end if

        if equal(pHeight, w32SameSize) then
            pHeight = size[4] - size[2]
        end if
    end if

    if not integer(pWidth) or not integer(pHeight) then
        BBox = convPctToPixel(id, 0, 0, pWidth, pHeight)
        pWidth = BBox[3]
        pHeight = BBox[4]
    end if

    if ctrl_Family[ id ] = PIXMAP then

        -- get the bitmap, replace it with null
        oldBmp = ctrl_Handle[ id ]
        ctrl_Handle[ id ] = -1

        -- create a pixmap of the new size
        createPixmap( id, pWidth, pHeight )

        -- was there a prior bitmap?
        if oldBmp > 0 then

            -- is there a current bitmap to draw into?
            if ctrl_Handle[ id ] != 0 then

        	    -- get size of old bitmap
        	    size = getCtlSize( oldBmp )
        	    pWidth = size[1]
        	    pHeight = size[2]

        	    -- copy the old bitmap onto the new one
        	    bitBlt( ctrl_Handle[ id ], 0, 0,
        	    	    oldBmp, 0, 0, pWidth, pHeight, SRCCOPY )

            end if

            -- release the old bitmap
            deleteObject( oldBmp )

        end if

    else

        -- get the current location of the window
        posn = getPosition( id )
        x = posn[1]
        y = posn[2]

        -- normal window class, send MoveWindow to resize
        if not w32Func( xMoveWindow, {getHandle( id ), x, y, pWidth, pHeight, 1} ) then
            warnErr( "setCtlSize:MoveWindow failed." )
        end if

    end if


end procedure
r_setCtlSize = routine_id("setCtlSize")

--/topic Attributes
--/proc setCtlPosition( integer id, object x, object y )
--/desc Sets the location of the control.
--
--Example
--/code
--      setCtlPosition( myBtn, 100, 200)
--/endcode
global procedure setCtlPosition(integer id, object x, object y)
    sequence lRect

    lRect = getRect(id)
    setRect(id, x, y, lRect[3]-lRect[1], lRect[4]-lRect[2], 1)

end procedure

--/topic Attributes
--/proc setClientRect( integer id, object width, object height )
--/desc Sets the size of the client area in a window.
--The client area is the area used by the application. It excludes toolbar,
-- statusbar, menu area, etc... /n
--After using this routine, the window will be larger than the dimensions
-- specified here. Use /getRect() to retrive to total window area.
--
--Example
--/code
--       --Set the client area to exactly 300 by 200 pixels
--       setClientRect(myWindow, 300, 200)
--/endcode
------------------------------
global procedure setClientRect( integer id, object width, object height )
    sequence client, diff, BBox


    -- Only work with valid IDs
    if validId(id) = w32False then
        return
    end if

    if not integer(width) or not integer(height) then
        BBox = convPctToPixel(id, 0, 0, width, height)
        width  = BBox[3]
        height = BBox[4]
    end if

    -- get current client size

    client = getClientRect( id )

    -- get current window size and subtract client size
    diff = getCtlSize( id ) - (client[3 .. 4] - client[1 .. 2])

    -- add difference to specified window size
    setCtlSize( id, width + diff[1], height + diff[2] )

end procedure
r_setClientRect = routine_id("setClientRect")

--/topic Attributes
--/proc moveZOrder( integer id, atom ztype)
--/desc Move /i id to up or down the of Z order of windows.
--
--/i ztype can be one of HWND_TOP, HWND_BOTTOM, HWND_TOPMOST or
-- HWND_NOTOPMOST, or another control id.
--
-- Example:
--
--/code
--          -- change the order of this window.
--          moveZOrder( msgWindow,  HWND_TOPMOST)
--
--          -- move id in front of id2
--          moveZOrder( id,  id2)
--/endcode

global procedure moveZOrder( integer id , atom ztype)

    if not validId(id) then
        return
    end if

    if not find(ztype, {HWND_TOP,HWND_BOTTOM,HWND_TOPMOST,HWND_NOTOPMOST})
            and validId(ztype) then
         ztype = getHandle(ztype)
    end if

    VOID = w32Func(xSetWindowPos, {getHandle(id),
                ztype, 0, 0, 0, 0,
                SWP_NOSIZE + SWP_NOMOVE})

end procedure
r_moveZOrder = routine_id("moveZOrder")

--/topic Attributes
--/proc refreshWindow( object ids )
--/desc Forces the control(s) to be refreshed.
-- /i ids can be either a single control id or a sequence of ids.
--
--Example:
--/code
--      refreshWindow({btn1, btn2})
--/endcode
global procedure refreshWindow( object ids)

    if atom(ids) then
        ids = {ids}
    end if

    for i = 1 to length(ids) do
        if validId(ids[i]) then
            VOID = w32Func(xSetWindowPos, {getHandle(ids[i]),
	                        0, 0, 0, 0, 0,
	                        SWP_NOSIZE + SWP_NOMOVE + SWP_NOZORDER +
	                            SWP_DRAWFRAME + SWP_SHOWWINDOW})
        end if
    end for

end procedure

--/topic Attributes
--/proc distributeControls( sequence ids, integer disttype, object pValue)
--/desc Evenly distributes a set of controls.
--/i ids is the set of controls to distribute. There must be at least two ids
-- in the sequence. /n
--/i disttype is the type of distribution required. It can be one of... /n
--/li /b w32HorzCentre : The /i left edges are distributed evenly.
--/li /b w32HorzGap : The /i gap between right & left edges are equally.
--/li /b w32VertCentre : The /i top edges are distributed evenly.
--/li /b w32VertGap : The /i gap between bottom & top edges are equally.
--/i pValue is maximum distance that can span the controls. If this is 0
-- it is ignored. Otherwise it can be a pixel measurement, or a single control
-- id inside a sequence. See examples for details. If /i pValue is zero,
-- then the maximum distance is the largest distance between the controls in
-- /i ids.
--
--Examples
--/code
--      -- Move these fields such that the horizontal gap between
--      -- each is the same amount. In this case, fld1 and fld3 remain
--      -- still while fld2 is centered between them.
--      distributeControls( {fld1, fld2, fld3}, w32HorzGap, 0)
--
--      -- Move these fields such that the horizontal gap between
--      -- each is the same amount. In this case, only fld1 remains
--      -- still while fld2 and fld3 are moved such that the distance
--      -- between fld1 and fld3 is 200 pixels.
--      distributeControls( {fld1, fld2, fld3}, w32HorzGap, 200)
--
--      -- Move these fields such that the horizontal gap between
--      -- each is the same amount. In this case, only fld1 remains
--      -- still while fld2 and fld3 are moved such that the distance
--      -- between fld1 and fld3 is the width of fld4.
--      distributeControls( {fld1, fld2, fld3}, w32HorzGap, {fld4} )
--
--/endcode
global procedure distributeControls( sequence ids, integer disttype, object pValue)
    sequence lRect, lDim
    integer lHigh, lCur
    atom lIncr, lLastIncr, lLow

    -- Minimum of 2 ids.
    if length(ids) <= 1 then
        return
    end if

    -- Make space all the new locations
    lDim = repeat({0, 0, 0, 0}, length(ids))

    lRect = getRect(ids[1])
    if disttype = w32HorzCentre then
        -- left edges are evenly distributed
        lLow = lRect[1]
        lHigh = lRect[3]
        lDim[1][1] = lRect[1]
        lDim[1][2] = lRect[2]
        lDim[1][3] = lRect[3] - lRect[1]
        lDim[1][4] = lRect[4] - lRect[2]
        for i = 2 to length(ids) do
            lRect = getRect(ids[i])
            lDim[i][1] = lRect[1]
            lDim[i][2] = lRect[2]
            lDim[i][3] = lRect[3] - lRect[1]
            lDim[i][4] = lRect[4] - lRect[2]
            if lLow > lRect[1] then
        	    lLow = lRect[1]
            end if
            if lHigh < lRect[3] then
        	    lHigh = lRect[3]
            end if
        end for

        if sequence(pValue) then
            lRect = getRect(pValue[1])
            pValue = lRect[3] - lRect[1]
        end if
        if pValue != 0 then
            lHigh = lLow + pValue
        end if

        lHigh -= lDim[length(ids)][3]

        lIncr = (lHigh - lLow)

        lIncr /= (length(ids) - 1)
        for i = 1 to length(ids) do
            setRect(ids[i], floor(lLow), lDim[i][2], lDim[i][3], lDim[i][4], 0)
            lLow += lIncr
        end for

    elsif disttype = w32HorzGap then
        -- gap b/n right & left edges are equal
        lLow = lRect[1]
        lHigh = lRect[3]
        lCur = lRect[3] - lRect[1]
        for i = 2 to length(ids) do
            lRect = getRect(ids[i])
            if lLow > lRect[1] then
    	    lLow = lRect[1]
            end if
            if lHigh < lRect[1] + lRect[3] then
    	    lHigh = lRect[3]
            end if
            lCur += (lRect[3] - lRect[1])
        end for

        if sequence(pValue) then
            lRect = getRect(pValue[1])
            pValue = lRect[3] - lRect[1]
        end if

        if pValue != 0 then
            lIncr = pValue
        else
            lIncr = floor((lHigh - lLow - lCur) / (length(ids)-1) )
        end if

        for i = 1 to length(ids) do
            lRect = getRect(ids[i])
            setRect(ids[i], lLow, lRect[2],
    	            lRect[3] - lRect[1], lRect[4] - lRect[2], 0)
            lLow +=  (lRect[3] - lRect[1]) + lIncr
        end for

    elsif disttype = w32VertCentre then
        -- top edges are evenly distributed
        lLow = lRect[2]
        lHigh = lRect[4]
        lDim[1][1] = lRect[1]
        lDim[1][2] = lRect[2]
        lDim[1][3] = lRect[3] - lRect[1]
        lDim[1][4] = lRect[4] - lRect[2]
        for i = 2 to length(ids) do
            lRect = getRect(ids[i])
            lDim[i][1] = lRect[1]
            lDim[i][2] = lRect[2]
            lDim[i][3] = lRect[3] - lRect[1]
            lDim[i][4] = lRect[4] - lRect[2]
            if lLow > lRect[2] then
    	    lLow = lRect[2]
            end if
            if lHigh < lRect[4] then
    	    lHigh = lRect[4]
            end if
        end for

        if sequence(pValue) then
            lRect = getRect(pValue[1])
            pValue = lRect[4] - lRect[2]
        end if
        if pValue != 0 then
            lHigh = lLow + pValue
        end if

        lHigh -= lDim[length(ids)][4]

        lIncr = (lHigh - lLow)

        lIncr /= (length(ids) - 1)
        for i = 1 to length(ids) do
            setRect(ids[i], lDim[i][1], floor(lLow),  lDim[i][3], lDim[i][4],0)
            lLow += lIncr
        end for

    elsif disttype = w32VertGap then
        -- gap b/n bottom & top edges are equal
        lLow = lRect[2]
        lHigh = lRect[4]
        lCur = lRect[4] - lRect[2]
        for i = 2 to length(ids) do
            lRect = getRect(ids[i])
            if lLow > lRect[2] then
    	    lLow = lRect[2]
            end if
            if lHigh < lRect[4] then
    	    lHigh = lRect[4]
            end if
            lCur += (lRect[4] - lRect[2])
        end for

        if sequence(pValue) then
            lRect = getRect(pValue[1])
            pValue = lRect[4] - lRect[2]
        end if
        if pValue != 0 then
            lIncr = pValue
        else
            lIncr = floor((lHigh - lLow - lCur) / (length(ids) - 1))
        end if

        for i = 1 to length(ids) do
            lRect = getRect(ids[i])
            setRect(ids[i], lRect[1], lLow,
    	            lRect[3] - lRect[1], lRect[4] - lRect[2], 0)
            lLow +=  (lRect[4] - lRect[2]) + lIncr
        end for

    end if

    repaintWindow(0)

end procedure

--/topic Attributes
--/proc sizeControls( object ids, object disttype, object pValue)
--/desc Set the size for a set of controls.
--/i ids is a sequence of ids to change /n
--/i sizetype is one of, or a list of ... /n
--/li w32Height
--/li w32Width
--/li w32Widest
--/li w32Narrowest
--/li w32Tallest
--/li w32Shortest
--
--/i pValue, if used, is the minimum size. It can be a pixel value or an
-- id value in a sequence.
--
--Example /n
--/code
--      sizeControls({fld1,fld3,fld4,fld7}, w32Widest, 200)
--      sizeControls({fld2,fld0,fld9,fld5}, w32Tallest, {lblXYZ} )
--      -- fld3 and fld2 to the same dimensions as btnOne
--      sizeControls({fld3,fld2}, {w32Height,w32Width}, {btnOne} )
--/endcode
global procedure sizeControls( object ids, object pSizetype, object pValue )
    sequence lRect
    object lValue
    integer sizetype

    if atom(ids) then
        ids= {ids}
    end if
    if length(ids) = 0 then
    return
    end if

    if atom(pSizetype) then
        pSizetype = {pSizetype}
    end if
    lValue = pValue
    for k = 1 to length(pSizetype) do
        sizetype = pSizetype[k]
        pValue = lValue
        if sizetype = w32Width then
        -- all are set to the same width

        if sequence(pValue) then
            lRect = getRect(pValue[1])
            pValue = lRect[3] - lRect[1]
        end if
        for i = 1 to length(ids) do
            lRect = getRect(ids[i])
            setRect(ids[i], lRect[1], lRect[2], pValue, lRect[4] - lRect[2], 0)
        end for

        elsif sizetype = w32Height then
        -- all are set to the same height
        if sequence(pValue) then
            lRect = getRect(pValue[1])
            pValue = lRect[4] - lRect[2]
        end if
        for i = 1 to length(ids) do
            lRect = getRect(ids[i])
            setRect(ids[i], lRect[1], lRect[2], lRect[3] - lRect[1], pValue, 0)
        end for

        elsif sizetype = w32Widest then
        -- all are set to the widest width
        if sequence(pValue) then
            lRect = getRect(pValue[1])
        else
            lRect = getRect(ids[1])
        end if
        pValue = lRect[3] - lRect[1]
        for i = 1 to length(ids) do
            lRect = getRect(ids[i])
            if pValue < (lRect[3] - lRect[1]) then
    	    pValue = lRect[3] - lRect[1]
            end if
        end for

        sizeControls(ids, w32Width, pValue)

        elsif sizetype = w32Narrowest then
        -- all are set to the narrowest width
        if sequence(pValue) then
            lRect = getRect(pValue[1])
        else
            lRect = getRect(ids[1])
        end if
        pValue = lRect[3] - lRect[1]
        for i = 1 to length(ids) do
            lRect = getRect(ids[i])
            if pValue > (lRect[3] - lRect[1]) then
    	    pValue = lRect[3] - lRect[1]
            end if
        end for

        sizeControls(ids, w32Width, pValue)

        elsif sizetype = w32Tallest then
        -- all are set to the tallest height
        if sequence(pValue) then
            lRect = getRect(pValue[1])
        else
            lRect = getRect(ids[1])
        end if
        pValue = lRect[4] - lRect[2]
        for i = 1 to length(ids) do
            lRect = getRect(ids[i])
            if pValue < (lRect[4] - lRect[2]) then
    	    pValue = lRect[4] - lRect[2]
            end if
        end for

        sizeControls(ids, w32Height, pValue)

        elsif sizetype = w32Shortest then
        -- all are set to the shortest height.
        if sequence(pValue) then
            lRect = getRect(pValue[1])
        else
            lRect = getRect(ids[1])
        end if
        pValue = lRect[4] - lRect[2]
        for i = 1 to length(ids) do
            lRect = getRect(ids[i])
            if pValue > (lRect[4] - lRect[2]) then
    	    pValue = lRect[4] - lRect[2]
            end if
        end for

        sizeControls(ids, w32Height, pValue)

        end if
    end for

    repaintWindow(0)
end procedure

--/topic Attributes
--/proc alignControls( object ids, integer disttype, object pValue)
--/desc Set the edge position for a set of controls.
--/i ids is a sequence of ids to change /n
--/i disttype is one of, or a list of ... /n
--/li w32LeftEdge
--/li w32RightEdge
--/li w32TopEdge
--/li w32BottomEdge
--/li w32VertCentre
--/li w32HorzCentre
--/li w32LeftMost
--/li w32RightMost
--/li w32TopMost
--/li w32BottomMost
--
--/i pValue, if used with the ...Most options, is the minimum position. When
-- used with the other options it is the exact position to use.
--It can be a pixel value or an id value in a sequence.
--
--Example /n
--/code
--      -- Align them all to fld3's left edge.
--      alignControls({fld1,fld3,fld4,fld7}, w32LeftEdge, {fld3})
--
--      -- Move these up to whatever among them is the topmost fld.
--      alignControls({fld2,fld0,fld9,fld5}, w32TopMost, 0 )
--
--      -- Center fld9 with respect to the screen
--      alignControls(fld9, {w32VertCentre,w32HorzCentre}, {Screen} )
--/endcode

global procedure alignControls( object ids, object pAligntype, object pValue )

    sequence lRect
    integer lWidth, lHeight, lNewValue
    integer aligntype
    object lValue

    if atom(ids) then
        ids = {ids}
    end if
    if length(ids) = 0 then
        return
    end if
    if atom(pAligntype) then
        pAligntype = {pAligntype}
    end if

    lValue = pValue
    for k = 1 to length(pAligntype) do
        aligntype = pAligntype[k]
        pValue = lValue
        if aligntype = w32LeftEdge then
            if sequence(pValue) then
                lRect = getRect(pValue[1])
                pValue = lRect[1]
            end if
            for i = 1 to length(ids) do
                lRect = getRect(ids[i])
                lWidth = lRect[3] - lRect[1]
                lHeight = lRect[4] - lRect[2]
                setRect(ids[i], pValue, lRect[2], lWidth, lHeight, 0)
            end for

        elsif aligntype = w32RightEdge then
            if sequence(pValue) then
                lRect = getRect(pValue[1])
                pValue = lRect[3]
            end if
            for i = 1 to length(ids) do
                lRect = getRect(ids[i])
                lWidth = lRect[3] - lRect[1]
                lHeight = lRect[4] - lRect[2]
                lNewValue = pValue - lWidth
                setRect(ids[i], lNewValue, lRect[2], lWidth, lHeight, 0)
            end for

        elsif aligntype = w32TopEdge then
            if sequence(pValue) then
                lRect = getRect(pValue[1])
                pValue = lRect[2]
            end if
            for i = 1 to length(ids) do
                lRect = getRect(ids[i])
                lWidth = lRect[3] - lRect[1]
                lHeight = lRect[4] - lRect[2]
                setRect(ids[i], lRect[1], pValue, lWidth, lHeight, 0)
            end for

        elsif aligntype = w32BottomEdge then
            if sequence(pValue) then
                lRect = getRect(pValue[1])
                pValue = lRect[4]
            end if
            for i = 1 to length(ids) do
                lRect = getRect(ids[i])
                lWidth = lRect[3] - lRect[1]
                lHeight = lRect[4] - lRect[2]
                lNewValue = pValue - lHeight
                setRect(ids[i], lRect[1], lNewValue, lWidth, lHeight, 0)
            end for

        elsif aligntype = w32VertCentre then
            if sequence(pValue) then
                lRect = getRect(pValue[1])
                pValue = lRect[1] + floor((lRect[3] - lRect[1])/2)
            end if
            for i = 1 to length(ids) do
                lRect = getRect(ids[i])
                lWidth = lRect[3] - lRect[1]
                lHeight = lRect[4] - lRect[2]
                lNewValue = pValue - floor(lWidth/2)
                setRect(ids[i], lNewValue, lRect[2], lWidth, lHeight, 0)
            end for

        elsif aligntype = w32HorzCentre then
            if sequence(pValue) then
                lRect = getRect(pValue[1])
                pValue = lRect[2] + floor((lRect[4] - lRect[2])/2)
            end if
            for i = 1 to length(ids) do
                lRect = getRect(ids[i])
                lWidth = lRect[3] - lRect[1]
                lHeight = lRect[4] - lRect[2]
                lNewValue = pValue - floor(lHeight/2)
                setRect(ids[i], lRect[1], lNewValue, lWidth, lHeight, 0)
            end for

        elsif aligntype = w32Leftmost then
            lRect = getRect(ids[1])
            pValue = lRect[1]
            for i = 2 to length(ids) do
                lRect = getRect(ids[i])
                if pValue > lRect[1] then
        	    pValue = lRect[1]
                end if
            end for
            alignControls(ids, w32LeftEdge, pValue)

        elsif aligntype = w32Rightmost then
            lRect = getRect(ids[1])
            pValue = lRect[3]
            for i = 2 to length(ids) do
                lRect = getRect(ids[i])
                if pValue < lRect[3] then
        	    pValue = lRect[3]
                end if
            end for
            alignControls(ids, w32RightEdge, pValue)

        elsif aligntype = w32Topmost then
            lRect = getRect(ids[1])
            pValue = lRect[2]
            for i = 2 to length(ids) do
                lRect = getRect(ids[i])
                if pValue > lRect[2] then
        	    pValue = lRect[2]
                end if
            end for
            alignControls(ids, w32TopEdge, pValue)

        elsif aligntype = w32Bottommost then
            lRect = getRect(ids[1])
            pValue = lRect[4]
            for i = 2 to length(ids) do
                lRect = getRect(ids[i])
                if pValue < lRect[4] then
        	    pValue = lRect[4]
                end if
            end for
            alignControls(ids, w32BottomEdge, pValue)

        end if
    end for
    repaintWindow(0)
end procedure


-----------------------------------------------------------------------------
procedure pushModal( integer id, atom hWnd, integer style, integer depth )
    -- set window as modal

    -- Save any existing modal id
    modalStack = append(modalStack, {modalWindow, modalhWnd, modalStyle, modalDepth})

    -- set new modal window
    modalWindow = id
    modalhWnd = hWnd
    modalStyle = style
    modalDepth = depth

end procedure

-----------------------------------------------------------------------------
procedure popModal()
    -- remove modal flag
    -- if there was a prior modal window, unstack it

    integer pending

    pending = length( modalStack )

    -- need to unstack?
    if pending > 0 then
        -- get previous modal window
        modalWindow = modalStack[pending][1]
        modalhWnd   = modalStack[pending][2]
        modalStyle  = modalStack[pending][3]
        modalDepth  = modalStack[pending][4]
        -- unstack
        modalStack = modalStack[1 .. pending-1]
    else
        warnErr("popModal: The Modal Window Stack is already empty.")
    end if

end procedure


-- NEW! 0.45
-----------------------------------------------------------------------------
--/topic Attributes
--/proc popup( popupMenu, x, y )
--/desc Display popupMenu at { /i x, /i y }.
--The coordinates /i x and /i y are relative to the parent window
--of the popup menu. If you are trapping the mouse position relative
--some other control, you will need to pass both the id of the popup menu
--and the reference control for the coordiniates passed. This is done by
-- passing the first parameter as a 2-element sequence {popup, controlId}.
--
-- Example: Hard coded location relative to parent window.
--/code
--
--  -- create a popup for MyWindow
--  constant
--      MyPopup   = create( Popup, "", MyWindow, 0, 0, 0, 0, 0 )
--
--  -- add four items into it
--  constant
--      Item1     = create( MenuItem, "Item 1", MyPopup, 0, 0, 0, 0, 0 ),
--      Item2     = create( MenuItem, "Item 2", MyPopup, 0, 0, 0, 0, 0 ),
--      Item3     = create( MenuItem, "Item 3", MyPopup, 0, 0, 0, 0, 0 ),
--      Item4     = create( MenuItem, "Item 4", MyPopup, 0, 0, 0, 0, 0 )
--
--  -- popup the menu at {10,10} in MyWindow
--  popup( MyPopup, 10, 10 )
--
--/endcode
--
-- Example: Location relative to some other control.
--/code
--    --------------------------------
--    procedure Mouse_TV(integer self, integer event, sequence parms)
--    --------------------------------
--        integer index
--
--        if parms[1] = WM_RBUTTONDOWN then
--            -- The coordinates are relative to self and
--            -- not the parent window.
--            popup({TVPopup, self}, parms[2], parms[3] )
--        end if
--
--    end procedure
--
--/endcode


global procedure popup( object id, object x, object y )

    integer parent
    sequence pt, BBox
    atom result
    integer lPopupId
    integer lRelId

    if atom(id) then
        lPopupId = id
        lRelId = 0
    else
        lPopupId = id[1]
        lRelId = id[2]
    end if

    if validId(lPopupId) = w32False
      or find(ctrl_Type[ lPopupId ],{ Popup, Menu}) = 0
      or ((lRelId != 0) and (validId(lRelId) = w32False)) then
        return
    end if

    parent = findParentWindow(lPopupId)

    if lRelId != 0 and  parent != lRelId then
        -- Convert the mouse positions from Relative to the Treeview
        -- to relative to the screen.
        BBox = ClientToScreen(lRelId, x, y)

        -- Now convert them relative to the parent window.
        BBox = ScreenToClient(findParent(lRelId), BBox[1], BBox[2])

        x = BBox[1]
        y = BBox[2]

    end if

    -- get parent

    -- convert the point to a screen point
    pt = getClientPoint( parent, x, y )

    -- popup the menu
    result = w32Func( xTrackPopupMenu, { getHandle( lPopupId ),    -- menu
	    	        0,                  -- flags
	    	        pt[1], pt[2],       -- position
	    	        0,                  -- reserved, must be 0
	    	        getHandle( parent ), -- owner window
	    	        0 } )               -- pointer to rect
end procedure

-----------------------------------------------------------------------------
-- MOUSE
--
-----------------------------------------------------------------------------
--/topic Mouse
--/proc captureMouse( window )
--/desc Send all mouse events to /i window.
-- To release the mouse, use /releaseMouse.
--
-- Example:
--
--/code
--          -- grab the mouse for TheWindow
--          /captureMouse( TheWindow )
--/endcode


global procedure captureMouse( integer id )

    -- captures the mouse so all events are sent to that window

    -- capture the mouse
    if w32Func( xSetCapture, { getHandle( id ) } ) then
    warnErr( "captureMouse:SetCapture failed." )
    end if

end procedure


-----------------------------------------------------------------------------
--/topic Mouse
--/proc releaseMouse()
--/desc Return control of the mouse to Windows.
-- This is called after /captureMouse to put control of the mouse
-- back to normal.
--
-- Example:
--
--/code
--          -- release the mouse.
--          /releaseMouse()
--/endcode

global procedure releaseMouse()
    -- release the mouse from a /captureMouse
    w32Proc( xReleaseCapture, {} )
end procedure

-- NEW! 0.48e
-----------------------------------------------------------------------------
--/topic Attributes
--/func isScreenPointIn( control, x, y )
--/ret /b w32True if point { /i x, /i y } is within /i control.
--/desc Return /b w32True if the screen point { /i x, /i y } is within /i control.
-- This is used for hit testing, to determine if a point lies on a control.
--
-- Example:
--
--/code
--          -- check if screen point {10,10} lies in MyWindow
--          if /isScreenPointIn( MyWindow, 10, 10 ) then
--              -- point is in MyWindow
--          end if
--/endcode

global function isScreenPointIn( integer id, integer pX, integer pY )
    sequence lScreenRect

    if not validId(id) then
        return w32False
    end if

    lScreenRect = getRect(id)
    lScreenRect[3..4] -= lScreenRect[1..2]
    lScreenRect[1..2] = ClientToScreen( id, 0, 0)
    lScreenRect[3..4] += lScreenRect[1..2]-1

    if pX >= lScreenRect[3] or
       pX < lScreenRect[1] or
       pY >= lScreenRect[4] or
       pY < lScreenRect[2] then
        return w32False
    else
        return w32True
    end if

end function

-----------------------------------------------------------------------------
-- TIMERS
--
-----------------------------------------------------------------------------
--/topic Low Level Routines
--/proc setTimer( window, timer, ticks )
--/desc Start a timer ticking in /i window.
-- Timers are clocks that are maintained by Windows, and trigger events
-- at a user-specified interval, measured in milliseconds.
--
-- The arguments are:
-- /li /i window: /Window the timer belongs to.
-- /li /i timer: Unique ID assigned to the timer.
-- /li /i milliseconds: How much time, in milliseconds, that must pass
--              before triggering an /onTimer event.
--
-- To respond to timer events, use /onTime. You can have more than
-- one timer per /window. If your window is too busy to receive the
-- timer messages, they will be discarded.
--
-- Example:
--
--/code
--          -- start a timer with id #12 in MyWindow
--          -- it will trigger every 3 seconds.
--          /setTimer( MyWindow, 12, 3000 )
--/endcode

global procedure setTimer( integer id, integer timerId, atom ticks )

    -- set a timer to go off every ticks milliseconds
    w32Proc( xSetTimer, { getHandle( id ), timerId, ticks, 0 } )

end procedure

-----------------------------------------------------------------------------
--/topic Low Level Routines
--/proc killTimer( window, timer )
--/desc Stop a timer.
-- This deactivates /i timer that was set with /setTimer.
--
-- Example:
--
--/code
--          -- deactivate timer #12
--          /killTimer( MyWindow, 12 )
--/endcode

global procedure killTimer( integer id, integer timerId )

    -- remove timer from window
    w32Proc( xKillTimer, { getHandle( id ), timerId } )

end procedure

-----------------------------------------------------------------------------
-- CURSORS
--
-----------------------------------------------------------------------------

--/topic Mouse
--/proc restoreMousePointer( object id)
--/desc Gets back the previous pointer the mouse had before the last /setMousePointer call.
-- This restores the pointer shape for /i id by poping it from the /i id's stack. /n
-- /i id can either be a single control ID, or a sequence containing a control ID.
--You use the second form to restore the pointer for all the controls contained
-- in /i id.
--
-- Example:
--
--/code
--     -- Change mouse pointer in MyWindow to hourglass
--     /setMousePointer( {MyWindow}, WaitPointer )
--     -- Do some long job...
--     . . .
--     -- Restore the previous shape.
--     /restoreMousePointer( {MyWindow} )
--/endcode

global procedure restoreMousePointer( object id )
    sequence lKids

    if sequence(id) then
        lKids = findChildren(id[1])
        for i = 1 to length(lKids) do
            restoreMousePointer({lKids[i][1]})
        end for

        id = id[1]
    end if

    -- set pointer style
    if length(ctrl_Cursor[id]) > 1 then
        ctrl_Cursor[ id ] = ctrl_Cursor[ id ][2..length(ctrl_Cursor[id])]
    end if

    -- Force windows to show new shape right now!

    -- Really should try to find out which ID the mouse is currently over first,
    -- and uses its pointer shape.
    VOID = w32Func( xSetCursor, {ctrl_Cursor[ id ][1]} )
end procedure

--/topic Mouse
--/proc setMousePointer( object id, object pointer )
--/desc Set the pointer the mouse displays when in /i id.
-- This saves the current pointer for /i id by pushing it onto the /i id's stack
-- and sets the /i pointer as the new shape. You can get the previous pointer
-- shape by calling /restoreMousePointer().
--
-- /i id can either be a single control ID, or a sequence that contains a control
-- ID. You use the second form to set the pointer for all the controls contained
-- in /i id.
--
-- The initial mouse pointer displayed is the /i ArrowPointer, except
-- for /TextEdit and /MleText controls, which use the /i IBeamPointer.
--
-- The /i pointer can either be a system pointer, or one created with
-- the /createMousePointer function, or a path to .CUR or .ANI file.
--
-- System mouse pointers are:
-- /li /i ArrowPointer: Standard arrow
-- /li /i IBeamPointer: Text I-Beam
-- /li /i WaitPointer: Hourglass
-- /li /i CrossPointer: Crosshair
-- /li /i UpArrowPointer: Vertical arrow
-- /li /i SizeNWSEPointer: Double-pointed arrow pointing northwest and southeast
-- /li /i SizeNESWPointer: Double-pointed arrow pointing northeast and southwest
-- /li /i SizeWEPointer: Double-pointed arrow pointing west and east
-- /li /i SizeNSPointer: Double-pointed arrow pointing north and south
-- /li /i SizeAllPointer: Same as /i SizePointer
-- /li /i NoPointer: Slashed circle
-- /li /i AppStartingPointer: Standard arrow with small hourglass
-- /li /i IconPointer: Four-pointed arrow
-- /li /i Null: This is identical to calling /restoreMousePointer()
-- /li /i -1: This pops all pushed mouse shapes and restores the default one for /i id.
--
-- These system pointers can also be specified as a string value:
--li    "ARROW",
--li    "IBEAM",
--li    "WAIT" or "HOURGLASS",
--li    "CROSS",
--li    "UPARROW",
--li    "SIZENWSE",
--li    "SIZENESW",
--li    "SIZEWE",
--li    "SIZENS",
--li    "SIZEALL",
--li    "NO" or "NOT",
--li    "APPSTARTING",
--li    "ICON",
--li    "NULL",
--li    "DEFAULT"
-- Example:
--
--/code
--     -- Change mouse pointer in MyWindow and all its child controls to hourglass
--     /setMousePointer( {MyWindow}, WaitPointer )
--     -- Do some long job...
--     . . .
--     -- Restore the previous shape.
--     /restoreMousePointer( {MyWindow} )
--
--      /setMousePointer( ListPanel, "SpecialCursor.cur")
--      /setMousePointer( {WindowX}, "hourglass")
--/endcode

constant PointerValues = {
    ArrowPointer,
    IBeamPointer,
    WaitPointer,
    WaitPointer,
    CrossPointer,
    UpArrowPointer,
    SizeNWSEPointer,
    SizeNESWPointer,
    SizeWEPointer,
    SizeNSPointer,
    SizeAllPointer,
    NoPointer,
    NoPointer,
    AppStartingPointer,
    IconPointer,
    0,
    -1
    }
constant PointerNames = {
    "ARROW",
    "IBEAM",
    "WAIT",
    "HOURGLASS",
    "CROSS",
    "UPARROW",
    "SIZENWSE",
    "SIZENESW",
    "SIZEWE",
    "SIZENS",
    "SIZEALL",
    "NO",
    "NOT",
    "APPSTARTING",
    "ICON",
    "NULL",
    "DEFAULT"
    }
global procedure setMousePointer( object id, object style )

    -- load the cursor
    atom handle, point, result
    integer x, y
    sequence lKids

    if sequence(style) then
        result = find(upper(style), PointerNames)
        if result != 0 then
            style = PointerValues[result]
        else
            handle = w32Func(xLoadCursorFromFile, {style})
            if handle then
                trackCursor(handle)
                style = handle
            else
                warnErr(sprintf("setPointer: The cursor file '%s' didn't load.", {style}))
                return
            end if
        end if
    end if

    if equal(style, 0)  then
        restoreMousePointer(id)
        return
    end if


    if not equal(style, -1) then
        if find( style, heldCursor ) then
            -- don't need to load. either null or user defined
            handle = style
        elsif find( {style}, heldCursor ) then
            -- don't need to load. either null or user defined
            handle = style
        else
            -- load system cursor
            handle = w32Func( xLoadCursor, { NULL, style } )
            if handle = NULL then
                -- warning
                warnErr( "setPointer:LoadCursor failed." )
            else
                trackCursor({handle})
            end if
        end if
    else
        handle = -1
    end if

    -- set pointer style
    if sequence(id) then
        lKids = findChildren(id[1])
        for i = 1 to length(lKids) do
            setMousePointer({lKids[i][1]}, handle)
        end for
        id = id[1]
    end if

    if equal(style, -1) then
        ctrl_Cursor[id] = {ctrl_Cursor[id][length(ctrl_Cursor[id])]}
    else
        ctrl_Cursor[ id ] = prepend(ctrl_Cursor[ id ], handle)
    end if

    -- Force windows to show new shape right now!
    VOID = w32Func( xSetCursor, {ctrl_Cursor[ id ][1]} )

end procedure
r_setMousePointer = routine_id("setMousePointer")

--/topic Mouse
--/proc setDragPointer( object style)
--/desc Sets the mouse pointer shape to use when dragging.
-- Win32lib supports four cursor shapes for dragging. /n
-- /i style can be either an atom (handle) or a sequence of four handles. If it is an
-- atom then set all four drag pointers to the same value. /n
-- The sequence represents these shapes: /n
--<ul>
--/li [1] - Used when no keys pressed
--/li [2] - Used when the shift key is pressed
--/li [3] - Used when the control key is pressed
--/li [4] - Used when the Alt key is pressed.
--</ul>
-- If /i style is a sequence, if any element is /b 0 then the current value
-- for this position is not changed.
--
-- Initially all shapes are set to the CrossPointer.
--
-- /i Handles can be either one of the predefined system shapes, one created by
-- /createMousePointer() or one returned by /loadCursor().
--
-- Example:
--
--/code
--      setDragPointer( IconPointer )
--
--      setDragPointer( {IconPointer, -- set the 'normal' shape
--                       0  -- leave exsting 'Shift' shape alone
--                       loadCursor(mycursor), -- load 'Ctrl' shape from a file.
--                    } )
--
--/endcode

global procedure setDragPointer( object style )
    if atom(style) then
        style = repeat(style, 4)
    end if

    for i = 1 to length(style) do
        if i > 4 then
            exit
        end if
        if style[i] != 0 then
            vDragPointer[i] = style[i]
        end if
    end for

end procedure


procedure IndicateDragging(integer id, integer flag )
    atom lPointerType


    if flag then
        lPointerType = call_func(r_getKeyMasks,{0})
        if and_bits(lPointerType, ShiftMask) then
            lPointerType = 2
        elsif and_bits(lPointerType, ControlMask) then
            lPointerType = 3
        elsif and_bits(lPointerType, AltMask) then
            lPointerType = 4
        else
            lPointerType = 1
        end if
        -- Set the pointer shape for each possible control
        -- that can receive dragged data
        for i = 1 to length(ctrl_Handlers) do
            if (atom(ctrl_Handlers[i])
                  or atom(ctrl_Handlers[i][w32HDragAndDrop])
                   or length(ctrl_Handlers[i][w32HDragAndDrop]) > 0)
               and ctrl_Destroyed[i] = 0 then
                setMousePointer( i, vDragPointer[lPointerType] )
            end if
        end for
    else
        -- Restore the pointer shape for each possible control
        -- that can receive dragged data
        for i = 1 to length(ctrl_Handlers) do
            if (atom(ctrl_Handlers[i])
                  or atom(ctrl_Handlers[i][w32HDragAndDrop])
                   or length(ctrl_Handlers[i][w32HDragAndDrop]) > 0)
               and ctrl_Destroyed[i] = 0 then
                restoreMousePointer( i)
            end if
        end for

    end if


end procedure

-----------------------------------------------------------------------------
--/topic Mouse
--/proc createMousePointer( hotspotX, hotspotY, image )
--/desc Create a new mouse pointer.
-- The /i hotspotX and /i hotspotY values are the "hotspot". The image is
-- a 2x2 text sequence of the pointer. Bytes are interpreted as follows:
--
--~s~s  /ff<' '> = transparent /n
--~s~s  /ff<'.'> = solid white /n
--~s~s  /ff<'x'> = solid black /n
--
-- Example:
--
--/code
--      constant PlusPointer = /createMousePointer( 8, 8, {
--          "     xxxxxx      ",
--          "     x....xx     ",
--          "     x....xx     ",
--          "     x....xx     ",
--          "     x....xx     ",
--          "xxxxxx....xxxxxx ",
--          "x..............xx",
--          "x..............xx",
--          "x..............xx",
--          "x..............xx",
--          "xxxxxx....xxxxxxx",
--          " xxxxx....xxxxxxx",
--          "     x....xx     ",
--          "     x....xx     ",
--          "     x....xx     ",
--          "     xxxxxxx     ",
--          "      xxxxxx     "} )
--
--          -- set as pointer for MyWindow
--          /setMousePointer( MyWindow, PlusPointer )
--
--/endcode

global function createMousePointer( integer x, integer y, sequence image )

    -- load the cursor
    integer cx, cy, diff
    atom andPlane, xorPlane, hCursor, mset
    sequence data, maskBits

    mset = w32new_memset()
    -- get the metrics for the cursor
    cx = w32Func( xGetSystemMetrics, { SM_CXCURSOR } )
    cy = w32Func( xGetSystemMetrics, { SM_CYCURSOR } )

    -- ensure image is wide enough
    diff = cx - length( image[1] )
    for i = 1 to length( image ) do

        -- add padding...
        image[i] &= repeat( ' ', cx )

        -- trim
        image[i] = image[i][1..cx]

    end for

    -- ensure the image is tall enough
    for i = 1 to cy do
        -- add extra padding
        image = append( image, repeat( ' ', cx ) )
    end for
    -- trim
    image = image[1..cy]

    -- create the and mask
    maskBits = ( image = ' ' )

    -- convert the bits to bytes
    data = {}
    for i = 1 to length( maskBits ) do
        data = data & codeToBytes( maskBits[i] )
    end for

    -- Allocate and poke the and plane data
    andPlane = w32acquire_mem(mset, length( data ) )
    poke( andPlane, data )

    -- create the xor mask
    maskBits = (image = '.')

    -- convert the bits to bytes
    data = {}
    for i = 1 to length( maskBits ) do
        data = data & codeToBytes( maskBits[i] )
    end for

    -- Allocate and poke the xor plane data
    xorPlane = w32acquire_mem( mset, length( data ) )
    poke( xorPlane, data )

    -- create the cursor
    hCursor = w32Func( xCreateCursor,
	        { instance(),       -- application instance
	          x, y,             -- x and y of hotspot
	          length( image ),    -- cursor width
	          length( image[1] ), -- cursor height
	          andPlane,
	          xorPlane } )

    -- keep track of cursor
    trackCursor( hCursor )

    -- Free the data
    w32release_mem( mset)

    return hCursor

end function




-- NEW! 0.45k
-----------------------------------------------------------------------------
--/topic Dialogs
--/func getColorDialog( window, default color )
--/desc "Get Color" Dialog
--/ret Selected color, or default color if nothing selected.
-- Calling this function brings up the modal "Select Color" dialog, allowing
-- the user to select a color from the default color list, or add a color to
-- the custom color list.
--
-- The parameter passed in /b default /b color is an atom representing the
-- default color to select, in #RRGGBB format. Passing -1 specifies that
-- the color black (#000000) is the default color.
--
--
-- Example:
--
--/code
--          -- get a color; red ( #FF0000 ) is the default
--          atom color
--          color = getColorDialog( Window, #FF0000 )
--/endcode


atom customColors
    customColors = w32acquire_mem(0, 64)

for i=0 to 63 do
    poke(customColors+i,#FF)
end for

global function getColorDialog(atom id, object defaultColor )

    atom mem, result, color

    -- Allocate memory for the dialog
    mem = w32acquire_mem(0, SIZEOF_COLORDLG )

    -- set up
    w32store( mem, COLORDLG_lStructSize, SIZEOF_COLORDLG )
    w32store( mem, COLORDLG_hwndOwner, getHandle(id) )
    w32store( mem, COLORDLG_lpCustColors, customColors )

    -- default color
    w32store( mem, COLORDLG_Flags, CC_RGBINIT )
    w32store( mem, COLORDLG_rgbResult, colorValue(defaultColor) )

    -- call the routine
    result = w32Func(xColorDlg, {mem})
    if result then
        -- fetch the color
        color = w32fetch( mem, COLORDLG_rgbResult )
    else
        -- cancelled
        color = colorValue(defaultColor)
    end if

    -- release the buffer
    w32release_mem( mem )

    return color

end function


-----------------------------------------------------------------------------
--/topic Dialogs
--/func getFontDialog( window )
--/desc "Get Font" Dialog
--/ret { font name, points, style flags, color } or -1 if cancelled.
-- Calling this function brings up the modal "Select Font" dialog, allowing
-- the user to select a font from the list of available fonts.
--
-- Example:
--
--/code
--          integer flags, points
--          atom color
--          sequence font
--          object result
--
--          -- get a font choice from the user
--          result = getFontDialog( MyWindow )
--          if sequence( result ) then
--              -- get the values
--              font = result[1]
--              points = result[2]
--              flags  = result[3]
--              color  = result[4]
--          end if
--/endcode

global function getFontDialog( integer id )

    integer points, attrib
    sequence  font
    atom hChooseFont, hLogFont, color, mset
    object result
    integer owner

    -- assume failure
    result = -1
    owner = findParentWindow(id)
    -- create structures
    mset = w32new_memset()
    hChooseFont = w32acquire_mem(mset, SIZEOF_CHOOSEFONT)
    hLogFont = w32acquire_mem(mset, SIZEOF_LOGFONT)

    -- populate the choose font structure
    w32store( hLogFont, lfFaceName, ctrl_Font[id][FontName])
    if sequence(ctrl_Font[id][FontSize]) then
        w32store( hLogFont, lfHeight, ctrl_Font[id][FontSize][1] )
    else
        w32store( hLogFont, lfHeight, -(100 * ctrl_Font[id][FontSize])/72)
    end if

    w32store( hChooseFont, CF_lStructSize, SIZEOF_CHOOSEFONT )
    w32store( hChooseFont, CF_hwndOwner, getHandle( owner ) )
    w32store( hChooseFont, CF_Flags, CF_INITTOLOGFONTSTRUCT+CF_SCRIPTSONLY+CF_SCREENFONTS+CF_EFFECTS )
    w32store( hChooseFont, CF_hLogFont, hLogFont )

    -- call the dialog
    if w32Func( xChooseFont,{ hChooseFont } ) then

    -- pointer to structure good?
    if w32fetch( hChooseFont, CF_hLogFont ) then

        -- got pointer successfully
        font = w32peek_string( w32address( hLogFont, lfFaceName ) )
        points = floor( w32fetch( hChooseFont, CF_iPointSize ) / 10 )

        -- clear attributes
        attrib = 0

-- NEW! 0.45o check correct flag
        -- bold?
        if w32fetch( hLogFont, lfWeight ) >= vFontWeight then
	    attrib += Bold
        end if

        -- italic?
        if w32fetch( hLogFont, lfItalic ) then
	    attrib += Italic
        end if

        -- underline?
        if w32fetch( hLogFont, lfUnderline ) then
	    attrib += Underline
        end if

        -- strikeout?
        if w32fetch( hLogFont, lfStrikeOut ) then
	    attrib += Strikeout
        end if

        --get font color
        color = w32fetch( hChooseFont, CF_rgbColors )

        -- save result
        result = { font, points, attrib, color }

    end if

    end if

    -- Free the structures
    w32release_mem(mset)

    return result


end function

--/topic Attributes
--/func setTabStops(integer id, sequence flds)
--/desc This establishes the controls in a containing control that get tabbing focus.
--/ret SEQUENCE: The list of controls that used to be the tabbing controls.
--/i id is the Id of a control that contains other controls. Usually a Window,
-- Group, or TabItem. /n
-- The /i flds parameter specifies a list of control ids. The order of the ids
-- is the new order of tabbing. Any control that is /b not in this list is
-- ignored by the tabbing process.
--
--Example:
--/code
--      sequence OldFlds
--      OldFlds = setTabStops(MainWin, {CustName, CustAddr, Telephone,
--                                     OKBtn, CancelBtn})
--/endcode
global function setTabStops(integer id, sequence flds)
    sequence lOldTabs

    if validId(id) = 0 then
        return {}
    end if
    lOldTabs = ctrl_Focus_order[ id ]

    ctrl_Focus_order[ id ] = flds

    return lOldTabs
end function

--/topic Controls
--/proc tab_direction(integer id, integer direction )
--/desc Moves focus ahead or back to next available focus item
--/i id is the control that is your reference point. /n
--/i direction is the number of items to 'tab' over to. Negative values
-- move backward while postive values move forward.
--
--Example:
--/code
--      -- Tab forward to the next item that can take focus.
--      tab_direction(Fld1, 1)
--/endcode
global procedure tab_direction( integer id, integer direction )

    -- tabs ahead or back to next available focus item
    -- if nothing is found, doesn't focus on anything

integer parent, focus, at
sequence tabs


    -- is the id a window?
   if isTopLevelWindow(id) or find(ctrl_Type[id],{ TabItem}) then
        -- parent is self
        parent = id

    elsif ctrl_Family[ctrl_Parent[id]] = COMBO  then

        -- This is a subclassed control, so use the parent (combo) as reference.

        id = ctrl_Parent[id]
        parent = ctrl_Parent[ id ]

    else
        -- parent is container
        parent = ctrl_Parent[ id ]

    end if

    -- get the parent's list of tabstop controls
    tabs = ctrl_Focus_order[ parent ]
    id = ctrl_Current_focus[parent]

    -- get the index of the item with focus
    at = find( id, tabs)
    if at = 0 then
        at = 1
    end if

    -- look through all the tab stops
    for i = 1 to length( tabs ) do

        -- move in correct direction
        at += direction

        -- wrap?
        if at > length( tabs ) then
            at = 1
        elsif at < 1 then
            at = length( tabs )
        end if

        -- get proposed focus
        focus = tabs[at]

        -- can it take focus?
        if validId( focus ) and
           isEnabled( focus ) and
           isVisible( focus ) then

            -- tab direction
            if ctrl_Type[focus] = TabItem then
                call_proc(r_setFocus,{focus})
            else
                w32Proc( xSetFocus, { getHandle( focus ) } )
            end if
            ctrl_Current_focus[parent] = focus
            -- leave
            return

        elsif direction = 0 then
            direction = 1
        end if

    end for

end procedure

-- NEW! 0.54.5
sequence vTabKeyCodes
vTabKeyCodes =  {VK_TAB}

----------------------------------------------------------------------------
global function setTabCodes( object newcodes)

    sequence oldcodes

    oldcodes = vTabKeyCodes

    if    atom(newcodes)
      and newcodes >= 0
    then
    vTabKeyCodes = {newcodes}

    elsif sequence(newcodes)
      and length(newcodes) > 0
    then
    vTabKeyCodes = newcodes
    end if

    return oldcodes
end function

--DEBUG NEEDS DOCUMENTING
----------------------------------------------------------------------------
global function setTabEnabled( integer id, integer flag)
    integer oldflag

    if validId(id) then
        oldflag = ctrl_TabKey_Used[id]

        ctrl_TabKey_Used[id] = w32iff(flag != 0, 1, 0)
    else
        oldflag = -1
    end if

    return oldflag

end function

----------------------------------------------------------------------------
function isTabKey( integer id, atom key)

    -- returns true if it's a tab key
    -- MleText requires the Ctrl key be pressed as well

atom result
integer tabdir

    -- key event and tab?

    tabdir = 0
    if  find(key, vTabKeyCodes) then
        -- Is raw tab key allowed for this control?
        if ctrl_TabKey_Used[ id ] = w32False then
            -- only respond if CTRL key is pressed as well
            result = call_func(r_getKeyState,{VK_CONTROL})
            tabdir = w32iff(result != 0, 1, 0)
        else
            -- it's a tab
            tabdir = 1
        end if

        if tabdir != 0 then
             -- Check for shift key, to reverse tabbing direction.
            result = call_func(r_getKeyState,{VK_SHIFT})
            if result != 0 then
    	        tabdir = - tabdir
            end if
        end if
    end if

    return tabdir

end function

--/topic Values
--/func getTabItem(integer id)
--/desc Used to get the current tabitem selected in a tabcontrol
--/ret The control ID of the current tabitem or 0
global function getTabItem(integer id)
    integer tabitem

    if validId(id) = 0
    or ctrl_Type[id] != TabControl then
        return 0
    end if

    tabitem = 1 + w32Func( xSendMessage, {getHandle(id),TCM_GETCURSEL,0,0})
    if tabitem > 0 and tabitem <= length(ctrl_Tabitems[id]) then
        tabitem = ctrl_Tabitems[id][tabitem]
    end if

    return tabitem
end function


-----------------------------------------------------------------------------
procedure activateTabItems( integer id )

    -- when a tab is activated, all the items that are
    -- associated with that tab are made visible.

    integer parent
    sequence incgroup, show, hide , alltabitems
    integer curp, groupsize, tabitem

    -- get the parent of the tab
    parent = ctrl_Parent[ id ]
    ctrl_Current_focus[parent] = id
    --repaintWindow(parent)
    --call_proc(r_doEvents,{0})
    -- get the set of items to hide in the tab
    groupsize = 0
    hide = {}
    -- Examine each tabitem in this tabcontrol
    alltabitems = ctrl_Group[ parent ]
    for j = 1 to length(alltabitems) do
        tabitem = alltabitems[j]

        -- Hide only the items in the tabs that are not selected.
        if tabitem != id then
            hide &= ctrl_Group[ tabitem ]

            -- Loop through to included and "grand-children" items
            while groupsize != length(hide) do
        	    -- Point to next starting position
        	    curp = groupsize + 1
        	    groupsize = length(hide)
        	    incgroup = {}
        	    for i = curp to length(hide) do
        	        incgroup &= ctrl_Group[hide[i]]
        	    end for

        	    hide &= incgroup
            end while
        end if
    end for

    -- get the set of items to show in the tab
    groupsize = 0
    show = ctrl_Group[ id ]
    while groupsize != length(show) do
        curp = groupsize + 1
        groupsize = length(show)
        incgroup = {}
        for i = curp to length(show) do
            -- Don't add in child tabcontrols as these
            -- are taken care of later on.
            if ctrl_Type[show[i]] != TabControl then
    	       incgroup &= ctrl_Group[show[i]]
            end if
        end for

        show &= incgroup
    end while

    -- Hide all the deselected items
    for i = 1 to length(hide) do
        setVisible(hide[i], w32False)
    end for

    -- Show all the selected items
    for i = 1 to length(show) do
        setVisible(show[i], w32True)

        -- Tabcontrol items must only show their current tabitem.
        if ctrl_Type[show[i]] = TabControl then
            tabitem = getTabItem( show[i] )
            activateTabItems(tabitem)
        end if
    end for


end procedure
r_activateTabItems = routine_id("activateTabItems")

-----------------------------------------------------------------------------
--/topic Attributes
--/proc setFocus( id )
--/desc Set the focus to the specified window or control.
-- This will cause the window or control that currently has focus
-- to lose it.
--
-- The window or control losing focus will get an /onLostFocus event,
-- and the window or control that is getting focus will get an /onGotFocus
-- event.
--
-- Controls that are not visible or not enabled, will never receive focus.
-- If you try to, nothing will actually happen.

global procedure setFocus( object id )

    -- set the focus
    atom parent, item , hWnd, subitem

    if sequence(id) then
        item = id[2]
        id = id[1]
    else
        item = -1
    end if

    if  not isEnabled( id )
       or
       not isVisible( id ) then
        return  -- Either can't see it, or shouldn't touch it.
    end if

    if ctrl_Type[id] = TabItem then

        parent = ctrl_Parent[id]
        item = find(id, ctrl_Tabitems[parent]) - 1
        VOID = sendMessage( parent, TCM_SETCURSEL, item, 0)
        activateTabItems( id )
        return
    end if

    focus_current = id

    hWnd = getHandle(id)
    w32Proc( xSetFocus, {hWnd} )

    if item > 0 then
        if ctrl_Type[id] = TreeView then
            subitem = tvitem_handle[item]
            VOID = w32Func( xSendMessage, {hWnd, TVM_SELECTITEM, TVGN_FIRSTVISIBLE, subitem})
            VOID = w32Func( xSendMessage, {hWnd, TVM_SELECTITEM, TVGN_CARET, subitem})

        elsif ctrl_Type[id] = ListView then
            subitem = item - 1
            VOID = w32Func( xSendMessage, {hWnd, LVM_SETHOTITEM, subitem,0})
            VOID = w32Func( xSendMessage, {hWnd, LVM_ENSUREVISIBLE, subitem,0})
            setLVItem(id, LVIF_STATE, item, 0, or_bits(LVIS_SELECTED,LVIS_FOCUSED),
                            or_bits(LVIS_SELECTED,LVIS_FOCUSED), 0, 0, 0)

        end if
    end if
end procedure
r_setFocus = routine_id("setFocus")

--/topic Attributes
--/func getFocus( )
--/desc Gets the id of the control that has focus.
--/ret INTEGER: The id of the control that has focus.
global function getFocus( )
    return getId(w32Func( xGetFocus, {} ))
end function


-----------------------------------------------------------------------------
-- NEW! 0.45a
-- Allow user to select tooltip font
integer
    hintFontSize,
    hintFontAttrib
sequence
    hintFontName


-- set defaults
    hintFontName   = "MS Sans Serif"
    hintFontSize   = 8
    hintFontAttrib = Normal


-- NEW! 0.45a
-----------------------------------------------------------------------------
--/topic Fonts
--/proc setHintFont( font, point size, attributes )
--/desc Set font type and size for the control's hints.
--
-- Default values are { "MS Sans Serif", 8 points, Normal }.
--
-- Example:
--
--/code
--   /setHintFont( "Times New Roman", 10, /Bold)
--/endcode
-- You can also call /setFont( /i tooltipControl )

global procedure setHintFont( sequence fontName, integer points, integer attrib )

    setFont( tooltipControl, fontName, points, attrib )

end procedure


-- NEW! 0.45b

-----------------------------------------------------------------------------
--/topic Mouse
--/func getPointerRelPos(integer id)
--/desc Retrieves relative position of the mouse.
--/ret SEQUENCE: Mouse {x,y} position, relative to the control specified by /i id.
--
-- Example:
--
--/code
-- sequence pos
--
--  pos = getPointerRelPos(myWindow)
--  if pos[1] > 200 then
--      -- code goes here...
--  end if
--/endcode

global function getPointerRelPos(integer pId)

    if validId(pId) then
        return getPointerPos() - ClientToScreen(pId, 0, 0)
    else
        return {0,0}
    end if

end function
r_getPointerRelPos =  routine_id("getPointerRelPos")
sequence vControlSets vControlSets = {}
object vCurrentControlSet vCurrentControlSet = "not set"

--/topic Controls
--/proc showControlSet(integer id)
--/desc Makes visible all the controls in the identified set, and hides the previously shown set.
--
--/i id is the id of a ControlSet created by /setControlSet
--
--Example:
--/code
--      sequence FuncGroup
--      sequence TriggerGroup
--      constant CustomerGrp=1, OrderGrp=2, InventGrp=5, AdminGrp=7
--
--      setControlSet(CustomerGrp, w32True, {Fld1, Fld2, Fld3})
--      setControlSet(OrderGrp, w32True, {Fld11, Fld12, Fld13, Fld14})
--      setControlSet(InventGrp, w32True, {Fld21, Fld22})
--      setControlSet(AdminGrp, w32True, {Fld31, Fld32, Fld33})
--      TriggerGroup = {Btn1,        Btn2,     Btn3,      Btn4}
--      FuncGroup    = {CustomerGrp, OrderGrp, InventGrp, AdminGrp}
--
--      procedure Click_Buttons(integer self, integer event, sequence parms)
--          showControlSet( FuncGroup[ find(self, TriggerGroup) ] )
--      end procedure
--      setHandler(TriggerGroup, w32HClick, routine_id("Click_Buttons"))
--/endcode
global procedure showControlSet(integer id)
    if not equal(id, vCurrentControlSet) and
       id > 0 and
       id <= length(vControlSets) then
        setVisible(vControlSets[id], w32True)
        if integer(vCurrentControlSet) then
            setVisible(vControlSets[vCurrentControlSet], w32False)
        end if
        vCurrentControlSet = id
    end if
end procedure

--/topic Controls
--/proc hideControlSet(object set)
--/desc Hides all the controls in the identified set(s).
--/i set is either a single ControlSet id, or a list of ControlSet ids.
--
--If /i set is zero, then all known ControlSets are hidden.
--
--Example:
--/code
--      -- Hide all sets
--      hideControlSet(0)
--      -- Hide one set
--      hideControlSet(2)
--      -- Hide a few sets
--      hideControlSets({1,3,2,5})
--/endcode

global procedure hideControlSet(object id)
    if atom(id) then
        if id = 0 then
            for i = 1 to length(vControlSets) do
                setVisible(vControlSets[i], w32False)
            end for
            id = {}
        else
            id = {id}
        end if
    end if

    for i = 1 to length(id) do
        if id[i] > 0 and id[i] <= length(vControlSets) then
            setVisible(vControlSets[id[i]], w32False)
        end if
    end for
end procedure

--/topic Controls
--/proc enableControlSet(integer id)
--/desc Enables all the controls in the identified set, and disables the previously enabled set.
--
--/i id is the id of a ControlSet created by /setControlSet
--
--Example:
--/code
--      sequence FuncGroup
--      sequence TriggerGroup
--      constant CustomerGrp=1, OrderGrp=2, InventGrp=5, AdminGrp=7
--
--      setControlSet(CustomerGrp, w32True, {Fld1, Fld2, Fld3})
--      setControlSet(OrderGrp, w32True, {Fld11, Fld12, Fld13, Fld14})
--      setControlSet(InventGrp, w32True, {Fld21, Fld22})
--      setControlSet(AdminGrp, w32True, {Fld31, Fld32, Fld33})
--      TriggerGroup = {Btn1,        Btn2,     Btn3,      Btn4}
--      FuncGroup    = {CustomerGrp, OrderGrp, InventGrp, AdminGrp}
--
--      procedure Click_Buttons(integer self, integer event, sequence parms)
--          enableControlSet( FuncGroup[ find(self, TriggerGroup) ] )
--      end procedure
--      setHandler(TriggerGroup, w32HClick, routine_id("Click_Buttons"))
--/endcode
global procedure enableControlSet(integer id)
    if not equal(id, vCurrentControlSet) and
       id > 0 and
       id <= length(vControlSets) then
        setEnable(vControlSets[id], w32True)
        if integer(vCurrentControlSet) then
            setEnable(vControlSets[vCurrentControlSet], w32False)
        end if
        vCurrentControlSet = id
    end if
end procedure

--/topic Controls
--/proc disableControlSet(object set)
--/desc Disables all the controls in the identified set(s).
--/i set is either a single ControlSet id, or a list of ControlSet ids.
--
--If /i set is zero, then all known ControlSets are disabled.
--
--Example:
--/code
--      -- Disable all sets
--      disableControlSet(0)
--      -- Disable one set
--      disableControlSet(2)
--      -- Disable a few sets
--      disableControlSets({1,3,2,5})
--/endcode

global procedure disableControlSet(object id)
    if atom(id) then
        if id = 0 then
            for i = 1 to length(vControlSets) do
                setEnable(vControlSets[i], w32False)
            end for
            id = {}
        else
            id = {id}
        end if
    end if

    for i = 1 to length(id) do
        if id[i] > 0 and id[i] <= length(vControlSets) then
            setEnable(vControlSets[id[i]], w32False)
        end if
    end for
end procedure

--/topic Controls
--/proc setControlSet(integer Set, integer Add, object id)
--/desc Create and maintains the entries in a control set.
--ControlSets are used to easily manipulate a set of related controls.
--
--/i Set is the id of the control set. If it doesn't exist, it is created. /n
--/i Add is a True/False flag. If w32True then the /id is added to the set,
-- otherwise it is removed from the set. /n
--/i id is either a single control id or a list of control ids.
--
--Example:
--/code
--      -- Add some controls to a set.
--      setControlSet(InventGrp, w32True, {Fld21, Fld22})
--      setControlSet(InventGrp, w32True, {Fld23, Fld25})
--      -- The control set 'InventGrp' now has 4 ids in it.
--      -- Remove one.
--      setControlSet(InventGrp, Fld22)
--      -- The control set 'InventGrp' now has 3 ids in it.
--/endcode
--
--See also: /showControlSet, /hideControlSet, /enableControlSet, /disableControlSet

global procedure setControlSet(integer pSet, integer pAdd, object id)
    integer lPos

    if pSet <= 0 then
        return
    end if
    if pSet > length(vControlSets) then
        vControlSets &= repeat({}, pSet - length(vControlSets))
    end if

    if not sequence(id) then
        id = {id}
    end if

    if pAdd = w32True then
        for i = 1 to length(id) do
            if not find(id[i], vControlSets[pSet]) then
                vControlSets[pSet] &= id[i]
            end if
        end for
    else
        for i = 1 to length(id) do
            vControlSets[pSet] = w32removeItem(id[i], vControlSets[pSet])
        end for
    end if

end procedure
r_setControlSet = routine_id("setControlSet")

--/topic TreeView Control
--/func hitTestTV( id )
--/desc Check to see if mouse is over a /TreeView item
--/ret Index of /TreeView item under mouse, or zero, if none
global function hitTestTV( integer id )
    atom ht, iItem, flags, mset
    sequence pt

    pt = getPointerRelPos(id)

    -- need to calculate offset due to control position
    ht = struct_TVHITTESTINFO( pt[1], pt[2], 0, 0 )

    iItem = sendMessage( id, TVM_HITTEST, getHandle( id ), ht )

    flags = w32fetch( ht, TVHITTESTINFO_flags )

    if and_bits( flags, TVHT_ONITEM ) then
        iItem = find( iItem, tvitem_handle )
    else
        iItem = 0
    end if

    w32release_mem( ht )

    return iItem
end function


--/* Begin Tone Skoda --
-- [Created on 6. June 2002, 14:23]

--/topic TreeView Control
--/func expandTV(object TVID, object ItemID, integer Action)
--/desc Expands or Collapses all child tree items.
--/ret INTEGER: The inverse of /i pAction
-- /i TVID is the id of a TreeView control /n
-- /i ItemID is the id of a TreeView item as returned by /addTVItem /n
-- /i Action is either TVE_EXPAND or TVE_COLLAPSE. The default is TVE_EXPAND. /n
-- This routine expands or collapses all the items, starting with /i ItemId, and
-- continuing down the hierarchy. /n
-- /b Returning the opposite of /i Action. Thus if /i Action was /b TVE_EXPAND then
-- this would return /b TVE_COLLAPSE, and visa versa.
--
--Example:  /i<See demo /b<ListTreeView.exw>>
--/code
--      integer nextAction
--      nextAction = TVE_EXPAND
--      nextAction = expandTV( myTV, rootItem, nextAction)
--/endcode
constant tvActions = {TVE_EXPAND, TVE_COLLAPSE}
function Internal_expandTV(object treewnd, object item_handle, integer pAction, integer pLock)
    atom hChild
    atom hTV, hTVI

    if sequence(item_handle) then
        hTV = treewnd[1]
    else
        hTV = getHandle(treewnd)
    end if

    if sequence(item_handle) then
        hTVI = item_handle[1]
    else
        hTVI = getHandle({treewnd, item_handle})
    end if
    if not find(pAction, tvActions) then
        pAction = TVE_EXPAND
    end if

    if pLock = w32True then
        VOID = w32Func(xLockWindowUpdate, {hTV})
    end if
    VOID = w32Func(xSendMessage,{ hTV, TVM_EXPAND, pAction, hTVI})
    hChild = w32Func(xSendMessage,{hTV, TVM_GETNEXTITEM, TVGN_CHILD, hTVI})
    while hChild do
        VOID = Internal_expandTV ({hTV}, {hChild}, pAction, w32False)
        hChild = w32Func(xSendMessage,{hTV, TVM_GETNEXTITEM, TVGN_NEXT, hChild})
    end while
    if pLock = w32True then
        VOID = w32Func(xLockWindowUpdate,{0})
    end if
    return tvActions[w32iff(find(pAction, tvActions)=1,2,1)]
end function
global function expandTV(object treewnd, object item_handle, integer pAction)
    return Internal_expandTV(treewnd, item_handle, pAction, w32True)
end function

-- End Tone Skoda

-----------------------------------------------------------------------------
--/topic System Attributes
--/func getKeyState(atom key)
--/desc Gets the depressed stats of the /i key.
--/ret INTEGER: w32True if the /i key is pressed otherwise w32False
--
--Example:
--/code
--      if getKeyState( VK_NUMPAD0) then
--          cmd = kStop
--      elsif getKeyState( VK_NUMPAD2) then
--          cmd = kDown
--      elsif getKeyState( VK_NUMPAD4) then
--          cmd = kLeft
--      elsif getKeyState( VK_NUMPAD6) then
--          cmd = kRight
--      elsif getKeyState( VK_NUMPAD8) then
--          cmd = kUp
--      else
--          cmd = 0
--      end if
--      processCmd(cmd)
--/endcode

global function getKeyState( atom key )

    -- return the state Shift, Control, or Menu keys
    atom result

    -- get key
    result = w32Func( xGetKeyState, {key} )

    -- check the high bit. (low bit is toggle state)
    return (floor( result / 2 ) != 0)

end function
r_getKeyState = routine_id("getKeyState")

-----------------------------------------------------------------------------
function getKeyMasks(atom wParam)

    -- return the state Shift, Control, and Menu keys
    integer flags

    -- clear the flags
    flags = 0

    -- shift key
    if getKeyState( VK_SHIFT ) then
        flags += ShiftMask
    end if

    -- control key
    if getKeyState( VK_CONTROL ) then
        flags += ControlMask
    end if

    -- alt key
    if getKeyState( VK_MENU ) then
        flags += AltMask
    end if

    if and_bits(wParam, LEFT_BUTTON) then
        flags += LeftBtnMask
    end if

    if and_bits(wParam, RIGHT_BUTTON) then
        flags += RightBtnMask
    end if

    if and_bits(wParam, MIDDLE_BUTTON) then
        flags += MiddleBtnMask
    end if

    return flags

end function
r_getKeyMasks = routine_id("getKeyMasks")



-----------------------------------------------------------------------------

procedure resizeWidgets( integer id, integer cx, integer cy )

    -- this is called when a window has been resized.

    integer lMoveId, lRepaint

    -- Special handling for rebars.
    for i = 1 to length(ctrl_Init_Posns[id][1]) do
        lMoveId = ctrl_Init_Posns[id][1][i]
        lRepaint = w32iff( ctrl_Type[lMoveId] = Window,1,0)
        setRect(lMoveId,
                ctrl_Init_Posns[id][2][i][1],
                ctrl_Init_Posns[id][2][i][2],
                ctrl_Init_Posns[id][2][i][3],
                ctrl_Init_Posns[id][2][i][4], lRepaint)
    end for

end procedure


integer vSkipF10 vSkipF10 = w32False

--/topic Menus
--/func skipF10(integer NewValue)
--/desc Sets whether or not F10 sets focus on the menubar
--/ret Returns INTEGER: The current value of the flag.
--By default, the F10 key sets focus on the menubar. If /i NewValue
-- is w32True, then the behaviour is changed so that the F10 key does not
-- set focus on the menubar.
--
--Example:
--/code
--      integer PrevF10Flag
--      PrevF10Flag = skipF10( w32True )
--/endcode
-----------------------------------------------------------------------------
global function skipF10(integer pNewValue)
-----------------------------------------------------------------------------
    integer lOldValue

    lOldValue = vSkipF10
    vSkipF10 = (pNewValue != 0)
    return lOldValue

end function


----------------------------------------------------------------------------
function fDoSYSKEY( integer id, atom hWnd, atom event, atom key, atom lParam, atom pReturn )
----------------------------------------------------------------------------
    integer lRC

    lRC = kSubclassedMsg
    if key = VK_F10 then
        if not vSkipF10 then
            VOID = sendMessage(id, WM_KEYDOWN, key, lParam)
        else
            VOID = invokeHandler(id, w32HKeyDown, {key, getKeyMasks(0)})
            lRC = kMainMsg
        end if
    end if
    return {lRC}
end function

-----------------------------------------------------------------------------
function isHotKey( integer id, atom hWnd, atom event, atom key, atom lParam, atom pReturn )
-----------------------------------------------------------------------------

integer window, focus , i
integer parent, j
sequence hotkeys, hotids

    -- if there is a control in the hotkey list associated with the
    -- toplevel parent window, set focus to that control and return
    -- true.
    --
    -- note that some controls (like TabControl) can have several items
    -- with the same hotkey, since only one group of controls are enabled
    -- at a time.

    -- find the top level window

    window = findParentWindow(id)
    if window = 0 then
       return {kSubclassedMsg} -- control is not in a window!
    end if

    -- get the hotkey list
    hotkeys = upper(ctrl_Hotkey_Keys[ window ]) & lower(ctrl_Hotkey_Keys[ window ])
    hotids  = ctrl_Hotkey_Ids[ window ] & ctrl_Hotkey_Ids[ window ]
    -- any controls with same parent have this hotkey?
    while 1 do
        i = find(key, hotkeys)
        if i = 0 then
            exit
        end if

        -- get item with hotkey
        focus = hotids[i]

        -- is the control enabled and visible?
        if  isEnabled( focus )
           and isVisible( focus ) then
            -- change focus
            if ctrl_Type[focus] = TabItem then
                setFocus (focus)
            else
                w32Proc( xSetFocus, { getHandle( focus ) } )
            end if
            if ((event = WM_KEYDOWN) or (event = WM_SYSCHAR)) then
                if ctrl_Family[ focus ] = BUTTON then
                    VOID = sendMessage( focus, BM_CLICK, 0, 0 )
                elsif ctrl_Type[ focus ] = Window then
                 VOID = sendMessage( focus, WM_LBUTTONDOWN, 0, 0 )
                 VOID = sendMessage( focus, WM_LBUTTONUP, 0, 0 )
                end if
            end if

            -- return true; hotkey handled
            return {kMainMsg,-1}
        else
            hotkeys = hotkeys[i+1 .. length(hotkeys)]
            hotids  = hotids[i+1 .. length(hotids)]
        end if
    end while

    -- hotkey not handled
    return {kSubclassedMsg}
end function


constant kMsgCommandCode = {
    {BUTTON,BN_CLICKED},     -- Button click
    {STATIC,STN_CLICKED},    -- Label(static) click
    {LISTBOX,LBN_SELCHANGE},  -- combo/list box selection change
    {EDIT,EN_CHANGE},      -- editbox notify change
    {COMBO,CBN_EDITCHANGE}, -- combo notify change has occured
    {COMBO,CBN_SELCHANGE},  -- combo/list box notify change
    {COMBO,CBN_DROPDOWN},   -- The combobox is about to dropdown.
    {COMBO,CBN_CLOSEUP}     -- The combobox dropdown has just been closed
    }

constant kW32EventCode = {
    {w32HClick,   0},    -- Button
    {w32HClick,   0},    -- Label Click
    {w32HChange,  w32CHG_Sel},   -- list box notify change
    {w32HChange,  w32CHG_Chg},   -- editbox notify change
    {w32HChange,  w32CHG_Chg},   -- combo data changed
    {w32HChange,  w32CHG_Sel},   -- combo selection changed
    {w32HDropDown,0}, -- combo is about to dropdown.
    {w32HCloseUp, 0}   -- combo dropdown has just been closed
    }

-----------------------------------------------------------------------------
procedure wmCommand( integer id, atom hWnd, atom iMsg, atom wParam, atom lParam)
-----------------------------------------------------------------------------

    -- this handles notification (WM_COMMAND) messages
    -- this is used by WINDOW and TabControls.

    integer event, w32event
    integer lPos
    sequence parms
    object lExtra
    sequence lObjEvent

    -- determine which window sent the message
    -- update with new id

    if ctrl_Type[ id ] = FlatToolBar then
        id = w32lo_word( wParam )
    end if

    -- clear parms

    parms = {}
    lExtra = {}
    event = w32hi_word( wParam )

    lObjEvent = {ctrl_Family[id],event}
    lPos = find(lObjEvent, kMsgCommandCode)
    if lPos != 0 then
        lExtra &= kW32EventCode[lPos][2]
        w32event = kW32EventCode[lPos][1]
        -- Special handling for Radio buttons that get focus via tabbing.
        if w32event = w32HClick and
           ctrl_Type[id] = Radio and
           sendMessage( id, BM_GETCHECK, 0, 0 ) = 0 then
            return
        end if
        -- Special handling for COMBO and LISTBOX
        if lObjEvent[1] = COMBO then
            lExtra &= 1 + sendMessage(id, CB_GETCURSEL, 0, 0)
        elsif lObjEvent[1] = LISTBOX then
            lExtra &= 1 + sendMessage(id, LB_GETCURSEL, 0, 0)
        end if
        VOID  = invokeHandler(id, w32event, lExtra)
    end if

end procedure

--/topic ListView control
--/proc setLVStyle(integer ID, object StyleFlags)
--/desc Sets the extended style flags on a listview
--
--/i StyleFlags can either be an atom containing all then
-- flag bits set to a sequence of flag names. The valid names are... \n
--/li LVS_EX_GRIDLINES
--/li LVS_EX_SUBITEMIMAGES
--/li LVS_EX_CHECKBOXES
--/li LVS_EX_TRACKSELECT
--/li LVS_EX_HEADERDRAGDROP
--/li LVS_EX_FULLROWSELECT
--/li LVS_EX_ONECLICKACTIVATE
--/li LVS_EX_TWOCLICKACTIVATE
--/li LVS_EX_FLATSB
--/li LVS_EX_REGIONAL
--/li LVS_EX_NFOTIP
--/li LVS_EX_UNDERLINEHOT
--/li LVS_EX_UNDERLINECOLD
--/li LVS_EX_MULTIWORKAREAS
--
--Example
--/code
--      setLVStyle(myListView, {LVS_EX_FULLROWSELECT,
--                              LVS_EX_GRIDLINES,
--                              LVS_EX_HEADERDRAGDROP})
--/endcode
global procedure setLVStyle(integer pId, object pStyleFlags)
    atom lMask

    if sequence( pStyleFlags ) then
        lMask = w32or_all(pStyleFlags)
    else
        lMask = pStyleFlags
    end if

    VOID = sendMessage( pId, LVM_SETEXTENDEDLISTVIEWSTYLE, lMask, lMask)
end procedure
r_setLVStyle = routine_id("setLVStyle")

--/topic ListView control
--/func setLVAttr(integer id, sequence pNewData)
--/desc Set (some) attributes of a ListView control
--/ret SEQUENCE: The current attributes.
-- /i id is the ListView's id /n
-- /i pNewData is a list of two-element sequences. The first
-- element is the code name for the attribute being changed,
-- and the second is the new value for it.
--
--<ul>
--/li /i kLVColTypes The data types per column for sorting. /n
-- The data is a sequence, one element per column. /n
-- The values can be one of: /n
--<ul>
--/li 'i' = Case Insensitive sorting
--/li 'n' = Numeric Sorting
--/li 'a' = Case sensitive
--</ul>
--/li /i kLVSortSeq The sorting direction, per column, to use. /n
-- The values for the kLVSortSeq attribute can be: /n
--<ul>
--/li -2 = swaps between ascending and descending for each column click.
--/li -1 = descending
--/li  1 = ascending
--/li  2 = swaps between descending and ascending for each column click.
--</ul>
--/li /i kLVSortRtn The routine_id, per column, of the user-defined sorting routine.
-- If any column value is set to -2, then the default routine is used. If set
-- to -1 then no sorting is done on that column.
--
-- When a user clicks on a column heading on a listview, Win32lib tries to sort
-- the ListView based on the contents of the row data. You are able to specify
-- your own sorting method if the built-in ones are not sufficient.
--
-- The user-defined sorting routine is called whenever Windows needs to know which
-- of two items goes before, goes after, or are equivalent. The exact number of times
-- that this is called depends on the number of items in the listview, however you can
-- expect it to be called many times for each sort request.
--
-- The user-defined routine is passed four parameters: /n
--/code
--    integer ID    -- The control id of the listview
--    integer ItemA -- The row number of one of the items to compare
--    integer ItemB -- The row number of the other item to compare
--    integer Column-- The column number that was clicked on.
--/endcode
--
-- The user-defined routine is also called just before the sorting starts and just
-- after it finishes. In these cases, ItemA and ItemB are both -1 and the Column
-- value is either w32LV_StartSorting or w32LV_EndSorting, respectively. /n
-- When called at the start of sorting, your routine is expected to return w32True
-- if the sort can commence, otherwise the sort request is rejected.
--
-- /b Note that the cursor is changed to the 'hourglass' shape during the sorting
-- process.
--</ul>
--
--Example:
--/code
--    sequence ov
--    -- Indicate that col 1 is case-insensitive, and col 2 is numeric.
--    -- Indicate that col 1 swaps directions, and col 2 is always ascending.
--    ov = setLVAttr( myLV, {{kLVColTypes, {'i','n'}},
--                           {kLVSortSeq, {-2, 1}},
--                           {kLVSortRtn, {-2, routine_id("lvsort")}}
--                       })
--/endcode
global function setLVAttr(integer id, sequence pNewData)
    sequence lOldData
    integer lv

    lv = find(id, lv_id)
    if lv = 0 then
        return {}
    end if

    lOldData = lv_properties[lv]

    for i = 1 to length(pNewData) do
        if pNewData[i][1] = kLVColTypes then
            lv_properties[lv][kLVColTypes] = pNewData[i][2]

        elsif pNewData[i][1] = kLVSortSeq then
            lv_properties[lv][kLVSortSeq] = pNewData[i][2]

        elsif pNewData[i][1] = kLVSortRtn then
            lv_properties[lv][kLVSortRtn] = pNewData[i][2]
            if sequence(lv_properties[lv][kLVSortRtn]) then
                for j = 1 to length(lv_properties[lv][kLVSortRtn]) do
                    if lv_properties[lv][kLVSortRtn][j] = -2 then
                        lv_properties[lv][kLVSortRtn][j] = r_lvSortitems
                    end if
                end for
            else
                if lv_properties[lv][kLVSortRtn] = -2 then
                    lv_properties[lv][kLVSortRtn] = r_lvSortitems
                end if
            end if
        end if
    end for

    return lOldData
end function


function lvSortitems( integer id, integer lItem1, integer lItem2, integer column )
    object text1, text2, textnum
    sequence lProps

    lProps = lv_properties[find(id, lv_id)]
    text1 = getLVItemText(id, lItem1, column)
    if sequence(lProps[kLVColTypes]) and length(lProps[kLVColTypes]) >= column then
        if equal(lProps[kLVColTypes][column], 'i') then
            text1 = upper(text1)
        elsif equal(lProps[kLVColTypes][column], 'n') then
            textnum =  w32TextToNumber({text1, w32True})
            if textnum[2] = 0 then
                text1 = textnum[1]
            end if
        end if
    end if

    text2 = getLVItemText(id, lItem2, column)
    if sequence(lProps[kLVColTypes]) and length(lProps[kLVColTypes]) >= column then
        if equal(lProps[kLVColTypes][column], 'i') then
            text2 = upper(text2)
        elsif equal(lProps[kLVColTypes][column], 'n') then
            textnum =  w32TextToNumber({text2, w32True})
            if textnum[2] = 0 then
                text2 = textnum[1]
            end if
        end if
    end if

    return compare( text1, text2)

end function
r_lvSortitems = routine_id( "lvSortitems" )

function PrepareLVSort( atom lParam1, atom lParam2, atom id )
    integer lItem1, lItem2
    integer rtn, column
    atom LV_FINDINFO
    integer sign, subitem
    sequence lProps

    -- Allow something else to happen too.
    call_proc(r_doEvents,{0})

    lProps = lv_properties[find(id, lv_id)]
    column = lProps[kLVSortCol]

    rtn = r_lvSortitems
    if sequence(lProps[kLVSortRtn]) then
        if length(lProps[kLVSortRtn]) >= column then
            rtn = lProps[kLVSortRtn][column]
        end if
    end if

    if rtn = -1 then
        -- No sorting done.
        return 0
    end if

    LV_FINDINFO = struct_LVFINDINFO( LVFI_PARAM, "", lParam1, 0, 0, 0)
    lItem1 = sendMessage( id, LVM_FINDITEM, -1, LV_FINDINFO ) + 1

    w32store(LV_FINDINFO, LVFINDINFO_lParam, lParam2)
    lItem2 = sendMessage( id, LVM_FINDITEM, -1, LV_FINDINFO ) + 1

    w32release_mem(LV_FINDINFO)

    if lItem1 = 0 or lItem2 = 0 then
        -- Nothing to sort.
        return 0
    end if

    sign = 1
    if sequence(lProps[kLVSortSeq]) then
        if length(lProps[kLVSortSeq]) >= column then
            if lProps[kLVSortSeq][column] < 0 then
                sign = -1
            end if
        end if
    else
        if lProps[kLVSortSeq] < 0 then
            sign = -1
        end if
    end if

    return sign * call_func(rtn,{id, lItem1, lItem2, column})

end function

atom pfnCompare
pfnCompare = call_back( routine_id("PrepareLVSort") )


--/topic ListView control
--/proc loadLVInfo(integer id, sequence pNewData)
--/desc Used to bulk load data into a list view control
-- /i id is the ID of the /ListView control /n
-- /i pNewData is a list of row data and optional image ids.
-- Each element is either a list of column data or an image id
-- as returned from /addIcon(). An image id applies to all
-- the row data that follows until the next image id.
--
--Example:
--/code
--      sequence theData
--      integer iconMale, iconFemale
--      iconMale = addIcon(loadBitmapFromFile("male.ico"))
--      iconFemale = addIcon(loadBitmapFromFile("female.ico"))
--      theData = {}
--      theData &= iconMale
--      theData = append(theData, {"George", 95.4, "Judo"})
--      theData = append(theData, {"Harry", 97.2, "Karate"})
--      theData &= iconFemale
--      theData = append(theData, {"Wendy", 65.1, "Kendo"})
--      theData = append(theData, {"Jill", 75.8, "Ice Hockey"})
--      theData &= iconMale
--      theData = append(theData, {"Horatio", 105.1, "Chess"})
--      theData = append(theData, {"Felix", 87.0, "Butterflies"})
--      loadLVInfo(myLV, theData)
--/endcode
global procedure loadLVInfo(atom id, sequence alldata)
    atom hWnd
    atom LV_ITEM
    object data
    integer msg
    integer lImageIdx
    atom lNewRow

    hWnd = getHandle(id)
    VOID = w32Func( xSendMessage, {hWnd, LVM_DELETEALLITEMS, 0, 0})
    LV_ITEM = w32acquire_mem(0,  SIZEOF_LVITEM )
    lImageIdx = -1
    for i = 1 to length(alldata) do
        data = alldata[i]
        if sequence( data ) then
            w32store( LV_ITEM, LVITEM_iItem, i-1)
            w32store( LV_ITEM, LVITEM_lParam, i )
            w32store( LV_ITEM, LVITEM_iImage, lImageIdx)

            for j = 1 to length(data) do
                w32store( LV_ITEM, LVITEM_iSubItem, j-1 )
                if not sequence(data[j]) then
                    data[j] = sprintf("%g", data[j])
                end if

                w32store( LV_ITEM, LVITEM_pszText, data[j] )
                w32store( LV_ITEM, LVITEM_cchTextMax, length(data[j]) )
                if j = 1 then
                    msg = LVM_INSERTITEM
                    w32store( LV_ITEM, LVITEM_mask, w32or_all({LVIF_TEXT,LVIF_IMAGE,LVIF_PARAM}) )
                    lNewRow = w32Func( xSendMessage, { hWnd, msg, i-1, LV_ITEM } )
                else
                    msg = LVM_SETITEMTEXT
                    w32store( LV_ITEM, LVITEM_mask, LVIF_TEXT )
                    VOID = w32Func( xSendMessage, { hWnd, msg, lNewRow, LV_ITEM } )
                end if
            end for
        else
            lImageIdx = data-1
        end if
    end for

    w32release_mem(LV_ITEM)
end procedure

--/topic ListView Control
--/func hitTestLV( id )
--/desc Check to see if mouse is over a /ListView item
--/ret Id of /ListView item under mouse, or zero, if none
global function hitTestLV( integer id )
    atom ht,  flags
    sequence pt
    sequence lItem

    pt = getPointerRelPos(id)

    -- need to calculate offset due to control position
    ht = w32acquire_mem(0, SIZEOF_LVHITTESTINFO)
    w32store(ht, LVHITTESTINFO_ptX, pt[1])
    w32store(ht, LVHITTESTINFO_ptY, pt[2])

    VOID = sendMessage( id, LVM_HITTEST, 0, ht )

    flags = w32fetch( ht, LVHITTESTINFO_flags )

    if and_bits( flags, LVHT_ONITEM ) then
        lItem = {w32fetch(ht,LVHITTESTINFO_iItem),
                 w32fetch(ht,LVHITTESTINFO_iSubItem)} + 1--find( iItem, tvitem_handle )
    else
        lItem = {}
    end if

    w32release_mem( ht )

    return lItem
end function




-- DEBUG IMPLEMENT API SCROLLWINDOWEX

-----------------------------------------------------------------------------
function fDoScroll( integer id, atom hWnd, atom iMsg, atom wParam, atom lParam, atom pReturn )
-----------------------------------------------------------------------------

	-- scroll event handler
	integer
		request,
		origpos,
		lChildId,
		lnChg, pgChg,
		lWhich, lSBar,
		inc
	atom
	   pos
	sequence
	   range,
	   chgs,
	   lRC,
	   lDir,
	   lScope

	-- determine if this is from the parent window's scroll
	-- bar, or a child scroll bar

	if ctrl_Parent[id] != 0 then
		lRC = {kSubclassedMsg}
	else
		lRC = {kMainMsg}
	end if

	if lParam != 0 then -- I have children
		-- find the control
		lChildId = getId( lParam )
		if lChildId = 0  or ctrl_Parent[lChildId] != id then -- Not one of mine
			return lRC
		end if

		id = lChildId
	end if

	-- get the request
	request = w32lo_word( wParam )

	-- get the value of the scroll bar
	if find(ctrl_Type[ id ] , {HScroll, VScroll}) then
		lWhich = 1
		lSBar = SB_CTL

	elsif find(ctrl_Type[ id ] , {Window, HTrackBar, VTrackBar, UpDown}) then
		if iMsg = WM_VSCROLL then
			lWhich = 1
			lSBar = SB_VERT
		else
			lWhich = 2
			lSBar = SB_HORZ
		end if
	else

		lWhich = 1
		lSBar = SB_VERT
	end if

	-- UpDown's handle scroll events themselves
	if ctrl_Type[ id ] = UpDown then
		pos = getScrollPos( id )
		VOID = invokeHandler(id, w32HScroll, {pos, request, lSBar})
		return {kMainMsg}
	end if

	if request != SB_THUMBTRACK then
		pos = getScrollPos( {id, lSBar} )

	else
		pos = getThumbPos( {id, lSBar} )

	end if

	if find(ctrl_Type[ id ], {HTrackBar, VTrackBar}) then
		origpos = 0
	else
		origpos = pos
	end if

	-- get the range
	range = getScrollRange( {id, lSBar} )

	-- scrollbars need special handling to adjust small/large change
	inc = find(request, {SB_LINEUP, SB_LINEDOWN, SB_PAGEUP, SB_PAGEDOWN})
	if inc != 0 then
		if find(ctrl_Type[ id ], {HScroll, VScroll, Window}) then
			lDir = {-1, 1, -1, 1}
			lScope = {MY_SMALLCHANGE, MY_SMALLCHANGE, MY_LARGECHANGE, MY_LARGECHANGE}
			if ctrl_Type[id] = Window then
				chgs = ctrl_Scroll[id][lWhich]
			else
				chgs = ctrl_Scroll[id][1]
			end if

			pos += (chgs[lScope[inc]] * lDir[inc])
		end if

	elsif request = SB_ENDSCROLL then
		VOID = invokeHandler(id, w32HScroll, {pos, request, lSBar})
		return lRC

	elsif request = SB_TOP then
		-- to top of page
		pos = range[1]

	elsif request = SB_BOTTOM then
		-- to bottom of page
		pos = range[2]

	elsif find(request, {SB_THUMBPOSITION, SB_THUMBTRACK}) then
		-- track thumb position
        origpos = -1 -- Force the event to kick in.
		pos = getThumbPos( {id, lSBar} )

	end if

	-- clip to range
	if pos < range[1] then
		pos = range[1]
	elsif pos > range[2] then
		pos = range[2]
	end if

	-- call global routine to do the work
	if pos != origpos then
		setScrollPos( {id, lSBar} , {pos, request} )
	end if

	return lRC
end function

-----------------------------------------------------------------------------
function fDoDropFiles(integer id, atom hWnd, atom iMsg, atom hDrop, atom lParam, atom pReturn)
-----------------------------------------------------------------------------

    -- processes a WM_DROPFILES event.

    integer bufferSize, namesize, itemCount, dropRoutine
    atom buffer
    sequence fileName
    object lUserResponse

    -- does this control support drag and drop?

    if   onDragAndDrop[ id ] >= 0
      or onDragAndDrop[ Screen ] >= 0
      or length(ctrl_Handlers[id][w32HDragAndDrop]) > 0
      or length(ctrl_Handlers[Screen][w32HDragAndDrop]) > 0
    then

        -- set up data structures
        bufferSize = 4000
        buffer = w32acquire_mem(0, bufferSize )

        -- get the count of files
        itemCount = w32Func(xDragQueryFile,{hDrop, #FFFFFFFF, buffer, bufferSize})

        if itemCount > 0 then

            -- Indicate number of files in list.
            lUserResponse = invokeHandler(id, w32HDragAndDrop, {0, {itemCount}})

            -- DragQueryFileA uses zero based indexing
            for i = 0 to itemCount - 1 do
                -- Check to see if user has aborted callbacks.
                if sequence(lUserResponse) then
                    exit
                end if

                -- checking for buffer overflow.
                namesize = w32Func(xDragQueryFile,{hDrop, i, 0, bufferSize})
                if (namesize+1) > bufferSize then
                    w32release_mem(buffer)
                    bufferSize = namesize + 1
                    buffer = w32acquire_mem(0, bufferSize)
                end if
                namesize = w32Func(xDragQueryFile,{hDrop, i, buffer, bufferSize})

                -- get the next file name
                fileName = peek({buffer, namesize})

                -- user trap
                lUserResponse = invokeHandler(id, w32HDragAndDrop, {0, fileName})
            end for

            -- Indicate end of file list.
            VOID = invokeHandler(id, w32HDragAndDrop, {0, ""})
        end if

        -- Free the memory
        w32release_mem( buffer )

    end if

    return {kSubclassedMsg}

end function

sequence vLMB_id
vLMB_id = {-1, -1, -1, -1}

atom
      vMaxClickTime
integer
    vMaxClickXDelta,
    vMaxClickYDelta

vMaxClickTime   = (w32Func(xGetDoubleClickTime,{}) / 1000)
vMaxClickXDelta = 3
vMaxClickYDelta = 3

--/topic Events
--/func setMouseClick(object pTimeDelta, object pXDelta, object pYDelta)
--/desc Sets/gets the mouse click detection parameters.
--/ret The current settings for these parameters.
-- There are three parameters used to detect a mouse click event. These are /n
--/li Time: Number of seconds difference between left mouse down and up events.
--/li XDelta: Number of pixels allowance in the X (horizontal) direction.
--/li YDelta: Number of pixels allowance in the Y (vertical) direction.
--
-- By using this function, you can set any, all, or none of these parameters. To /b not
-- set a parameter, you must use an empty sequence in its place.
--
-- example:
--/code
--     -- Set the time to 1.5 seconds, and the Y tolerance to 5 pixels.
--     -- Leave the X tolerance as it is.
--     curval1 = setMouseClick( 1.5, {}, 5)
--     -- Double the X tolerance, leaving the others alone.
--     curval2 = setMouseClick( {}, curval1[2] * 2, {})
--/endcode

----------------------------------------------------
global function setMouseClick(object pTimeDelta, object pXDelta, object pYDelta)
----------------------------------------------------
sequence
     lCurrentValues

   lCurrentValues = {vMaxClickTime, vMaxClickXDelta, vMaxClickYDelta}

   if atom(pTimeDelta) then
      vMaxClickTime   = pTimeDelta
   end if

   if atom(pXDelta) then
      vMaxClickXDelta = pXDelta
   end if

   if atom(pYDelta) then
      vMaxClickYDelta = pYDelta
   end if

   return lCurrentValues
end function

----------------------------------------------------
function fDoMouse(integer id, atom hWnd, atom iMsg, atom wParam, atom lParam, atom pReturn)
----------------------------------------------------
    integer
        mouseX,
        mouseY,
        action,
        doActions,
        lWheelPosn,
        lParent
    sequence
        lRC,
        lEventParms,
        cmp,
        lRgns,
        lRelXY

    lRC = {pReturn}
    if (and_bits(classAttr[ctrl_Type[id]], w32Clickable) != 0)
          or (ctrl_Family[id] = BUTTON)
          or find(iMsg, {WM_RBUTTONDOWN, WM_MOUSEWHEEL})
          or (classType[ctrl_Type[id]] = STATIC and
               and_bits(SS_NOTIFY, w32Func( xGetWindowLong, { ctrl_Handle[id], GWL_STYLE })) != 0)
          then
          doActions = w32True
    else
        doActions = w32False
    end if
    lParent = findParentWindow(id)

    -- decode parameters
    mouseX = w32shortInt( w32lo_word( lParam ) )
    mouseY = w32shortInt( w32hi_word( lParam ) )
    if iMsg = WM_MOUSEWHEEL then
        -- This 'fixes' a bug in Windows in which the incorrect x/y is being reported.
        lRgns = getPointerRelPos(id)
        mouseX = lRgns[1]
        mouseY = lRgns[2]
        -- Get the movement and direction data
        lWheelPosn = w32hi_word(wParam)
        if lWheelPosn > #7FFF then
            lWheelPosn -= #10000
        end if
        lWheelPosn /= 120
    else
        lWheelPosn = 0
    end if

    if sequence(ctrl_Mousetrap[lParent]) then
        -- Check the mousetrap areas set for this control.
        lRelXY = getPointerRelPos(lParent)
        lRgns = hitMouseTrap(lParent, iMsg, lRelXY[1], lRelXY[2])
        if length(lRgns) > 0 then
            VOID = invokeHandler(lParent, w32HMouseTrap, {iMsg, lRelXY[1], lRelXY[2],  lWheelPosn, lRgns, id})
            if sequence(VOID) then
                -- If the user returns anything, eat the event.
                lRC = {kMainMsg}
                iMsg = 0
                doActions = w32False
            end if
        end if
    end if

    -- get command

    if iMsg = WM_LBUTTONUP then
        -- test for a "click" gesture.
        if vLMB_id[1] = id and
          time()-vLMB_id[4] < vMaxClickTime  and
          w32abs(mouseX - vLMB_id[2]) < vMaxClickXDelta  and
          w32abs(mouseY - vLMB_id[3]) < vMaxClickYDelta then
            -- Clicking! Any handler for this?
            if doActions and (ctrl_Family[id] != BUTTON) then
                -- Note. Buttons are notified via the BN_CLICKED msg.
                VOID = invokeHandler(id, w32HClick, {})
            end if
        else -- not a click.

            if length(vDragData) > 0 then
                -- I'm draging something. --
                -- First, tell the destination control.
                VOID = invokeHandler(id,          w32HDragAndDrop, vDragData)
                -- Secondly, tell the source control
                VOID = invokeHandler(vDragData[1], w32HDragAndDrop, vDragData)
                -- Reset the cursor shape.
                IndicateDragging( vDragData[1], w32False ) -- Reset drag cursor shape.
            end if
        end if

        vDragData = {} -- Clear any drag operation data.

    end if

    if iMsg != WM_MOUSEMOVE then
        vLMB_id[1] = -1
    end if

    -- set the mouse cursor
    VOID = w32Func( xSetCursor, {ctrl_Cursor[ id ][1]} )

    -- generate an event?
    if doActions then
        lEventParms = {iMsg, mouseX, mouseY, getKeyMasks(wParam), 0 }
        if iMsg = WM_MOUSEWHEEL then
            lEventParms[5] = lWheelPosn
        end if
        VOID = invokeHandler(id, w32HMouse,  lEventParms)
        if sequence(VOID) then
            -- If the user returns anything, eat the event.
            lRC = {kMainMsg}
        end if
    end if
    -- Save mouse position and time for click detection.
    if iMsg = WM_LBUTTONDOWN then
        vLMB_id = {id, mouseX, mouseY, time()}
        if ctrl_Type[id] = TabControl then
            call_proc(r_setFocus,{id})
        end if
    end if

    return lRC
end function


----------------------------------------------------
function fDoSize(integer id, atom hWnd, atom iMsg, atom wParam, atom lParam, atom pReturn)
----------------------------------------------------
    integer cx
    integer cy
    sequence lRC
    integer lEraseBG


    lRC = {pReturn}
    -- Sometimes this is received for 'destroyed' controls.
    if validId(id) then
        -- decode parameters
        cx = w32lo_word( lParam )
        cy = w32hi_word( lParam )
        -- resize behavior?
        VOID = invokeHandler(id, w32HResize, {wParam, cx, cy} )
        if sequence(VOID) then
            if (length(VOID) != 1) or (not integer(VOID[1])) then
                lEraseBG = 1
            elsif VOID[1] = 0 then
                lEraseBG = 0
            else
                lEraseBG = 1
            end if
            VOID = w32Func( xInvalidateRect, {getHandle(id), NULL, lEraseBG} )
        end if

        resizeWidgets( id, cx, cy ) -- resize the toolbar and statusbar, if any

    end if
    return lRC
end function

----------------------------------------------------
function fDoBkGndErase(integer id, atom hWnd, atom iMsg, atom wParam, atom lParam, atom pReturn)
----------------------------------------------------
    sequence lRC

    lRC = {kSubclassedMsg}

    if ctrl_Erase[id] != 0 then
        lRC = {kMainMsg}
    end if
    return lRC
end function

----------------------------------------------------
function fDoSetFocus(integer id, atom hWnd, atom iMsg, atom wParam, atom lParam, atom pReturn)
----------------------------------------------------
    sequence lRC
    sequence lProp

    integer lParent
    integer lParentWindow
    integer lTempId


    lRC = {kSubclassedMsg}
    lParent = findParent(id)

    lParentWindow = findParentWindow(id)

    -- Don't bother setting focus to a window that's going down.
    if ctrl_Destroyed[id] != 0 or ctrl_Destroyed[lParentWindow] != 0 then
        return lRC
    end if

    -- Check for special case of a control in a closed window that
    -- gets focus again!
    if (ctrl_Closed[lParentWindow] = 1) or (lParent !=0 and ctrl_Closed[lParent] = 1) then
        if focus_current > 0 and focus_current != id then
            -- Reset focus on the last control that had an explicit set focus.
            setFocus(focus_current)
            return lRC
        end if
    end if

    if and_bits(classAttr[ctrl_Type[id]], w32HasChildren) then
        -- eg. A 'group' type of control. If somebody explictly
        -- sets focus to the group, then set focus to the first
        -- tabable control in that group.
        if length(ctrl_Focus_order[id]) > 0 then
            setFocus( ctrl_Focus_order[id][1] )
            return lRC
        end if

    end if

    -- item to focus on?
    if (id != lParentWindow) and length( ctrl_Focus_order[id]) > 0 then
        -- no focus?

        if ctrl_Previous_focus[id] != 0 and ctrl_Previous_focus[id] != id then
            lTempId = ctrl_Previous_focus[id]
            ctrl_Previous_focus[id] = 0
            if lTempId > 0 then
                id = lTempId
                lParent = findParent(id)
                lParentWindow = findParentWindow(id)
            end if
        end if
        tab_direction( id, 0 ) -- try to focus on item again
    else

        lProp = getUserProperty(id, vCanFocus)
        if (id = lParentWindow) and (length(lProp) = 0 or lProp[1] = w32True) then
            if ctrl_Previous_focus[id] != 0 and ctrl_Family[ctrl_Previous_focus[id]] != WINDOW then
                setFocus(ctrl_Previous_focus[id])
            end if
        else
            if length(lProp) > 0 and lProp[1] = w32True then
                if ctrl_Previous_focus[id] != 0 then
                    setFocus(ctrl_Previous_focus[id])
                else
                    tab_direction(id,2)
                end if
                focus_current = -1
                return lRC
            end if
        end if
    end if

    -- is there a window with modal focus?
    if modalWindow != 0 and
       modalWindow != lParentWindow then
        -- force focus back to the modal one
        w32Proc( xSetFocus, { modalhWnd })
    else
        if lParent != 0 then
            if ctrl_Family[ lParent ] = COMBO then

                ctrl_Current_focus[ ctrl_Parent[ lParent ] ] = id - 1
            else
                ctrl_Current_focus[ lParent ] = id
            end if
        else
            lRC = {kMainMsg}
        end if

        -- Check for autoselect behaviour.
        if find(ctrl_Type[id], {EditText, MleText, RichEdit}) then
            lProp = getUserProperty(id, vAutoSelect)
            if length(lProp) > 0 then
                if lProp[1] = w32True then
                    setIndex(id, {1,0})
                else
                    setIndex(id, getIndex(id))
                end if
            else
                setIndex(id, getIndex(id))
            end if
        end if

        -- call proc?
        VOID = invokeHandler(id, w32HGotFocus, {})

    end if

    focus_current = -1
    return lRC
end function


----------------------------------------------------
function fDoKillFocus(integer id, atom hWnd, atom iMsg, atom wParam, atom lParam, atom pReturn)
----------------------------------------------------
    -- Remember the id that just lost focus.
    integer lParentWindow

    lParentWindow = findParentWindow(id)
    if ctrl_Destroyed[id] = 0 and ctrl_Closed[ lParentWindow ] != 1 then
        ctrl_Previous_focus[id] = ctrl_Current_focus[lParentWindow]
        if id != lParentWindow then
            ctrl_Previous_focus[lParentWindow] = id
        end if

        VOID = invokeHandler(id, w32HLostFocus, {ctrl_Previous_focus[id]})
    end if

    return {kSubclassedMsg} -- Continue with default windows processing.
end function

----------------------------------------------------
function fDoKeys(integer id, atom hWnd, atom iMsg, atom wParam, atom lParam, atom pReturn)
----------------------------------------------------
    integer
        w32event,
        tabdir,
        lIsHotkey,
        lIsTabkey,
        lIsPausekey,
        lNewFocus
    atom
        lKeyMasks

    sequence
        lRC,
        lResult

    object
        lUserReturn

    w32event = 0
    tabdir = 0
    lIsHotkey = w32False
    lIsTabkey = w32False
    lIsPausekey = w32False
    lNewFocus = 0
    lRC = {kSubclassedMsg}

    if wParam = VK_RETURN or wParam = VK_ESCAPE then
        lResult = isHotKey(id, hWnd, iMsg, wParam, lParam, pReturn)
        if lResult[1] = kMainMsg  then -- hotkey detected
            lIsHotkey = w32True
            lRC = {kMainMsg}
        end if

    elsif wParam = VK_PAUSE or wParam = VK_CANCEL then
        lIsPausekey = w32True

    elsif wParam = VK_DOWN and ctrl_Type[id] = TabControl then

        if ctrl_Current_focus[id] != 0 then
            lNewFocus = ctrl_Current_focus[id]
            tabdir = 0
        elsif length(ctrl_Tabitems[id]) > 1 then
            lNewFocus = ctrl_Tabitems[id][1]
            tabdir = 0
        end if
    else
        tabdir = isTabKey( id , wParam)
        if tabdir != 0 then
            lIsTabkey = w32True
            lRC = {kMainMsg} -- Skip default windows processing.
            lNewFocus = id
        end if
    end if


    if iMsg = WM_KEYDOWN then

        if lIsPausekey then

            if getKeyState(VK_CONTROL) then
	            w32event = w32HBreak
            else
	            w32event = w32HPause
            end if
        else
            w32event = w32HKeyDown
        end if

    elsif iMsg = WM_CHAR then
        w32event = w32HKeyPress
        lNewFocus = 0

    elsif iMsg = WM_KEYUP then
        w32event = w32HKeyUp
        lNewFocus = 0

    end if

    if lRC[1] != kMainMsg and w32event != 0 then
        lKeyMasks = getKeyMasks(0)
        lUserReturn = invokeHandler(id, w32event,{ wParam, lKeyMasks } )

        if sequence(lUserReturn) then
            if iMsg = WM_CHAR  then
                if lUserReturn[1] = -1 then
                    -- Ignore this keystroke
                    lRC = {kMainMsg}
                else -- Replace entered key with new one.
                    lRC = {kSubclassedMsg,{hWnd, iMsg, lUserReturn[1],lParam}}
                end if
            elsif iMsg = WM_KEYDOWN then
                if length(lUserReturn) >= 2 then
                    if equal(lUserReturn[1], w32KH_SetFocus) then
                        lNewFocus = lUserReturn[2]
                    end if
                elsif lUserReturn[1] = -1 then
                    -- Ignore this keystroke
                    lRC = {kMainMsg}
                else -- Replace entered key with new one.
                    lRC = {kSubclassedMsg,{hWnd, iMsg, lUserReturn[1],lParam}}
                end if
            end if
        else
            if iMsg = WM_CHAR and wParam = VK_RETURN and lKeyMasks = 0 and ctrl_Type[id] = EditText then
                -- Tab to next field if a ReturnKey pressed in an edit field.
                lNewFocus = id
                tabdir = 1
                lRC = {kMainMsg}
            end if
        end if
    end if

    if lNewFocus != 0 then
        tab_direction(lNewFocus, tabdir)
    end if

    return lRC
end function


----------------------------------------------------
function fDoCommand(integer id, atom hWnd, atom iMsg, atom wParam, atom lParam, atom pReturn)
----------------------------------------------------
sequence lRC
atom lChildId
integer lParent

    lRC = {kSubclassedMsg}
    if (lParam = NULL) then
        -- menu or accelerator?
        if w32hi_word( wParam ) = 1 then
        -- from accelerator;
        -- this should not happen

        -- menu click
        else
            -- get the menu id
            id = w32lo_word( wParam )
            -- update with new id

            VOID = invokeHandler(id, w32HClick, {})
        end if
    else

        lChildId = getId( lParam )
        if lChildId != 0  then
            lParent = findParent( lChildId)
            if ctrl_Type[lParent] = TabItem then
                -- Windows actually believes that the parent of a control
                -- in a TabItem is really the TabControl, so we have to
                -- make that adjustment here.
                lParent = findParent( lParent )
            end if
            if lParent = id  then
                -- notification from control
                wmCommand( lChildId, hWnd, iMsg, wParam, lParam)
                -- Only parent windows stop processing at this point.
                if findParent(id) = 0 then
                    lRC = {kMainMsg}
                end if
            end if
        end if
    end if
    return lRC
end function

----------------------------------------------------
function fDoPaint(integer id, atom hWnd, atom iMsg, atom wParam, atom lParam, atom pReturn)
----------------------------------------------------
atom
   ps,
   hdc
integer pos
sequence
   lUpdateRect,
   lRC

   lRC = {kSubclassedMsg}


   if  onPaint[ id ] >= 0
    or onPaint[Screen] >= 0
    or length(ctrl_Handlers[id][w32HPaint]) > 0
    or length(ctrl_Handlers[Screen][w32HPaint]) > 0
   then -- there is an onPaint routine.
     if find(id, vDuringPaint) then
        -- Already in a paint handler.
        -- So avoid some recursion.
        return lRC
     end if
     vDuringPaint &= id
     ps = w32acquire_mem(0, SIZEOF_PAINTSTRUCT)

     -- begin paint
     hdc = w32Func( xBeginPaint, { hWnd, ps } )

     pos = w32findKey(id, grabbedHDC)
     if pos = 0 then
        grabbedHDC = prepend( grabbedHDC, {id,{1, hdc, 0, kDCReasonPaint}} )
     else
        -- Insert the Paint hdc as the 'topmost' dc.
        grabbedHDC[pos] = {id , {1, hdc, 0, kDCReasonPaint} , grabbedHDC[pos][2]}
     end if

     -- fetch the update rectangle
     lUpdateRect = w32fetch( ps, psPaintRect )

     VOID = invokeHandler(id, w32HPaint, lUpdateRect)

    -- Free up any resources used with this DC
     releaseDC(id)

     -- end of paint
     w32Proc( xEndPaint, { hWnd, ps } )

     -- Free the structure
     w32release_mem( ps )

     vDuringPaint = vDuringPaint[2..length(vDuringPaint)]

     lRC = {kMainMsg}
   end if

   return lRC

end function


----------------------------------------------------
function fDoTimer(integer id, atom hWnd, atom iMsg, atom wParam, atom lParam, atom pReturn)
----------------------------------------------------
    VOID = invokeHandler(id, w32HTimer,{wParam} )
    return {pReturn}
end function


----------------------------------------------------
function fDoSysColorChange(integer id, atom hWnd, atom iMsg, atom wParam, atom lParam, atom pReturn)
----------------------------------------------------
    -- system color changed. force a redraw of the window

    for i = 1 to length(ctrl_Handle) do
        if validId(i) then
            setWindowBackColor(i, ctrl_Bg_Color[i])
            setTextColor(i, ctrl_Font[i][FontColor])
        end if
    end for

    if not w32Func( xInvalidateRect, {hWnd, NULL, -1} ) then
        warnErr( "InvalidateRect in DoSysColorChange failed." )
    end if

    return {pReturn}
end function

----------------------------------------------------
function fDoCtlColor(integer id, atom hWnd, atom iMsg, atom wParam, atom lParam, atom pReturn)
----------------------------------------------------
    integer lParent
    integer lControl
    atom lHDC
    atom lBrush
    object y
    object z

    -- system is about to draw the colors for a control.
    -- this intercepts the command, and returns the brush we want
    lControl = getId(lParam)
    if lControl = 0 then
        -- A Windows managed control, so ignore it.
        return {kMainMsg , -1}
    end if
    lParent = getParent(lControl)

    VOID = w32Func(xSetTextColor, {wParam, colorValue(ctrl_Font[lControl][FontColor])} )
    if not equal(ctrl_Bg_Color[lControl], w32WinDefColor) then
        -- wParam contains the device context of the control
        VOID = w32Func(xSetBkColor,   {wParam, colorValue(ctrl_Bg_Color[lControl])} )
        -- get the background color brush
        return {kMainMsg, ctrl_Bg_Brush[lControl]}
    else
        if and_bits(classAttr[ctrl_Type[lControl]], w32UseSubProc) then
            return {kSubclassedMsg}
        else
            return {kMainMsg,-1}
        end if
    end if
end function


sequence ActiveEL ActiveEL = {}
----------------------------------------------------
global procedure quitWindow(integer id)
----------------------------------------------------
    if validId(id) = w32False then
        return
    end if

    if length(ActiveEL) > 0 then
        ActiveEL[length(ActiveEL)] = 1
    end if
    return

end procedure

----------------------------------------------------
function fDoClose(integer id, atom hWnd, atom iMsg, atom wParam,
	      atom lParam, atom pReturn)
----------------------------------------------------
    integer idStyle, idDepth
    object lUserReturn


    -- Ignore this call if a bad ID supplied.
    if  validId(id) = w32False
     or ctrl_Closed[id] != 0  then
        return {kMainMsg}
    end if

    -- Do not close this window if there is a modal one active,
    -- unless this window is the modal one.
    if   modalWindow != 0
     and modalWindow != id  then
        -- In case the window has been programmatically minimized,
        -- restore it to show the user why the requested window
        -- is not closing.
        if isMinimized( modalWindow) then
            VOID = w32Func( xShowWindow, {modalhWnd, SW_RESTORE} )
        end if
        w32Proc( xSetFocus, {modalhWnd} )
    return {kMainMsg}
    end if

    ctrl_Closed[id] = 2 -- Closing down

    -- Any user defined action?
    if onClose[id] >= 0
    or onClose[Screen] >= 0
    or length(ctrl_Handlers[id][w32HClose]) > 0
    or length(ctrl_Handlers[Screen][w32HClose]) > 0
    then
        lUserReturn = invokeHandler(id, w32HClose, {})
        -- If the user routine returned a non-zero value
        -- do not close this window.
        if   sequence(lUserReturn)
         and (lUserReturn[1] != 0)
        then
            -- undo the closing flag
            ctrl_Closed[id] = 0
            -- Ignore the close request
            return {kMainMsg}
        end if
    end if

    -- close modal grab?
    if modalWindow = id then
        idStyle = modalStyle
        idDepth = modalDepth
        popModal()
    else
        idStyle = Normal
    end if

    -- hide the window if not the primary
    if   id != mainWindow then
        VOID = w32Func( xShowWindow, {hWnd, SW_HIDE} )
        ctrl_Closed[id] = 1
        if idStyle = Dialog then
            if length(ActiveEL) > idDepth then
                quitWindow(id)
            end if
        end if
        return {kMainMsg}
    else

        destroy(id)
        VOID = setMainWindow(0)
        ctrl_Closed[id] = 1

        if vEndAction >= 0 then
            abort(vEndAction)
        end if

    end if

    return {kSubclassedMsg}
end function

----------------------------------------------------
function fDoDestroy(integer id, atom hWnd, atom iMsg, atom wParam, atom lParam, atom pReturn)
----------------------------------------------------

   if mainWindow = id then
       -- close the app
       w32Proc( xPostQuitMessage, { wParam } )
   end if

   return {kSubclassedMsg}
end function

----------------------------------------------------
function fDoTCN_SELCHANGE(integer id, atom hWnd, atom wParam, atom lParam)
----------------------------------------------------
   -- get handle

   hWnd = w32fetch( lParam, NMHDR_hwndFrom )
   -- find the tab control id
   id = getId( hWnd )
   if id != 0 then

       -- get id of selected tab
       id = ctrl_Tabitems[ id ][ w32Func( xSendMessage, {hWnd, TCM_GETCURSEL, 0, 0} ) + 1 ]
       -- activate the tab items for the control
       activateTabItems( id )

       -- is there a click behavior?
       VOID = invokeHandler(id, w32HClick, {})

   end if

   return {kMainMsg}
end function

----------------------------------------------------
function fDoLVN_COLUMNCLICK(integer id, atom hWnd, atom wParam, atom lParam)
----------------------------------------------------
    integer lColumn
    integer lOwner
    integer lDoSort
    integer rtn


    id = getId( w32fetch( lParam, NMHDR_hwndFrom ))
    if id != 0 then
        lColumn = w32fetch( lParam, NMLISTVIEW_iSubItem ) + 1
        lOwner = find( id, lv_id )
        if lOwner != 0 then
            if sequence(lv_properties[lOwner][kLVSortSeq]) then
                if length(lv_properties[lOwner][kLVSortSeq]) >= lColumn then
                    if lv_properties[lOwner][kLVSortSeq][lColumn] = 2 then
                        lv_properties[lOwner][kLVSortSeq][lColumn] = -2
                    elsif lv_properties[lOwner][kLVSortSeq][lColumn] = -2 then
                        lv_properties[lOwner][kLVSortSeq][lColumn] = 2
                    end if
                end if
            else
                if lv_properties[lOwner][kLVSortSeq] = 2 then
                    lv_properties[lOwner][kLVSortSeq] = -2
                elsif lv_properties[lOwner][kLVSortSeq] = -2 then
                    lv_properties[lOwner][kLVSortSeq] = 2
                end if
            end if
        end if

        lv_properties[lOwner][kLVSortCol] = lColumn


        rtn = -1
        if sequence(lv_properties[lOwner][kLVSortRtn]) then
            if length(lv_properties[lOwner][kLVSortRtn]) >= lColumn then
                rtn = lv_properties[lOwner][kLVSortRtn][lColumn]
            end if
        end if

        lDoSort = w32True
        if rtn >= 0 then
            -- Indicate that we are about to start sorting.
            if rtn != r_lvSortitems then
                lDoSort = call_func(rtn, {id, -1, -1, w32LV_StartSorting})
            end if
        end if

        if lDoSort then
            releaseMouse()
            setMousePointer(id, "HOURGLASS")
            VOID = sendMessage( id, LVM_SORTITEMS, id, pfnCompare )
            -- Signal that sorting has stopped.
            if rtn != -1 and rtn != r_lvSortitems then
                VOID = call_func(rtn, {id, -1, -1,  w32LV_EndSorting})
            end if
            setMousePointer(id, "NULL")
        end if
    end if

    return {kMainMsg}
end function

----------------------------------------------------
function fDoLVN_GETDISPINFO(integer id, atom hWnd, atom wParam, atom lParam)
----------------------------------------------------
atom
     lMask
integer
    lSubItem,
    lItem

    id = getId( w32fetch( lParam, NMHDR_hwndFrom ))

    if id != 0 then
        lMask    = w32fetch( lParam, LVDISPINFO_LVITEMmask )
        lSubItem = w32fetch( lParam, LVDISPINFO_LVITEMiSubItem ) + 1
        lItem    = w32fetch( lParam, LVDISPINFO_LVITEMiItem )

        if and_bits(lMask, LVIF_TEXT) then
            -- Indicate that somebody is looking for non-existant text.
            w32store(lParam, LVDISPINFO_LVITEMpszText, -1)
            w32store(lParam, LVDISPINFO_LVITEMcchTextMax, -1)
        end if
    end if

    return {kMainMsg}
end function

----------------------------------------------------
function fDoLVN_BEGINDRAG(integer id, atom hWnd, atom wParam, atom lParam)
----------------------------------------------------

   id = getId( w32fetch( lParam, NMHDR_hwndFrom ))
   if id != 0 then
      vDragData = {id, getLVSelected( id )}
   end if

   IndicateDragging( id, w32True ) -- Change cursor to show drap in progress.

   return {kMainMsg}
end function

----------------------------------------------------
function fDoTVN_BEGINDRAG(integer id, atom hWnd, atom wParam, atom lParam)
----------------------------------------------------

   id = getId( w32fetch( lParam, NMHDR_hwndFrom ))
   if id != 0 then
      vDragData = {id, {getTVIndex( id )}}
   end if
   IndicateDragging( id, w32True ) -- Change cursor to show drap in progress.

   return {kMainMsg}
end function

----------------------------------------------------
function fDoTVN_GETDISPINFO(integer id, atom hWnd, atom wParam, atom lParam)
----------------------------------------------------
atom
     lMask

integer
     lItem


    id    = w32fetch( lParam, TVDISPINFO_TVITEMhItem )
    lItem = find( id, tvitem_handle )

    -- This is called before we get the handle, so if
    -- we haven't filled it in yet, we'll just grab
    -- the first one.
    if lItem = 0
    then
        lItem = find(0, tvitem_handle )
        if lItem = 0 then
            lItem = 1
        end if
    end if

    if lItem <= length(tvitem_data) then
        lMask = w32fetch( lParam, TVDISPINFO_TVITEMmask )


        if and_bits( lMask, TVIF_IMAGE ) then
            w32store( lParam, TVDISPINFO_TVITEMiImage,
                        tvitem_data[lItem][ktv_NormImage] )
        end if

        if and_bits( lMask, TVIF_SELECTEDIMAGE ) then
            w32store( lParam, TVDISPINFO_TVITEMiSelectedImage,
                        tvitem_data[lItem][ktv_SelectImage] )
        end if

        if and_bits( lMask, TVIF_TEXT ) then
            w32store( lParam, TVDISPINFO_TVITEMpszText,
                        tvitem_data[lItem][ktv_TextAddr] )
            w32store( lParam, TVDISPINFO_TVITEMcchTextMax,
                        tvitem_data[lItem][ktv_TextSize] )
        end if
    end if

    return {kMainMsg}
end function

----------------------------------------------------
function fDoTVN_SELCHANGED(integer id, atom hWnd, atom wParam, atom lParam)
----------------------------------------------------

    id = getId( w32fetch(lParam, NMTREEVIEW_NMHDRhwndFrom ) )
    if id != 0 then
        VOID = invokeHandler(id, w32HChange, {w32CHG_Sel, getIndex(id)} )
    end if
    return {kMainMsg}
end function


-- Try to keep from GPF'ing when TreeView is child to something
-- other than a window (ie, TabControl).  This seems to
-- work, but I'm not sure why...
----------------------------------------------------
function fDoTVN_DELETEITEM(integer id, atom hWnd, atom wParam, atom lParam)
----------------------------------------------------
   return {kMainMsg}
end function

----------------------------------------------------
function fDoTTN_GETDISPINFO(integer id, atom hWnd, atom wParam, atom lParam)
----------------------------------------------------
    sequence lText
    atom hFrom
    atom lTextLen

    id = getId( wParam )
    if id = 0 then
        id = w32fetch(lParam, NMHDR_idFrom )
    end if

    if id > 0 and id <= length(ctrl_Hint_Text) then
        if atom(ctrl_Hint_Text[id]) then
            if integer(ctrl_Hint_Text[id]) and ctrl_Hint_Text[id] >= 0 then
                -- The user routine returns either a string or a sequence in
                -- the form of { string, width }, eg. {"Sample text", 120}
                lText = call_func(ctrl_Hint_Text[id], {id, ctrl_Hint_Width[id]})
                if length(lText) = 2 and sequence(lText[1]) and integer(lText[2]) then
                    ctrl_Hint_Width[id] = lText[2]
                    lTextLen = lText[2]
                    lText = lText[1]
                elsif length(lText) = 0 then
                    lTextLen = 0
                else
                    lTextLen = ctrl_Hint_Width[id]
                end if
            else
                lText = sprintf("Invalid routine_id %g", ctrl_Hint_Text[id])
                lTextLen = ctrl_Hint_Width[id]
            end if
        else
            lText = ctrl_Hint_Text[id]
            lTextLen = ctrl_Hint_Width[id]
       end if

        w32store( lParam, NMTTDISPINFO_szText, lText )
        VOID = w32Func(xSendMessage,{w32fetch(lParam, NMHDR_hwndFrom ),
                          TTM_SETMAXTIPWIDTH, 0,
                          lTextLen})

    end if

   return {kMainMsg}
end function

----------------------------------------------------
function fDoMCN_SELCHANGE(integer id, atom hWnd, atom wParam, atom lParam)
----------------------------------------------------
    id = getId( w32fetch(lParam, NMHDR_hwndFrom ) )
    if id != 0 then
        VOID = invokeHandler(id, w32HChange, {} )
    end if

    return {kMainMsg}
end function

----------------------------------------------------
function fDoMCN_SELECT(integer id, atom hWnd, atom wParam, atom lParam)
----------------------------------------------------
    id = getId( w32fetch(lParam, NMHDR_hwndFrom ) )
    if id != 0 then
        VOID = invokeHandler(id, w32HChange, getSelectedDateRange(id) )
    end if
    return {kMainMsg}
end function

----------------------------------------------------
function fDoTBN_GETBUTTONINFO(integer id, atom hWnd, atom wParam, atom lParam)
----------------------------------------------------

   return {kSubclassedMsg, {hWnd, TBN_GETBUTTONINFO, wParam, lParam}}
end function

----------------------------------------------------
function fDoTBN_QUERYINSERT(integer id, atom hWnd, atom wParam, atom lParam)
----------------------------------------------------

   return {kMainMsg, 1}
end function

----------------------------------------------------
function fDoTBN_QUERYDELETE(integer id, atom hWnd, atom wParam, atom lParam)
----------------------------------------------------

   return {kMainMsg, 1}
end function

----------------------------------------------------
function fDoLVN_ITEMCHANGED(integer id, atom hWnd, atom wParam, atom lParam)
----------------------------------------------------
    id = getId( w32fetch( lParam, NMHDR_hwndFrom ))
    if id != 0 then
        VOID = invokeHandler(id, w32HChange, {

                w32fetch( lParam, NMLISTVIEW_iItem)+1,
                w32fetch( lParam, NMLISTVIEW_iSubItem)+1,
                w32fetch( lParam, NMLISTVIEW_uNewState),
                w32fetch( lParam, NMLISTVIEW_uChanged),
                w32fetch( lParam, NMLISTVIEW_ptActionX),
                w32fetch( lParam, NMLISTVIEW_ptActionY),
                w32fetch( lParam, NMLISTVIEW_lParam)

                })
    end if
    return {kMainMsg}
end function


----------------------------------------------------
function fDoNM_CLICK(integer id, atom hWnd, atom wParam, atom lParam)
----------------------------------------------------
    sequence xy
    atom keys
    integer lRealId
    atom lCode

    lRealId = w32fetch( lParam, NMHDR_idFrom )
    if lRealId != 0 then
        lRealId = getId( w32fetch( lParam, NMHDR_hwndFrom ) )
    else
        lRealId = id
    end if
    lCode = w32fetch( lParam, NMHDR_code )
    xy = getPointerRelPos(lRealId)
    keys = getKeyMasks(0)

    VOID = invokeHandler( lRealId, w32HClick, {lCode} )
    VOID = invokeHandler( lRealId, w32HMouse, {WM_LBUTTONUP, xy[1],xy[2], keys} )
    return {kMainMsg}
end function

----------------------------------------------------
function fDoNM_RCLICK(integer id, atom hWnd, atom wParam, atom lParam)
----------------------------------------------------
    sequence xy
    atom keys
    integer lRealId

    lRealId = w32fetch( lParam, NMHDR_idFrom )
    if lRealId != 0 then
        lRealId = getId( w32fetch( lParam, NMHDR_hwndFrom ) )
    else
        lRealId = id
    end if
    xy = getPointerRelPos(lRealId)

    keys = getKeyMasks(0)
    VOID = invokeHandler( lRealId, w32HMouse, {WM_RBUTTONUP, xy[1],xy[2], keys} )
    return {kMainMsg}
end function

----------------------------------------------------
function fDoRBN_HEIGHTCHANGE(integer id, atom hWnd, atom wParam, atom lParam)
----------------------------------------------------
    --integer rebarid

    --rebarid = getId( w32fetch(lParam, NMTREEVIEW_NMHDRhwndFrom ) )
    --VOID = getCtlSize( rebarid )
    --VOID = invokeHandler(Screen, w32HResize, {rebarid, VOID[1], VOID[2]})

    VOID = w32Func( xInvalidateRect, {getHandle(id), NULL, w32True} )
    return {kMainMsg}
end function

sequence vNotifications
vNotifications =
     {
   TCN_SELCHANGE,
   LVN_COLUMNCLICK,
   LVN_GETDISPINFO,
   LVN_BEGINDRAG,
   TVN_BEGINDRAG,
   TVN_GETDISPINFO,
   TVN_SELCHANGED,
   TVN_DELETEITEM,
   TTN_GETDISPINFO,
   MCN_SELCHANGE,
   MCN_SELECT,
   TBN_GETBUTTONINFO,
   TBN_QUERYINSERT,
   TBN_QUERYDELETE,
   LVN_ITEMCHANGED,
   NM_CLICK,
   NM_RCLICK,
   RBN_HEIGHTCHANGE

     }

sequence vNotifyHandlers
vNotifyHandlers =
     {
   routine_id("fDoTCN_SELCHANGE"),
   routine_id("fDoLVN_COLUMNCLICK"),
   routine_id("fDoLVN_GETDISPINFO"),
   routine_id("fDoLVN_BEGINDRAG"),
   routine_id("fDoTVN_BEGINDRAG"),
   routine_id("fDoTVN_GETDISPINFO"),
   routine_id("fDoTVN_SELCHANGED"),
   routine_id("fDoTVN_DELETEITEM"),
   routine_id("fDoTTN_GETDISPINFO"),
   routine_id("fDoMCN_SELCHANGE"),
   routine_id("fDoMCN_SELECT"),
   routine_id("fDoTBN_GETBUTTONINFO"),
   routine_id("fDoTBN_QUERYINSERT"),
   routine_id("fDoTBN_QUERYDELETE"),
   routine_id("fDoLVN_ITEMCHANGED"),
   routine_id("fDoNM_CLICK"),
   routine_id("fDoNM_RCLICK"),
   routine_id("fDoRBN_HEIGHTCHANGE")
     }

----------------------------------------------------
function fDoNotify(integer id, atom hWnd, atom iMsg, atom wParam, atom lParam, atom pReturn)
----------------------------------------------------
    integer
         lNotify, nid
    atom
         lNewMsg
    object
         lResult

    -- lParam contains the notification message header
    lNewMsg = w32fetch( lParam, NMHDR_code )
    lNotify = find(lNewMsg, vNotifications)
    if lNotify = 0 then
        lResult = {kSubclassedMsg} -- Not one of the ones I'm interested in.
        nid = getId( w32fetch( lParam, NMHDR_hwndFrom ))
        VOID = invokeHandler( nid, w32HEvent, {lNotify, wParam, lParam} )
    else
        if vNotifyHandlers[lNotify] != -1 then
            lResult = call_func(vNotifyHandlers[lNotify], {id, hWnd, wParam, lParam})
            if atom(lResult) then
                lResult = {lResult}
            end if
        else
            lResult = {pReturn}
        end if
    end if

    return lResult

end function

--/topic Events
--/func setNotifyHandler(integer pMsg, integer pRtnId)
--/ret INTEGER: The current Routine ID for this notification message.
--/desc Sets a handler for WM_NOTIFY type of messages.
-- /i pMsg is the Notification Message code for which you are setting the
-- handler. /n
-- /i pRtnId is the routine_id() of your function that handles the message.
--
-- Your routine is passed four parameters: /n
--</ul>
--/li /b"integer id" = The ID of the control that is sending the notification.
--/li /b"atom hWnd" = a copy of the hWnd parameter sent by Windows.
--/li /b"atom wParam" = a copy of the wParam parameter sent by Windows.
--/li /b"atom lParam" = a copy of the lParam parameter sent by Windows.
--</ul>
-- and must return either /kSubclassedMsg or /kMainMsg /n
-- /i kSubclassedMsg means that you want the windows processing specific to this class of control to occur for
-- this notification, after your code has finished. A variation is to return {kSubclassedMsg,
-- {hWnd,iMsg,wParam,lParam}} that contain replacement values for the ones originally
-- send through by Windows. /n
-- /i kMainMsg means that you want the Windows default processing to occur, skipping any
-- class specific behaviour. This will
-- send a zero return code back to the Windows from the WM_NOTIFY message. Sometimes
-- however, you may need to specifies a specific return value. In this case you need
-- to return {kMainMsg, retval} in which /i retval must be an integer.
--Example:
--/code
--  sequence alldata
--  integer oldval
--  integer SORT_BY
--  SORT_BY=0
--  alldata = getDataItems()
--
--  function CS_byElement(sequence s1,sequence s2)
--    return compare(s1[SORT_BY],s2[SORT_BY])
--  end function
--
--  constant ByElement=routine_id("CS_byElement")
--
--  function mylvclick(integer id, atom hWnd, atom wParam, atom lParam)
--  integer
--    lColumn,
--    lOwner
--
--    id = getId( w32fetch( lParam, NMHDR_hwndFrom ))
--    if id != 0 then
--        lColumn = w32fetch( lParam, NMLISTVIEW_iSubItem ) + 1
--        SORT_BY=lColumn
--        alldata=custom_sort(ByElement,alldata)
--        VOID = sendMessage(id,WM_SETREDRAW,0,0)
--        loadLVInfo(id, alldata)
--        VOID = sendMessage(id,WM_SETREDRAW,1,0)
--    end if
--
--    return kMainMsg
--  end function
--  oldval = setNotifyHandler( LVN_COLUMNCLICK, routine_id("mylvclick"))
--/endcode

global function setNotifyHandler(integer pMsg, integer pRtnId)
    integer lOldRid
    integer lMsgIndx

    lMsgIndx = find(pMsg, vNotifications)
    if lMsgIndx = 0 then
        vNotifications &= pMsg
        vNotifyHandlers &= pRtnId
        lOldRid = -1
    else
        lOldRid = vNotifyHandlers[lMsgIndx]
        vNotifyHandlers[lMsgIndx] = pRtnId
    end if

    return lOldRid
end function

----------------------------------------------------
function fDoFindReplace(integer id, atom hWnd, atom iMsg, atom wParam, atom lParam, atom pReturn)
----------------------------------------------------
object
   flag,
   range

atom
   lReplacing,
   lRepeating,
   lMustRepeat,
   lNewText


   if ctrl_Type[ id ] = RichEdit
     or
      ctrl_Family[ id ] = EDIT
   then
      flag        = w32fetch( lParam, FINDREPLACE_Flags )
      if (and_bits( flag, FR_REPLACE + FR_REPLACEALL + FR_FINDNEXT) != 0)
      then
     range       = setFindSel( id, flag, lParam )
     lReplacing  = (and_bits( flag, FR_REPLACE + FR_REPLACEALL) != 0)
     lMustRepeat = (and_bits( flag, FR_REPLACEALL) != 0)
     lRepeating  = lReplacing
     if lReplacing then
        lNewText = peek4u( lParam + FINDREPLACE_lpstrReplaceWith[1] )
     end if

     while range and lRepeating do
        lRepeating = lMustRepeat
        VOID = sendMessage( id, EM_REPLACESEL, 1, lNewText)
        if lMustRepeat
        then
           range = setFindSel( id, flag, lParam )
        end if
     end while
      end if
   end if

   return {kSubclassedMsg}
end function

----------------------------------------------------
----------------------------------------------------
sequence vEventsHandled
vEventsHandled = {
    WM_MOUSEMOVE,
    WM_SETFOCUS,
    WM_KILLFOCUS,
    WM_KEYDOWN,
    WM_CHAR,
    WM_KEYUP,
    WM_LBUTTONDOWN,
    WM_RBUTTONDOWN,
    WM_LBUTTONUP,
    WM_RBUTTONUP,
    WM_LBUTTONDBLCLK,
    WM_RBUTTONDBLCLK,
    WM_MOUSEWHEEL,
    WM_SIZE,
    WM_COMMAND,
    WM_DROPFILES,
    WM_PAINT,
    WM_VSCROLL,
    WM_HSCROLL,
    WM_TIMER,
    WM_SYSCOLORCHANGE,
    WM_CTLCOLORBTN,
    WM_CTLCOLORSTATIC,
    WM_CTLCOLOREDIT,
    WM_CTLCOLORLISTBOX,
    WM_CTLCOLORSCROLLBAR,
    WM_CLOSE,
    WM_DESTROY,
    WM_NOTIFY,
    WM_SYSKEYDOWN,
    WM_SYSCHAR,
    WM_ERASEBKGND,
    w32FindReplaceMsg
}
sequence vHandler

vHandler = {
    routine_id("fDoMouse"),
    routine_id("fDoSetFocus"),
    routine_id("fDoKillFocus"),
    routine_id("fDoKeys"),
    routine_id("fDoKeys"),
    routine_id("fDoKeys"),
    routine_id("fDoMouse"),
    routine_id("fDoMouse"),
    routine_id("fDoMouse"),
    routine_id("fDoMouse"),
    routine_id("fDoMouse"),
    routine_id("fDoMouse"),
    routine_id("fDoMouse"),
    routine_id("fDoSize"),
    routine_id("fDoCommand"),
    routine_id("fDoDropFiles"),
    routine_id("fDoPaint"),
    routine_id("fDoScroll"),
    routine_id("fDoScroll"),
    routine_id("fDoTimer"),
    routine_id("fDoSysColorChange"),
    routine_id("fDoCtlColor"),
    routine_id("fDoCtlColor"),
    routine_id("fDoCtlColor"),
    routine_id("fDoCtlColor"),
    routine_id("fDoCtlColor"),
    routine_id("fDoClose"),
    routine_id("fDoDestroy"),
    routine_id("fDoNotify"),
    routine_id("fDoSYSKEY"),
    routine_id("isHotKey"),
    routine_id("fDoBkGndErase"),
    routine_id("fDoFindReplace")
    }

sequence vEventCnt
vEventCnt = repeat(0, length(vHandler))

sequence vUserEventsHandled,
         vUserEventHandlers
vUserEventsHandled = {}
vUserEventHandlers = {}


--/topic Events
--/proc setWinMsgHandler(object id, object pMsg, integer pRtnId)
--/desc Sets a user defined (raw) windows message handler.
--Use this to set up a handler to directly deal with a
--Windows message prior to win32lib processing it.
-- This is really only used by experienced Windows coders as it
-- must deal with all the low-level detail itself. /n
--
-- /i id can be either a single control Id or a list of them. /n
-- /i pMsg can be either a single Windows message code or a list of them.
-- The /i pRtnId is a routine_id of some code of yours which must
-- be a function that receives these parameters ... /n
--<ol>
--/li integer pSource
--/li atom hWnd
--/li atom iMsg
--/li atom wParam
--/li atom lParam
--</ol>
-- The /i pSource parameter is either kMainMsg if this is a subclassed
--control, or kSubclassedMsg if this is a window or non-subclassed control. /n
--If your handler routine returns a sequence then win32lib does not process
-- the message and the first element in the sequence is returned to Windows.
--
-- Note that if /i pRtnId is /b "-1" then this removes a previously set
-- message handler.
--
--
--Example:
--/code
--  function myhandler(integer pSource, atom hWnd, atom iMsg, atom wParam,  atom lParam)
--     if wParam = VK_ENTER then
--       if iMsg = WM_KEYDOWN then
--         ...
--       else -- WM_KEYUP
--         ...
--       end if
--     end if
--     return {0}
--  end function
--  setWinMsgHandler( myFld, {WM_KEYDOWN, WM_KEYUP}, routine_id(myhandler))
--/endcode

global procedure setWinMsgHandler(object pId, object pMsg, integer pRoutine)
    integer lPosn
    integer id
    atom lMsg

    if not sequence(pId) then
        pId = {pId}
    end if
    if not sequence(pMsg) then
        pMsg = {pMsg}
    end if

    for i = 1 to length(pId) do
        id = pId[i]
        for j = 1 to length(pMsg) do
            lMsg = pMsg[j]
            lPosn = find({id, lMsg}, vUserEventsHandled)
            if lPosn = 0 then
                vUserEventsHandled &= {{id, lMsg}}
                vUserEventHandlers &= -1
                lPosn = length(vUserEventsHandled)
            end if

            if pRoutine >= 0 then
                vUserEventHandlers[lPosn] = pRoutine
            else
                vUserEventHandlers = w32removeIndex(lPosn, vUserEventHandlers)
                vUserEventsHandled = w32removeIndex(lPosn, vUserEventsHandled)
            end if
        end for
    end for
end procedure


--/topic Events
--/func setDefaultProcessing(integer NewId)
--/desc This establishes a replacement routine to handle the Windows default processing.
--/ret INTEGER: The previous routine_id for this.
--The Windows Default Processing routine is called whenever a message is received for a control
--that Win32lib does not explicitly handle. Win32lib will pass a number of parameters to
-- this routine. /n
--/li /i "integer id": The win32lib ID for the control. It will be zero if it is not a control
--that was created with win32lib.
--/li /i "integer pSource": A code that indicates the source of the message. It is either kMainMsg or
-- kSubClassedMsg depending on whether it comes from a top-level window or a control within a window
-- respectively.
--/li /i "atom hWnd": The handle to the control.
--/li /i "atom iMsg": The Windows message code.
--/li /i "atom wParam": The first data item for the message code.
--/li /i "atom lParam": The second data item for the message code.
--
--Example:
--/code
--  function MyDefaultProc(integer id, integer pSource, atom hWnd,
--                         atom iMsg, atom wParam, atom lParam)
--      atom lResult
--
--      if (id = 0) or (pSource = kMainMsg) then
--          lResult = w32Func( xDefWindowProc, { hWnd, iMsg, wParam, lParam } )
--      else
--          lResult = w32Func( xCallWindowProc, { mySubProc, hWnd, iMsg, wParam, lParam } )
--      end if
--
--      return lResult
--  end function
--  VOID = setDefaultProcessing(routine_id("MyDefaultProc"))
--/endcode

global function setDefaultProcessing(integer pNewValue)
    sequence vOldVal

    vOldVal = r_defaultProcessing
    r_defaultProcessing = pNewValue
    return vOldVal
end function

-----------------------------------------------------------------------------
function DefProcessing(integer id, integer pSource, atom hWnd, atom iMsg, atom wParam, atom lParam)
-----------------------------------------------------------------------------
    atom lResult

    if (id = 0) or (pSource = kMainMsg) then
        lResult = w32Func( xDefWindowProc, { hWnd, iMsg, wParam, lParam } )
    else
        lResult = w32Func( xCallWindowProc, { ctrl_Function[id], hWnd, iMsg, wParam, lParam } )
    end if

    return lResult
end function
r_defaultProcessing = routine_id("DefProcessing")

-----------------------------------------------------------------------------
function MessageProcessor( integer pSource, atom hWnd, atom iMsg, atom wParam, atom lParam )
-----------------------------------------------------------------------------
    -- callback routine to handle Window class
    -- This routine processes messages sent by Windows
integer
    id,
    lHandledEvent,
    lTemp

object
      result,
      lUserReturn


    -- find the control
    id = getId( hWnd )

    -- not one of mine?
    if id = 0 then
        -- default processing
        return call_func(r_defaultProcessing,{id, pSource, hWnd, iMsg, wParam, lParam })
    end if

    -- Store current message data on stack.
    vWMI += 1
    if vWMI > length(vWinMsg) then
        vWinMsg &= repeat(0, 16)
    end if
    vWinMsg[vWMI] = {pSource, hWnd, iMsg, wParam, lParam}

    lTemp = ctrl_Type[id]
    if (sequence(vControlRID[lTemp]) and (vControlRID[lTemp][kCRID_Process] != -1)) then
        lUserReturn = call_func(vControlRID[lTemp][kCRID_Process], {id, pSource, hWnd, iMsg, wParam, lParam} )
        if sequence(lUserReturn) then
            -- Remove last message from stack
            vWMI -= 1
            -- user supplied a return code, so return to Windows
            return w32iff(length(lUserReturn) > 0, lUserReturn[1], 0)
        end if
    end if

    -- user can process events that Win32Lib doesn't have handlers for.
    if   onEvent[ id ] >= 0
      or onEvent[Screen] >= 0
      or length(ctrl_Handlers[id][w32HEvent]) > 0
      or length(ctrl_Handlers[Screen][w32HEvent]) > 0
    then
        lUserReturn = invokeHandler(id, w32HEvent, {iMsg, wParam, lParam, pSource} )
        if sequence(lUserReturn) then
            -- Remove last message from stack
            vWMI -= 1
            -- user supplied a return code, so return to Windows
            return w32iff(length(lUserReturn) > 0, lUserReturn[1], 0)
        end if

    end if

    lHandledEvent = find({id, iMsg}, vUserEventsHandled)
    if lHandledEvent = 0 then
        lHandledEvent = find({Screen, iMsg}, vUserEventsHandled)
    end if
    if lHandledEvent != 0 then
        lUserReturn = call_func(vUserEventHandlers[lHandledEvent],
            {pSource, hWnd, iMsg, wParam, lParam})
        if sequence(lUserReturn) then
            -- remove last message from stack
            vWMI -= 1
            -- user supplied a return code, so return to Windows
            return w32iff(length(lUserReturn) > 0, lUserReturn[1], 0)
        end if
    end if

    lHandledEvent = find(iMsg, vEventsHandled)
    if lHandledEvent = 0 or
       vHandler[ lHandledEvent ] < 0 then

        ---- Matt Lewis says this fixes some weird bug in windows. ----
        --if ctrl_Type[id] = TabControl and iMsg = WM_NOTIFY then
        --    if w32fetch( lParam, NMHDR_code ) = LVN_DELETEALLITEMS then
        --        vWMI -= 1
        --        return 0
        --    end if
        --end if
        -------------------

        -- Let Windows do the default processing
        result = call_func(r_defaultProcessing,{id, pSource, hWnd, iMsg, wParam, lParam })

    else
        result = call_func(vHandler[ lHandledEvent ], {id, hWnd, iMsg, wParam, lParam, pSource})
        if result[1] = kSubclassedMsg then
            if length(result) = 2 then
            -- the handler has altered the input parameters
                hWnd   = result[2][1]
                iMsg   = result[2][2]
                wParam = result[2][3]
                lParam = result[2][4]
            end if
            result = call_func(r_defaultProcessing,{id, pSource, hWnd, iMsg, wParam, lParam })
        else
            if length(result) > 1 then
                result = result[2]
            else
                result = 0
            end if
        end if

        -- Heuristic Optimisation --
        -- Move frequently used events closer to the start of the list.
        vEventCnt[lHandledEvent] += 1
        if lHandledEvent > 1 and (vEventCnt[lHandledEvent-1]+3 < vEventCnt[lHandledEvent]) then

            lTemp = vEventsHandled[lHandledEvent-1]
            vEventsHandled[lHandledEvent-1] = vEventsHandled[lHandledEvent]
            vEventsHandled[lHandledEvent] = lTemp

            lTemp = vHandler[lHandledEvent-1]
            vHandler[lHandledEvent-1] = vHandler[lHandledEvent]
            vHandler[lHandledEvent] = lTemp

            lTemp = vEventCnt[lHandledEvent-1]
            vEventCnt[lHandledEvent-1] = vEventCnt[lHandledEvent]
            vEventCnt[lHandledEvent] = lTemp
        end if
    end if

    VOID = invokeHandler(id, w32HAfterEvent, {iMsg, wParam, lParam, result} )
    -- remove last message from stack
    vWMI -= 1
    return result

end function


-----------------------------------------------------------------------------
function WndProc( atom hWnd, atom iMsg, atom wParam, atom lParam )
-----------------------------------------------------------------------------
    return MessageProcessor(kMainMsg, hWnd, iMsg, wParam, lParam)
end function

-----------------------------------------------------------------------------
function SubProc( atom hWnd, atom iMsg, atom wParam, atom lParam )
-----------------------------------------------------------------------------
    return MessageProcessor(kSubclassedMsg, hWnd, iMsg, wParam, lParam)
end function

-----------------------------------------------------------------------------
-- store routine id
procedure get_proc_w32address()

    atom id

    -- set WndProcAddress callback
    id = routine_id("WndProc")
    if id = -1 then
        abortErr( Err_WNDPROCNOID)
    end if
    WndProcAddress = call_back( id ) -- get 32-bit address for callback

-- NEW! 0.45l
    -- set SubProcAddress callback
    id = routine_id("SubProc")
    if id = -1 then
        abortErr( Err_SUBPROCNOID)
    end if
    SubProcAddress = call_back( id ) -- get 32-bit address for callback

end procedure

constant vSHOWWORDS = {
    "HIDE",
    "SHOWNORMAL",
    "NORMAL",
    "SHOWMINIMIZED",
    "SHOWMAXIMIZED",
    "MAXIMIZE",
    "SHOWNOACTIVATE",
    "SHOW",
    "MINIMIZE",
    "SHOWMINNOACTIVE",
    "SHOWNA",
    "RESTORE",
    "SHOWDEFAULT",
    "MAX",
    "FULLSCREEN",
    "MODAL",
    "DIALOG"
    }

constant vSHOWCODES = {
    SW_HIDE,
    SW_SHOWNORMAL,
    SW_NORMAL,
    SW_SHOWMINIMIZED,
    SW_SHOWMAXIMIZED,
    SW_MAXIMIZE,
    SW_SHOWNOACTIVATE,
    SW_SHOW,
    SW_MINIMIZE,
    SW_SHOWMINNOACTIVE,
    SW_SHOWNA,
    SW_RESTORE,
    SW_SHOWDEFAULT,
    SW_MAX,
    w32FullScreen,
    Modal,
    Dialog
    }

-----------------------------------------------------------------------------
--/topic Attributes
--/proc showWindow( window, style )
--/desc Shows a window according to the /i style
--/i window is either a control id or the name of a Window control.
--
-- The /i style flag is one of the following:
--/li SW_HIDE = Hides the window and activates another
--/li SW_NORMAL = Restores the window and activates it
--/li SW_SHOWMINIMIZED = Minimizes the window and activates it
--/li SW_SHOWMAXIMIZED = Maximizes the window and activates it
--/li SW_SHOWNOACTIVATE = Displays the window and doesn't activate it
--/li SW_SHOW = Displays the window and activates it
--/li SW_MINIMIZE = Minimizes the window and activates the next window
--/li SW_SHOWMINNOACTIVE = Minimizes the window and doesn't activate it
--/li SW_SHOWNA = Displays the window and doesn't activate it
--/li SW_RESTORE = Restores the window and activates it
--/li SW_MAX = Maximizes the window and doesn't activate it
--/li w32FullScreen = Makes the window appear without title bar and
-- without borders, and the client area fills the entire screen.
--
--Example:
--/code
--      showWindow(formErrors, SW_HIDE)
--      showWindow("Message List", SW_RESTORE)
--/endcode
global procedure showWindow(object id, object style)
    atom hWnd
    sequence lProp
    integer lPosn

    if sequence(id) then
        id = getNameId(id)
    end if

    if validId(id) = w32False then
        return
    end if

    lPosn = find(upper(style), vSHOWWORDS)
    if lPosn > 0 then
        style = vSHOWCODES[lPosn]
    end if

    hWnd = getHandle(id)
    lProp = getUserProperty(id, "w32FullScreen")
    -- display the window
    if equal(style, w32FullScreen) then
        if length(lProp) = 0 then
            lProp = w32Func( xGetWindowLong, { hWnd, GWL_STYLE }) & getRect(id)
            setUserProperty(id, "w32FullScreen", lProp )
            VOID = w32Func( xSetWindowLong,{ hWnd, GWL_STYLE, WS_POPUP })
        end if
        VOID = w32Func( xShowWindow, { hWnd, SW_MAXIMIZE } )

    elsif atom(style) then
        if length(lProp) != 0 then
            VOID = w32Func( xSetWindowLong,{ hWnd, GWL_STYLE, lProp[1][1] })
            setRect(id, lProp[1][2], lProp[1][3],
                        lProp[1][4] - lProp[1][2] - 1,
                        lProp[1][5] - lProp[1][3] - 1, w32True)
            deleteUserProperty(id, "w32FullScreen")
        end if
        VOID = w32Func( xShowWindow, { hWnd, style } )
    end if
    if ctrl_Type[id] = Window then
        w32Proc( xUpdateWindow, { hWnd } )
    end if

end procedure

-----------------------------------------------------------------------------
--/topic Attributes
--/proc openWindow( window, style )
--/desc Opens a window
--/i window is either a control id, a two-element sequence containing
-- {control id, focus id}, or the name of a Window control.
--
-- If /i window is a /b Window then
-- the /i style flag is one of the following:
--
-- /li /b Normal: Original size.
-- /li /b Minimize: Minimized into the task bar.
-- /li /b Maximize: Fills screen.
-- /li /b Modal: Original size, but no other application window can get
--          focus until this window is closed. Use to emulate modal
--          dialogs.
-- /li Win32 Flag: For example, /b SW_SHOWMINNOACTIVE.
--
-- The openWindow function will trigger an /w32HOpen event before it is opened
-- and a /w32HActivate event after it is opened. /n
-- If the w32HOpen event calls /returnValue(-1), the window is not opened.
--
-- It it possible to specify the control that will get the initial
-- focus when the window opens. To do this, the /i window parameter
-- must be specified in the form {window_id, focus_id}. If the /i focus_id
-- is zero, then the first Edit type control is given focus. If there are
-- no edit boxes, then the first button type control is given focus. If
-- you don't specify the initial focus control, then the control that
-- last had focus in the window is used.
--
--Example:
--/code
--      -- Open the Login window, giving focus to the User ID field.
--      openWindow({formLogin txtUserId}, Normal)
--
--      -- Open the Messages window.
--      openWindow("Message List", Normal)
--
--      -- Open an input form
--      openWindow(vPromptCust,
--               {"Name","~<unknown>"}
--              )
--/endcode

global procedure openWindow( object id, object style )

    atom hWnd
    object styleFlag
    object lFocus
    sequence lRBSize
    sequence lRect
    sequence lID
    object lRC
    integer lPosn
    sequence lInitView

    -- Avoid using this routine if app has ended.
    if vWinMainState = kFinished then
        return
    end if

    if sequence(id) then
        if length(id) = 2 then
            lFocus = id[2]
            id = id[1]
        else
            id = getNameId(id)
            if length(ctrl_Focus_order[id]) > 0 then
                lFocus = ctrl_Focus_order[id][1]
            else
                lFocus = -1
            end if
        end if
    else
        lFocus = -1
    end if

    if    validId(id) = w32False then
        return
    end if

    if ctrl_Type[id] = Window then

        -- action?
        lRC = invokeHandler(id, w32HOpen, {})
        if equal(lRC, {-1}) then
            -- Ignore this open request.
            return
        end if

        lInitView = getUserProperty(id, "w32InitView")
        if length(lInitView) > 0 then
            style = lInitView[1]
            deleteUserProperty(id, "w32InitView")
        end if

        lPosn = find(upper(style), vSHOWWORDS)
        if lPosn > 0 then
            style = vSHOWCODES[lPosn]
        end if
        if   equal(style, Modal)
          or equal(style, Dialog)  then
            -- Make sure we can't minimize a modal window.
            removeStyle(id, WS_MINIMIZEBOX)
        end if

        -- get the handle
        hWnd = getHandle( id )

        -- convert the parameter to a Win32 flag
        if integer(style) then
            if style > 0 then
                -- real flag
                styleFlag = style
            else
                -- Normal or Modal
                if isMinimized( id) then
                    styleFlag = SW_RESTORE
                else
                    styleFlag = SW_SHOWNORMAL
                end if
            end if
        else
            styleFlag = style
        end if

        -- need to show menubar?
        if ctrl_Menu[ id ] then
            VOID = w32Func( xDrawMenuBar, {hWnd} )
        end if

        -- displaying any tab controls?
        for i = 1 to length( ctrl_Parent ) do
            if  ctrl_Parent[ i ] = id              -- control owned by window
            and ctrl_Type[ i ] = TabControl       -- is a tab control
            and length( ctrl_Tabitems[i] ) then   -- contains tabs
                -- activate the current tab's items
                activateTabItems( getTabItem(i) )
            end if
        end for

        -- display the window
        if atom(styleFlag) then
            VOID = w32Func( xShowWindow, { hWnd, styleFlag } )
        else
            showWindow(id, styleFlag)
        end if

        ctrl_Closed[id] = 0

        -- update the window
        VOID = w32Func( xInvalidateRect, {hWnd, NULL, w32True} )
        w32Proc( xUpdateWindow, { hWnd } )


        -- If this is a "modal" style open, and the window is not already
        -- on the modal stack, save previous modal windows and set this one
        -- as the current modal window.
        if   (equal(style, Modal)
          or equal(style, Dialog))
          and modalWindow != id
          and w32findKey( id, modalStack) = 0  then
            pushModal( id , hWnd, style, length(ActiveEL))
        end if

        -- set focus to the window.
        w32Proc( xSetFocus, {hWnd} )
        -- Check if I'm supposed to set focus to a particular control.
        if lFocus >= 0 then

            if lFocus = 0 then
                for i = 1 to length(ctrl_Focus_order[id]) do
                    if find(ctrl_Type[ctrl_Focus_order[id][i]], {EditBox, MleText}) then
                        lFocus = ctrl_Focus_order[id][i]
                        exit
                    end if
                end for
                if lFocus = 0 then
                    for i = 1 to length(ctrl_Focus_order[id]) do
                        if ctrl_Family[ctrl_Focus_order[id][i]] = BUTTON then
                            lFocus = ctrl_Focus_order[id][i]
                            exit
                        end if
                    end for
                end if
                if lFocus = 0 then
                    for i = 1 to length(ctrl_Focus_order[id]) do
                        if ctrl_Family[ctrl_Focus_order[id][i]] = COMBO then
                            lFocus = ctrl_Focus_order[id][i]
                            exit
                        end if
                    end for
                end if
            end if
            if lFocus > 0 then
                setFocus(lFocus)
            end if
        end if

        -- Save initial control positions if there is any toolbars.
        if AutoReBarSizing and ctrl_Toolbar[id] > 0 and ctrl_Type[ctrl_Toolbar[id]] = ReBar then
            lRBSize = getCtlSize(ctrl_Toolbar[id])

            lID = findChildren(id)
            for i = 1 to length(lID) do
                if  lID[i][1] != ctrl_Toolbar[id] and
                   not find(lID[i][2], { ReBar, ReBarBand, StatusBar,Menu,Popup,MenuItem,MenuSpacer,Pixmap}) then
                    lRect = getRect(lID[i][1])
                    lRect[3] -= lRect[1]
                    lRect[4] -= lRect[2]
                    lRect[2] -= lRBSize[2]
                    ctrl_Init_Posns[ctrl_Toolbar[id]][1] &= lID[i][1]
                    ctrl_Init_Posns[ctrl_Toolbar[id]][2] &= {lRect}
                end if
            end for
        end if

        -- Now tell the app that we are ready for business.
        VOID = invokeHandler(id, w32HActivate, {})

    end if
end procedure
r_openWindow = routine_id("openWindow")



--/topic Attributes
--/proc centerControl( integer Id, integer RefId)
--/desc Centers /i Id with respect to /i RefId
--
--Example:
--/code
--      centerControl(CustDialog, Screen)
--      centerControl(BtnX, CustDialog)
--/endcode

global procedure centerControl(integer pId, integer pRefId)
    alignControls(pId, {w32VertCentre,w32HorzCentre}, {pRefId} )
end procedure

integer vIdleCheck
vIdleCheck = 0

---------------------------------------
--/topic Events
--/func setIdle(integer newvalue)
--/ret INTEGER: CurrentValue
--/desc Sets whether or not the library implements w32HIdle
--/i newvalue is either w32True or w32False /n
--The initial setting is w32False, meaning that w32HIdle is not invoked
-- when the application is idling. To start having this handler invoked,
-- you need to setIdle(w32True).
--
--example
--/code
--  integer x
--  x = setIdle(w32True)
--/endcode
global function setIdle(integer pNewValue)
    integer vOldVal

    vOldVal = vIdleCheck
    vIdleCheck = (pNewValue != 0)

    return vOldVal
end function

--/topic Events
--/func setEventLoop(integer NewId, object UserData)
--/desc This establishes an replacement event loop.
--/ret SEQUENCE: The previously set values = {message handler routine id, user data}
--There may be situations in which the Windows Message handler loop, built into Win32lib,
--is not adequate for your needs. If so, you can call this function to supply an alternative
--message handler.
--
--/i NewId is the routine_id of your routine that will be called by Win32lib to process
-- Windows Messages.
--
--/i UserData can be anything. It is passed back to your routine by Win32lib on each call.
--Win32lib does not alter it at anytime.
--
--Win32lib calls the message handler from within the /MainWin() routine to begin processing
-- messages received from Windows. It also calls it when you use /openDialog(). The replacement
--message handler will receive the /i UserData value every time it is called by Win32lib. /n
--
--Example:
--/code
--  integer OldHandler
--  procedure myMsgHandler(sequence Parms)
--     . . . your code goes here . . .
--  end procedure
--  OldHandler = setEventLoop( routine_id("myMsgHandler"), {})
--/endcode
object vELUserData vELUserData = {} -- Used internally as parameters when calling eventLoop.

global function setEventLoop(integer pNewValue, object pUserData)
    sequence vOldVal

    vOldVal = {r_eventLoop, vELUserData}
    r_eventLoop = pNewValue
    vELUserData = pUserData

    return vOldVal
end function

procedure eventLoop(object pData)
    sequence temp
    atom msg
    atom getRC
    integer inc
    integer el
    integer lTock

    ActiveEL &= 0
    el = length(ActiveEL)

    -- Allocate a message buffer
    msg = w32acquire_mem(0, SIZEOF_MSG)
    lTock = 0
    -- message loop
    while ActiveEL[el] = 0
      and vWinMainState = kStarted do

        if vIdleCheck then
            while w32Func(xGetQueueStatus, {QS_ALLEVENTS}) = 0 do
                lTock += 1
                if sequence(invokeHandler(Screen, w32HIdle, {lTock, msg})) then
                    -- The user wishes to stop being idle and instead
                    -- use the data they have loaded into the msg structure.
                    lTock = -2
                    exit
                end if
            end while

            if lTock >= 0 then

                getRC = w32Func( xPeekMessage, { msg, 0, 0, 0, PM_REMOVE } )
                if getRC > 0 and peek4u(msg+4) = WM_QUIT then
                    exit
                end if
                -- I've decided to ignore the undocumented windows message WM_SYSTIMER ('280')
                -- so it won't stop the idling tock counting.
                if lTock > 0 and peek4u(msg+4) != WM_SYSTIMER then
                    -- Signal end of idleness period.
                    VOID = invokeHandler(Screen, w32HIdle, {-1, msg})
                    lTock = 0
                end if
            else
                lTock = 0
            end if

        else
            getRC = w32Func( xGetMessage, { msg, 0, 0, 0 } )
            if  getRC = 0
             or getRC = -1 then
                exit
            end if
        end if

        -- Gather some entropy for the random integer routine
        w32Seed = remainder((w32Seed * peek4u(msg+16))
                            + 1 + peek4u(msg+20) * peek4u(msg+24),
                            #FFFFFFFF)

        w32Proc( xTranslateMessage, { msg } )
        w32Proc( xDispatchMessage, { msg } )
    end while

    w32release_mem(msg)
    ActiveEL = ActiveEL[ 1 .. length(ActiveEL) - 1]

end procedure
r_eventLoop = routine_id("eventLoop")

--/topic Events
--/proc doEvents(integer id)
--/desc Gives control back to windows until there are no pending events to process.
-- /i id is usually zero, meaning that events for all controls are processed,
-- however you can limit this to a particular control by supplying it id.
--
-- Typically this is used inside user written event handlers when they know
-- that they might take a long time to complete. For example, if by clicking
-- a button the application must scan through all the files on a disk, it
-- would be appropriate to include a doEvents() call inside the inner loop
-- so that other windows events can be processed during the file search. If
-- this isn't done, no control or window belonging to the application will
-- respond until the disk scan is conpleted. For example, there might be
-- another button that the user can click to abort the disk scan. Without
-- doEvents() this would only respond after the disk scan is completed!
global procedure doEvents(integer id)
    atom msg, hWnd

    if vWinMainState != kStarted then
    return
    end if

    if id = 0 then
    hWnd = 0
    else
    if validId(id) = w32False then
        return
    end if
    hWnd = getHandle(id)
    end if

    -- Allocate a message buffer
    msg = w32acquire_mem(0, SIZEOF_MSG)

    if w32Func( xPeekMessage, { msg, hWnd, 0, 0, PM_REMOVE } ) then
        w32Proc( xTranslateMessage, { msg } )
        w32Proc( xDispatchMessage, { msg } )
    end if
    w32release_mem(msg)

end procedure
r_doEvents = routine_id("doEvents")

-----------------------------------------------------------------------------
--/topic Attributes
--/proc openDialog( object id )
--/desc Opens a window, /i id, as a modal dialog.
--The /i id is either a control id, a two-element sequence containing
-- {control id, focus id}.
--
---There is a difference between this and /openWindow(..., Modal).
-- Here's some examples.... /n
--
--/code
--    while length(filename) = 0 do
--        openWindow(myFileDialog, Modal)
--    end for
--/endcode
--and /n
--/code
--    while length(filename) = 0 do
--        openDialog(myFileDialog)
--    end for
--/endcode
--
--In the first snippet, this would start a very tight loop in which the user
--could not enter data. This is because the /openWindow() would execute
--and /b not wait for the user to enter any data into the new window before
--executing the /i while test again. Whereas the openDialog() routine opens
-- a modal window then /b waits for that window to close before executing
--the line after the openDialog() statement. During this time, any event
--handlers set up for the dialog window would still fire correctly.

global procedure openDialog(object id)

    integer lFocus

    lFocus = -1
    if sequence(id) then
        lFocus = id[2]
        id = id[1]
    end if

    if validId(id) = w32False or ctrl_Type[ id ] != Window then
        return
    end if

    if lFocus != -1 then
        openWindow({id,lFocus}, Dialog)
    else
        openWindow(id, Dialog)
    end if
    call_proc(r_eventLoop,{vELUserData})
    closeWindow(id)

end procedure
r_openDialog = routine_id("openDialog")

function DetermineMainWindow()
    integer id

    if ctrl_Type[3] = Window then
        -- If its a window, then this becomes the main window.
        id = 3
    else
        -- otherwise search for the first created window.
        id = 0
        for i = length(ctrl_Type) to 4 by -1 do
            if ctrl_Type[i] = Window then
                id = i
                exit
            end if
        end for

        -- Don't do anything if there is no window.
    end if
    return id
end function

-----------------------------------------------------------------------------
--/topic System Attributes
--/proc WinMain( window, style )
--/desc Run event loop.
-- This is the main processing loop for Win32Lib. Call WinMain after
-- all the controls and their handlers have been defined for the initial
-- running of the application.
--
-- The main window is set to /i window. When /i window is closed,
-- the application is shut down. /b Note that if /i window is -1 then
-- the first window defined is used as the primary window.
--
-- If you wish to have an application that has /b no window under the
-- control of win32lib, but still wish to use its Windows Message loop,
-- then set /i window as 0.
--
-- The /i style flag is one of the following:
--
-- /li /b Normal: Original size.
-- /li /b Minimized: Minimized into the task bar.
-- /li /b Maximized: Fills the client area of the screen.
--
-- The WinMain function will open the application's main window.
--
-- It it possible to specify the control that will get the initial
-- focus when the window opens. See /openWIndow for details.
--
-- For example:
--/code
--      -- set MyWindow as main window, open normally
--      -- with the initial focus on the Login button.
--      /WinMain( {MyWindow, btnLogin}, Normal )
--/endcode

global procedure WinMain( object id, integer style )
    integer lInitFocus
    object lRtnId
    sequence lEventName
    sequence lInitView


    -- Don't rerun this once it has finished.
    if vWinMainState != kNotStarted then
        return
    end if
    vWinMainState = kStarted

    if sequence(id) then
        lInitFocus = id[2]
        id = id[1]
    else
        lInitFocus = -1
    end if
    -- create the default window
    if id = -1 then
        id = DetermineMainWindow()
    end if

    VOID = setMainWindow(id)
    pushSelf(id)

    -- Time to resolve any deferred event handler references.
    if r_AppCallback >= 0 then
        for i = 1 to length(ctrl_Deferred_Handlers) do
            if sequence(ctrl_Deferred_Handlers[i]) and length(ctrl_Deferred_Handlers[i]) > 0 then
                ResolveDeferredHandler(i)
            end if
        end for
    end if

    -- Automatically initialize all control sets as hidden.
    if length(vControlSets) > 0 then
        hideControlSet(0)
        showControlSet(1)
    end if

    openWindow( {id,lInitFocus}, style )

    -- Start processing the message events.
    call_proc(r_eventLoop, {vELUserData})

    -- release all resources
    if id != 0 then
        releaseAllResources(0)
    end if
end procedure

global constant w32NoCallBack = -1

--/topic Events
--/proc startApp(object CallbackRtns)
--/desc Start the application running.
--This opens the main window, setting focus on the first 'focusable' control
-- and then handles over control to Windows.
--
--The /i CallbackRtn parameter is either a single routine_id or a list of three routine_ids. /n
-- If it is a single routine_id is can be either /w32NoCallBack or the routine id
-- of a callback routine inside your application. See /setCallback for more
-- details.
--
-- If /i CallbackRtns is a list of three routine_ids, it takes the format of ... /n
-- /li integer AppCallback: Same as the single routine_id version above.
-- /li integer AlternateCAllback: If /i AppCallback is -1 then this is used instead.
-- /li integer AppMain: Either -1, or a routine_id of a routine that is called prior
-- to the library start up. The /i AppMain routine is passed a single sequence, which
-- is the command_line() parameters. If /i AppMain returns a zero then the library
-- continues executing otherwise the library stops immediately.
--
--Example:
--/code
--  startApp({routine_id("AppCallback"), routine_id("LocalCallback"), routine_id("AppMain")})
--/endcode

global procedure startApp(object pCallBack_rid)
    integer id
    sequence lKids
    sequence lProp
    integer lCallBack_rid
    integer lAltCallBack_rid
    integer lMain_rid

    if atom(pCallBack_rid) then
        lCallBack_rid = pCallBack_rid
        lAltCallBack_rid = -1
        lMain_rid = -1
    else
        lCallBack_rid = pCallBack_rid[1]
        lAltCallBack_rid = pCallBack_rid[2]
        lMain_rid = pCallBack_rid[3]
    end if

    if lMain_rid >= 0 then
        if call_func(lMain_rid, {command_line()}) != 0 then
            return
        end if
    end if

    if length(ctrl_Type) < 3 then
        -- There is no Main Window defined,
        return
    end if

    if lCallBack_rid >= 0 then
        VOID = setCallback( lCallBack_rid )
    else
        VOID = setCallback( lAltCallBack_rid )
    end if

    -- Check the first Control created after the Screen and Printer.
    if mainWindow = 0 then
        id = DetermineMainWindow()
        if id = 0 then
            return
        end if

    else
        id = mainWindow
    end if

    -- If the window has any focusable children, select the first one.
    lProp = getUserProperty(id, "w32initfocus")
    if length(lProp) != 0 then
        WinMain({id, lProp[1]}, Normal)

    elsif length(ctrl_Focus_order[id]) > 0 then
        WinMain({id, ctrl_Focus_order[id][1]}, Normal)

    else
        WinMain(id, Normal)

    end if
end procedure

--/topic Events
--/proc closeApp()
--/desc Closes the application down.
-- You can set a handler to trap the close of the main window if you
-- have any last minute activites to do, such as closing databases, etc...
--
--Example:
--/code
--      procedure Click_CloseBtn(integer self, integer event, sequence parms)
--          if message_box("Is it okay to stop now?", "Close", MB_YESNO) = IDYES
--              closeApp()
--          end if
--      end procedure
--      setHandler(CloseBtn, w32HClick, routine_id("Click_CloseBtn"))
--
--/endcode
global procedure closeApp()
    if mainWindow != 0 then
        closeWindow(mainWindow)
    end if
end procedure


-----------------------------------------------------------------------------
--/topic Utilities
--/func struct_TOOLINFO(uFlags, hwnd, uId, rect, text )
global function struct_TOOLINFO( atom uFlags, atom hwnd, atom uId,
    sequence rect, object text )
    atom ti

    ti = w32acquire_mem(0,  SIZEOF_TOOLINFO - 4 )
    w32store( ti, TOOLINFO_cbSize, SIZEOF_TOOLINFO )
    w32store( ti, TOOLINFO_uFlags, uFlags )
    w32store( ti, TOOLINFO_hwnd, hwnd )
    w32store( ti, TOOLINFO_uId, uId )
    w32store( ti, TOOLINFO_rectLeft, rect[1] )
    w32store( ti, TOOLINFO_rectTop, rect[2] )
    w32store( ti, TOOLINFO_rectRight, rect[3] )
    w32store( ti, TOOLINFO_rectBottom, rect[4] )
    w32store( ti, TOOLINFO_lpszText,  text )

    return ti

end function

--/topic Attributes
--/proc setHintEx( object control, object text, atom exflags )
--/desc Set the tooltip text for a control.
-- This is identical to /setHint() except that you can use extra flags
-- when creating the tooltip for a control.
--
-- Example:
--/code
--      -- set hint for CloseButton
--      /setHintEx( CloseButton, "Closes the window", TTF_CENTERTIP )
--/endcode

global procedure setHintEx( object id, object text, atom exflags )
    atom
       ti,
       lTTflags,
       lTTmsg

    sequence rect
    integer parentId
    integer lPart

    lPart = 0
    if sequence(id) then
        if length(id) = 2 then
            lPart = id[2]
            id = id[1]
            if validId(id) = w32False
            then
               return
            end if
            if ctrl_Type[id] != StatusBar then
                return
            end if
            if atom(text) then
                text = sprintf("routine_id %g not supported.", text)
            end if
            VOID = sendMessage(id, SB_SETTIPTEXT, lPart, text)
        end if
        return
    end if

   -- Doesn't hurt to check.
   if validId(id) = w32False
   then
      return
   end if

    -- Special code to set replicate the hint in a Combo's edit area.
    ti = getEdit(id)
    if ti then -- I own an edit area.
        setHintEx( ti, text, exflags )
    end if

    parentId = findParent(id)
    if parentId = 0 then -- Use myself if I'm the top-level window.
        parentId = id
    end if

    ctrl_Hint_Text[id] = text

    -- First time thru, create the tooltip control to manage hints.
    if not tooltipControl then
        tooltipControl = createEx( ToolTip, "", 0, 0, 0, 0, 0, 0, 0)
    end if


    if atom(text) or length( text )  then  -- adding a tip
        lTTflags = w32or_all( {TTF_SUBCLASS, TTF_IDISHWND, exflags})
        lTTmsg   =  TTM_ADDTOOL

    else  -- deleting a tip
        lTTflags = 0
        lTTmsg   = TTM_DELTOOL

    end if

    ti = struct_TOOLINFO(
             lTTflags,
             ctrl_Handle[ parentId ],
             ctrl_Handle[id],
             {0,0,0,0},
             LPSTR_TEXTCALLBACK -- text
             )

    VOID = sendMessage( tooltipControl, lTTmsg, 0, ti )
    VOID = sendMessage( tooltipControl, TTM_SETMAXTIPWIDTH, 0,
                            ctrl_Hint_Width[id])
    w32release_mem( ti )
end procedure
r_setHintEx = routine_id("setHintEx")

--/topic System Attributes
--/func manageToolTip( integer pAction, integer pNewControl)
--/desc Helps manage the ToolTip controls.
--/ret The current tooltip control id.
-- Use this to activate or deactivate the current tooltip control, or
-- to just get the id of the current tooltip control.
--
-- Set /i pAction to /b 1 to activate tooltips or /b 0 to deactivate them.
-- Any other value has no effect. /n
-- In all cases, the id of the current tooltip control is returned.
global function manageToolTip( integer pAction, integer pNewControl)
integer
     lOldToolTip

   lOldToolTip = tooltipControl

   -- See if a new control needs to be installed.
   if pNewControl > 0
     and
      ctrl_Family[pNewControl] = ToolTip
   then
      VOID = sendMessage( tooltipControl, TTM_ACTIVATE, 0, 0 )
      tooltipControl = pNewControl
      VOID = sendMessage( tooltipControl, TTM_ACTIVATE, 1, 0 )
   end if

   -- Activate/Deactivate the current tooltip control.
   if pAction = 1
   then
      VOID = sendMessage( tooltipControl, TTM_ACTIVATE, 1, 0 )
   elsif pAction = 0
   then
      VOID = sendMessage( tooltipControl, TTM_ACTIVATE, 0, 0 )
   end if

   return lOldToolTip

end function

--/topic Attributes
--/proc setHint( object control, object text )
--/desc Set the tooltip text for a control.
-- If the mouse stays still over a control that has tooltip text
-- associated with it, a small window displaying the tooltip text will
-- appear.
--
-- Any control that can get mouse events can have tooltips associated with
-- it, although it tends to work best with /PictureButtons, typically
-- in the /ToolBar.
--
-- Setting the text to "" effectively removes the tooltip.
--
-- /b Note: When setting tooltips for multipanelled StatusBar controls,
-- you need to specify which panel the tip applies to. You do this by
-- setting the /i control parameter as a sequence in the form {id, panel}
-- where /i id is the StatusBar control and /i panel is the panel number.
--
-- It is possible to dynamically set the text of a tooltip so that each time
-- the control needs to display a tip, it first calls a routine of your own
-- that must supply the text to display. To do this, set the /i text parameter
-- to the routine_id of your function. Your /b function will receive two parameters:
-- ( id, width ) where /i id is the control that needs a tip, and /i width is the
-- width of the tooltip box that will be used (in pixels). Your function must
-- return a /b sequence. That sequence can simply be the tip text, or a 2-element
-- sequence in the form { tiptext, newwidth }.
--
-- Example:
--/code
--      -- set hint for CloseButton
--      setHint( CloseButton, "Closes the window" )
--
--      function gettip( integer id, integer width)
--         sequence newtext
--         sequence AccountRecord
--
--         AccountRecord = getAccountFromName(getText(id))
--         if length(AccountRecord) > 0 then
--             newtext = sprintf("Account %d has a balance of %12.2f",
--                                {AccountRecord[fAcctNo],
--                                 AccountRecord[fCurBal]})
--         else
--             newtext = "No account found for this name."
--         end if
--         return newtext
--      end function
--      setHint( txtAccountName, routine_id("gettip") )
--/endcode


global procedure setHint( object id, object text )
   setHintEx(id, text, 0)
end procedure

--/topic Attributes
--/func getHint(integer id)
--/desc Find the hint text for a control, or the caption for a flattoolbar button
--/ret Any Tool Tip text associated with this /i id
global function getHint( integer id )
    return ctrl_Hint_Text[id]
end function


--/topic Attributes
--/func setHintWidth(integer id, integer width)
--/desc Sets the maximum width, in pixels, of the control's tooltip box.
--/ret INTEGER: Current width setting.
global function setHintWidth( integer id, integer width )
    integer lWidth

    lWidth = ctrl_Hint_Width[id]

    ctrl_Hint_Width[id] = w32iff(width > 0, width, 0)

    return lWidth
end function

--/topic Utilities
--/func hitTestTT()
--/desc Tests to see if the mouse is currently over a control that has a tooltip.
--/ret w32False or the id of a control.
global function hitTestTT( )
    atom ht, ok, tools, ti
    integer id,parentId
    sequence pt, op, mouse

    ht = w32acquire_mem(0, SIZEOF_TTHITTESTINFO )
    ti = ht + TTHITTESTINFO_ti[1]

    mouse = getPointerPos( )

    tools = sendMessage( tooltipControl, TTM_GETTOOLCOUNT, 0, 0 )

    id = 1
    ok = 0
    for i = 1 to tools do
      -- only look at Ids that have some tooltip text.
    while not length( ctrl_Hint_Text[id] ) do
        id += 1
    end while

    -- get its parent. NB, Top-level controls are their own parent.
    parentId = ctrl_Parent[id]
    if parentId = 0
    then
     parentId = id
    end if

    w32store( ht, TTHITTESTINFO_hwnd, ctrl_Handle[parentId] )

    op = getClientPoint( parentId, 0, 0 )
    pt = mouse - op

    w32store( ht, TTHITTESTINFO_ptX, pt[1] )
    w32store( ht, TTHITTESTINFO_ptY, pt[2] )

    ok = sendMessage( tooltipControl, TTM_HITTEST, 0, ht )

    if ok then
        ok = w32fetch( ht + TTHITTESTINFO_ti[1], TOOLINFO_uId )
        exit
    end if

    id += 1
    end for


    w32release_mem( ht )

    return ok

end function


-----------------------------------------------------------------------------
-----------------------------------------------------------------------------

integer xpmErrFlag          -- on error, sets code

global constant
    XPM_OK          = 0,    -- no error
    XPM_ERR_FILE    = -1,   -- file related error
    XPM_ERR_COLORS  = -2,   -- too many colors in bitmap
    XPM_ERR_HEADER  = -3,   -- error in XPM header
    XPM_ERR_COLOR   = -4    -- couldn't translate color code

constant XPM_CODES =
    " .+@#$%&*=-;>,')!~{]^/(_:<[}|1234567890" &
    "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ"

-----------------------------------------------------------------------------
--/topic XPM
--/proc setTransparentColor( object color )
--/desc Defines what the transparent color is to be.
-- The /i color can be an rgb atom, or a sequence in the form {r,g,b}.
--
-- The default color is {255,0,255} (a light pink).
--
-- For routines that create XPMs, this means that the color specified
-- in the XPM as /i None are rendered using this color.
--
-- The /transBlt routine uses this value to determine what color /i not
-- to render on the destination.
--
-- This routine can also be used to make the transparent color of XPMs
-- match the system color of buttons. This is useful for /PictureButtons.
--
--/code
--          -- set transparent colors to match button face color
--          setTransparentColor( /getSysColor( COLOR_BTNFACE ) )
--/endcode

global procedure setTransparentColor( object pColor )
    transColor = colorValue( pColor )
    transTuple = split_rgb( transColor )
end procedure

-- set default transparent color
setTransparentColor( BrightMagenta )

-- NEW! 0.42
------------------------------------------------------------------------------
--/topic XPM
--/func createXpm( filename, euphoria bitmap )
--/desc Creates an XPM file from a Euphoria bitmap.
--/ret Status code.
-- Status codes:
--
-- /li /b XPM_OK. File created successfully
-- /li /b XPM_ERR_FILE: File related error
-- /li /b XPM_ERR_COLORS: Too many colors in bitmap


global function createXpm( sequence outFile, sequence euBmp )

    -- create an XPM file from a euphoria bitmap
    integer
    handle,     -- out file handle
    index,      -- convenience counter
    colors,     -- count of colors used in XPM
    charsWide,  -- chars wide of encoding
    at          -- index
    sequence
    bmp,        -- bitmap portion of data
    pal,        -- pal portion of data
    code,       -- reassignment of codes to palette indexes
    encode      -- encoding of color codes

    -- get values
    pal = euBmp[1]
    bmp = euBmp[2]

    -- build a set of 'used' flags for the palette
    code = repeat( 0, length( pal ) )

    -- scan through the bitmap, and
    colors = 0
    for i = 1 to length( bmp ) do
    for j = 1 to length( bmp[i] )  do

        -- get palette index
        index = bmp[i][j]+1

        -- already assigned an index?
        if not code[ index ] then

	    -- increment index count
	    colors = colors + 1

	    -- assign an index
	    code[ index ] = colors

        end if
    end for
    end for

    -- need 1 or 2 byte codes?
    if colors > length( XPM_CODES ) then

    -- need to construct 2 byte codes
    charsWide = 2

    -- initialize sequence
    encode = repeat( 0, colors )

    -- index
    at = 1

    for i = 1 to length( XPM_CODES ) do
        for j = 2 to length( XPM_CODES ) do

	    -- build a two byte code
	    encode[at] = XPM_CODES[i] & XPM_CODES[j]

	    -- increment
	    at += 1

	    -- filled?
	    if at > colors then
	        -- leave inner loop
	        exit
	    end if

        end for

        -- filled?
        if at > colors then
	    -- leave outer loop
	    exit
        end if

    end for

    else

    -- 1 byte coding
    charsWide = 1

    -- list of codes is subset of
    encode = XPM_CODES[1..colors]

    end if

    -- open the file
    handle = w32FileOpen( outFile, "w" )
    if handle = -1 then
    -- error opening file
    return XPM_ERR_FILE
    end if

    -- header
    puts( handle, "/* XPM */\n" )
    puts( handle, "static char * xpm[] = {\n" )

    -- values: width, height, colors, code width
    printf( handle, "\"%d %d %d %d\",\n",
    {length(bmp[1]), length(bmp), colors, charsWide} )

    -- the color tuples
    for i = 1 to length( code ) do
    -- color used?
    if code[i] then
        -- create an entry
        printf( handle, "\"%s        c #%02x%02x%02x\",\n",
	    {encode[code[i]]} & pal[i] )
    end if

    end for

    -- build the xpm data
    for i = 1 to length( bmp ) do
    -- "
    puts( handle, "\"" )
    for j = 1 to length( bmp[i] ) do

        -- get palette index
        index = bmp[i][j]+1

        -- write the code out
        puts( handle, encode[ code[index] ] )

    end for

    -- end of line
    if i = length( bmp ) then
        -- "};
        puts( handle, "\"};\n" )
    else
        -- ",
        puts( handle, "\",\n" )
    end if

    end for

    -- close the file
    close( handle )

    -- return success
    return XPM_OK

end function


------------------------------------------------------------------------------
--/topic XPM
--/func createXpmFromBmpFile( filename, euphoria bitmap )
--/desc Creates an XPM file from a bitmap file.
--/ret Status code.
-- Status codes:
--
-- /li /b XPM_OK. File created successfully
-- /li /b XPM_ERR_FILE: File related error
-- /li /b XPM_ERR_COLORS: Too many colors in bitmap

-- NEW! 0.43 renamed
global function createXpmFromBmpFile( sequence inFile, sequence outFile )

    -- create an XPM file from a bitmap file
    object bmp

    -- read the bitmap in
    bmp = read_bitmap( inFile )
    if integer( bmp ) then
    -- file error
    return XPM_ERR_FILE
    end if

    -- convert to xpm
    return createXpm( outFile, bmp )

end function


------------------------------------------------------------------------------
function convertToWords( sequence s )
    -- convert s into space delimited words
    sequence word, words

    words = {}
    word = ""
    s = s & " "
    for i = 1 to length( s ) do
    if s[i] = ' ' then
        if length( word ) then
	    words = append( words, word )
	    word = ""
        end if
    else
        word = word & s[i]
    end if
    end for

    return words

end function


-- NEW! 0.42
------------------------------------------------------------------------------
function xpmConvertToNumber( sequence s )

    -- convert a string to a number
    -- this should only return positive numbers,
    -- -1 indicates error

    s = value( s )
    if s[1] != GET_SUCCESS then
    -- flag error
    xpmErrFlag = 1
    end if

    return s[2]

end function

------------------------------------------------------------------------------
function xpmConvertToRGB( sequence s )

    -- convert a color code string into an {r,g,b} tuple
    integer r,g,b

    if s[1] = '#' then
    -- hex tuple: #rrggbb

    -- upper case
    s = upper( s )

    r = xpmConvertToNumber( s[1..3] )
    g = xpmConvertToNumber( "#" & s[4..5] )
    b = xpmConvertToNumber( "#" & s[6..7] )

    -- return tuple
    return {r,g,b}

    elsif equal( s, "None" ) then

    -- set color to clear
    return transTuple

    end if

    -- unable to convert color
    xpmErrFlag = 1

    return {0,0,0}

end function


-- NEW! 0.42 added for XPM support
-- NEW! 0.43 renamed
------------------------------------------------------------------------------
--/topic XPM
--/func xpmToEuBmp( xpm )
--/desc Convert XPM data into a standard Euphoria bitmap.
--/ret A Euphoria bitmap in a sequence. On failure, an error code.
-- The error codes are:
--
-- /li /b XPM_ERR_COLORS: Too many colors in bitmap
-- /li /b XPM_ERR_HEADER: Error in XPM header
-- /li /b XPM_ERR_COLOR: Couldn't translate color code


global function xpmToEuBmp( sequence xpm )


    integer
    line,           -- current line in file
    at,             -- used to find positions in strings
    bitsWide,       -- width of the xpm
    bitsTall,       -- height of the xpm
    colors,         -- colors in the xpm
    codeWide        -- width of the color code

    sequence
    colorCode,      -- text of color code
    colorRGB,       -- palette of tuples
    bits            -- bits of image

    object
    data            -- generic bucket


    -- clear error flag
    xpmErrFlag = 0

    -- extract the values: "<wide> <tall> <colors> <bytes per color>"
    data = convertToWords( xpm[1] )
    bitsWide = xpmConvertToNumber( data[1] )
    bitsTall = xpmConvertToNumber( data[2] )
    colors   = xpmConvertToNumber( data[3] )
    codeWide = xpmConvertToNumber( data[4] )

    -- error?
    if xpmErrFlag then
    -- error in header
    return XPM_ERR_HEADER
    end if

    -- create a palatte and data
    colorCode  = repeat( "", colors )
    colorRGB   = repeat( {}, colors )

    -- start of data
    line = 2

    -- read the color data
    for i = 1 to colors do

    -- extract the color code
    colorCode[i] = xpm[line][1..codeWide]

    -- get a line
    data = xpm[line]

    -- seek to the color
    data = data[3..length(data)]
    at = match( "c ", data )
    if at = 0 then
        -- badly formed color definition
        return XPM_ERR_COLOR
    end if

    -- extract the color code
    data = data[at+2..length(data)]

    -- convert to an {r,g,b} code
    colorRGB[i] = xpmConvertToRGB( data )

    -- increment line
    line += 1

    end for

    -- check condition
    if xpmErrFlag then
    -- error in call to colorRGB
    return XPM_ERR_COLOR
    end if

    -- create data area
    bits = repeat( repeat( 0, bitsWide ), bitsTall )

    -- convert the text into indexes
    for i = 1 to bitsTall do

    -- get a line
    data = xpm[line]

    -- convert to w32lookup
    at = 0

    for j = 1 to length( data ) by codeWide do

        -- move 1 pixel at a time
        at += 1

        -- find the position, subtract to make base zero
        bits[i][at] = find( data[j..j+codeWide-1], colorCode ) - 1

    end for

    -- read the next line
    line += 1

    end for

    return { colorRGB, bits }

end function


function bmpToMask( sequence bmp )

    bmp[1] = { transTuple, split_rgb(Black) }

    for i = 1 to length( bmp[2] ) do
    for j = 1 to length( bmp[2][i] ) do
        if bmp[2][i][j] then
	    bmp[2][i][j] = 1
        end if
    end for
    end for

    return bmp
end function


--/topic Image Lists
--/func addXpm( xpm )
--/desc Adds xpm's to win32lib's imagelists
--/ret Index to image
-- This function is used to add images for /ListView, /TreeView,
-- /ComboBoxEx and /FlatToolBar controls.  There are two ways to
-- use /addXpm:
-- /li /b xpm is an xpm sequence
--      used for /ListView, /TreeView, /ComboBoxEx
-- /li /b xpm is a sequence of 3 xpm's
--      used for /FlatToolBar
-- The xpm's passed for the /FlatToolBar should be the xpms to be used
-- for the default, hot and disabled images, respectively.
global function addXpm( sequence xpm )
    sequence xpm_mask, himl
    object hIcon, iIcon
    object hbmp, hmask

    if length( xpm ) = 3 then
        xpm_mask = {}
        hIcon = {}

        himl = { himlFTBDefault, himlFTBHot, himlFTBDisabled }
        for i = 1 to 3 do

            hbmp = createDIB(xpmToEuBmp( xpm[i] ))

            hmask = createDIB(bmpToMask(xpmToEuBmp( xpm[i] )))

            hbmp  = w32Func( CopyImage, { hbmp, IMAGE_BITMAP, 32, 32,
    	    LR_COPYDELETEORG })
            hmask = w32Func( CopyImage, { hmask, IMAGE_BITMAP, 32, 32,
    	    w32or_all({LR_MONOCHROME, LR_COPYDELETEORG}) })

            ILAdd( himl[i], hbmp, hmask )
            hIcon &= hbmp

        end for

        FTB_images &= { hIcon }
        iIcon = length( FTB_images )
    else
        hbmp = createDIB(xpmToEuBmp( xpm ))
        hmask =createDIB(bmpToMask(xpmToEuBmp(xpm)) )
        ILAdd( ILlarge, hbmp, hmask )
        ILAdd( ILsmall, hbmp, hmask )
        ilicon_list &= hbmp
        iIcon = length( ilicon_list )
    end if


    return iIcon
end function

integer pm
pm = 0

function createMonochromeDIB( atom hBmp )
    atom dib, p, t, wide, tall
    sequence bmp, test

    if not pm then
        pm = createEx( Pixmap, "", 0, 0, 0, 31, 31, 0, 0 )
    end if

    setPenColor( pm, transColor )
    drawRectangle( pm, 1, 1, 32, 32, w32True )
    drawBitmap( pm, hBmp, 0, 0 )

    bmp = repeat( repeat( ' ', 32), 32 )
    test = bmp
    p = getPixel(pm, 1, 1 )

    for i = 1 to 30 do
        for j = 1 to 30 do
            t = getPixel( pm, j, i )
            if t != p then
        	    bmp[i][j] = 'x'
            end if
            test[i][j] = t
        end for
    end for

    dib = textToBitmap( bmp )
    dib = w32Func( CopyImage, { dib, IMAGE_BITMAP, 32, 32, LR_MONOCHROME } )

    return dib
end function

--/topic Image Lists
--/func addEuBmp( bmp )
--/desc Adds EuBitmaps to win32lib's imagelists
--/ret Index to image
-- This function is used to add images for /ListView, /TreeView,
-- /ComboBoxEx and /FlatToolBar controls.  There are two ways to
-- use /addEuBmp:
-- /li /b bmp is a sequence in Eu Bitmap form
--      used for /ListView, /TreeView, /ComboBoxEx
-- /li /b xpm is a sequence of 3 Eu Bitmaps
--      used for /FlatToolBar
-- The Bitmaps passed for the /FlatToolBar should be the images to be used
-- for the default, hot and disabled images, respectively.
global function addEuBmp( object bmp )
    sequence list, dib

    if length( bmp ) = 1 then
        list = ilicon_list

        dib = {
            w32Func( CopyImage, { createDIB( bmp ), 32, 32, IMAGE_BITMAP,
    	    LR_COPYDELETEORG }),
            w32Func( CopyImage, { createDIB( bmpToMask( bmp ) ) , IMAGE_BITMAP,
    	    32, 32, w32or_all({LR_MONOCHROME, LR_COPYDELETEORG}) } ) }

        ILAdd( ILlarge, dib[1], dib[2] )
        ILAdd( ILsmall, dib[1], dib[2] )

        VOID = w32Func( xDeleteObject, { dib[1] } )
        VOID = w32Func( xDeleteObject, { dib[2] } )

        list &= 0

        ilicon_list = list

    else

        list = FTB_images
        dib = repeat( {}, 3 )

        for i = 1 to 3 do
            dib[i] = {
    	    w32Func( CopyImage,
    	        { createDIB( bmp[i] ), IMAGE_BITMAP, 32, 32,
    	        LR_COPYDELETEORG }),

    	    w32Func( CopyImage, { createDIB( bmpToMask( bmp[i] ) ) ,
    	        IMAGE_BITMAP, 32, 32,
    	        w32or_all({LR_MONOCHROME, LR_COPYDELETEORG }) } ) }

        end for

        ILAdd( himlFTBDefault, dib[1][1], dib[1][2] )
        ILAdd( himlFTBHot, dib[2][1], dib[2][2] )
        ILAdd( himlFTBDisabled, dib[3][1], dib[3][2] )

        for i = 1 to 3 do
            VOID = w32Func( xDeleteObject, { dib[i][1] } )
            VOID = w32Func( xDeleteObject, { dib[i][2] } )
        end for

        list &= { {0,0,0} }
        FTB_images = list
    end if

    return length( list )

end function

--/topic Image Lists
--/func addDIB( hBmp )
--/desc Adds DIB's to win32lib's imagelists
--/ret Index to image
-- This function is used to add images for /ListView, /TreeView,
-- /ComboBoxEx and /FlatToolBar controls.  There are two ways to
-- use /addDIB:
-- /li /b hBmp is a handle to a DIB (see /createDIB)
--      used for /ListView, /TreeView, /ComboBoxEx
-- /li /b hBmp is a sequence of 3 handles to DIBs
--      used for /FlatToolBar
-- The DIBs passed for the /FlatToolBar should be the images to be used
-- for the default, hot and disabled images, respectively.
-- NOTE: This function does not work very well, due to difficulties
-- in generating a mask for the image.  Use /addEuBmp or /addXpm if
-- possible.

global function addDIB( object hBmp )
    integer iIcon
    sequence list
    object bmp


    if atom( hBmp ) then
        list = ilicon_list
    else
        list = FTB_images
    end if

    iIcon = find( hBmp, list)

    if iIcon then
        return iIcon
    end if

    iIcon = length( list )

    if atom( hBmp ) then

        bmp = w32Func( CopyImage, { hBmp, IMAGE_BITMAP, 32, 32, 0 } )

        ILAddMasked( ILlarge, hBmp )
        ILAddMasked( ILsmall, hBmp )

        VOID = w32Func( xDeleteObject, { hBmp } )

        list &= hBmp
        ilicon_list = list

    else
        -- Need to use CopyImage, since the mask feature wrecks the image
        bmp = repeat( {0,0}, 3 )

        for i = 1 to 3 do

            bmp[i][1] = w32Func( CopyImage,
    	    { hBmp[i], IMAGE_BITMAP, 32, 32, 0 })

            bmp[i][2] = createMonochromeDIB( bmp[i][1] )


        end for

        ILAdd( himlFTBDefault, bmp[2][1], bmp[1][2] )
        ILAdd( himlFTBHot, bmp[1][2], bmp[2][2] )
        ILAdd( himlFTBDisabled, bmp[1][1], bmp[3][2] )

        for i = 1 to 3 do
            for j = 1 to 2 do
    	    VOID = w32Func( xDeleteObject, { bmp[i][j] } )
            end for
        end for

        list &= {hBmp}
        FTB_images = list

    end if


    return iIcon + 1

end function

------------------------------------------------------------------------------
global function readXpm( sequence fName )

    -- read a file into a sequence
    -- removes line feeds

    integer handle, at
    sequence file
    object data

    file = {}

    -- open the file
    handle = w32FileOpen( fName, "r" )
    if handle = -1 then
    -- error opening file
        return XPM_ERR_FILE
    end if

    -- check header
    data = gets( handle )
    if not match( "/* XPM */", data ) then
        return XPM_ERR_HEADER
    end if

    -- read to eof
    while 1 do

        -- read a line
        data = gets( handle )

        -- eof?
        if integer( data ) then
            exit
        end if

        -- remove line feed, if any
        if data[length(data)] = '\n' then
            data = data[1..length(data)-1]
        end if

        -- blank line?
        if length( data ) = 0 then
            -- ignore

        -- not quoted?
        elsif data[1] != '"' then
            -- ignore

        else

            -- first quote
            at = find( '"', data )
            data = data[at+1..length(data)]

            -- last quote
            at = find( '"', data )
            data = data[1..at-1]

            -- add to file
            file = append( file, data )

        end if

    end while

    -- close the file
    close( handle )

    -- reads an XPM from disk, returns bitmap
    return xpmToEuBmp( file )

end function


-----------------------------------------------------------------------------
------------------------------------------------------------------------------
--/topic XPM
--/func xpmToPixmap( xpm )
--/desc Create a /Pixmap from XPM data.
--
--/ret A Euphoria bitmap, or an error code.
-- The error codes are:
--
-- /li /b XPM_ERR_COLORS: Too many colors in bitmap
-- /li /b XPM_ERR_HEADER: Error in XPM header
-- /li /b XPM_ERR_COLOR: Couldn't translate color code


global function xpmToPixmap( sequence xpm )

    -- convert xpm to bmp, and then to dib
    atom pixmap
    sequence bmp

-- NEW! 0.43 function renamed
    -- convert xpm to bmp using the TransRGB for the transparent color
    bmp = xpmToEuBmp( xpm )

    -- create an empty pixmap
    pixmap = createEx( Pixmap, "", 0, 0, 0, 0, 0, 0, 0 )

    -- create a dib, and assign it to the pixmap
    setPixmap( pixmap, createDIB( bmp ) )

    return pixmap

end function


-----------------------------------------------------------------------------
-- ShellExecute error codes
global constant SE_ERR_FNF             = 2,       -- file not found
                SE_ERR_PNF             = 3,       -- path not found
                SE_ERR_ACCESSDENIED    = 5,       -- access denied
                SE_ERR_OOM             = 8,       -- out of memory
                SE_ERR_SHARE           = 26,
                SE_ERR_ASSOCINCOMPLETE = 27,
                SE_ERR_DDETIMEOUT      = 28,
                SE_ERR_DDEFAIL         = 29,
                SE_ERR_DDEBUSY         = 30,
                SE_ERR_NOASSOC         = 31,
                SE_ERR_DLLNOTFOUND     = 32
------------------------------------------------------------------------------
--/topic Utilities
--/func shellExecuteEx( object verb, sequence file, object params, object defdir, object style, atom struct )
--/desc Launch a Windows application
--/ret INTEGER: Success code. 0 to 32 are errors.
--
-- This is a wrapper around the Win32 /b ShellExecute command.
--
-- The /i verb parameter is the action you are trying to execute. In nearly
-- all cases this is "open". The actions possible are defined in your Windows
-- File Associations definitions. If this parameter is not a sequence then
-- the default action for the /i file is used.
--
-- The /i file parameter is the file to perform the action upon. This is
-- usually a .EXE file but can be any file type that has a defined action in
-- the Window File Associations.
--
-- The /i params is a list of zero or more parameters passed to the file.
-- Usually when opening an EXE file, this is the parameters for that program.
--
-- The /i defdir is the default directory to change to before openning the
-- file. If this is not a sequence the the current directory is used.
--
-- The /i style parameter is a window style flag.
-- These can be ... /n
--/li SW_HIDE
--/li SW_SHOWNORMAL
--/li SW_NORMAL
--/li SW_SHOWMINIMIZED
--/li SW_SHOWMAXIMIZED
--/li SW_MAXIMIZE
--/li SW_SHOWNOACTIVATE
--/li SW_SHOW
--/li SW_MINIMIZE
--/li SW_SHOWMINNOACTIVE
--/li SW_SHOWNA
--/li SW_RESTORE
--/li SW_SHOWDEFAULT
--/li SW_MAX
--
-- The /i struct parameter is not used yet.
--
-- The return codes for this function are... /n
-- SE_ERR_FNF                    -- file not found
-- SE_ERR_PNF                    -- path not found
-- SE_ERR_ACCESSDENIED           -- access denied
-- SE_ERR_OOM                    -- out of memory
-- SE_ERR_SHARE
-- SE_ERR_ASSOCINCOMPLETE
-- SE_ERR_DDETIMEOUT
-- SE_ERR_DDEFAIL
-- SE_ERR_DDEBUSY
-- SE_ERR_NOASSOC
-- SE_ERR_DLLNOTFOUND

global function shellExecuteEx( object verb, sequence file, object parms,
	              object defdir, atom style, atom struct)

    -- call ShellExecuteEx to display a file
    atom mset, parms_p, file_p, verb_p, defdir_p
    atom hWnd
    integer rc

    if validId(mainWindow) then
        hWnd = getHandle(mainWindow)
    else
        hWnd=0
        --warnErr("shellExecute requires a WinMain()")
        --return 0
    end if

    -- convert to strings
    mset = w32new_memset()
    if atom(verb) or length(verb) = 0 then
        verb_p = 0
    else
        verb_p = w32acquire_mem(mset, verb )
    end if

    if atom(parms) or length(parms) = 0 then
        parms_p = 0
    else
        parms_p = w32acquire_mem(mset, parms )
    end if

    file_p  = w32acquire_mem(mset, file )

    if atom(defdir) or length(defdir) = 0 then
        defdir_p = 0
    else
        defdir_p = w32acquire_mem(mset, defdir )
    end if

    -- call ShellExecute
    rc = w32Func( xShellExecute,
        { hWnd, verb_p, file_p, parms_p, defdir_p, style } )

    -- Free the strings
    w32release_mem( mset )

    return rc
end function

------------------------------------------------------------------------------
--/topic Utilities
--/proc shellExecute( command, file, style )
--/desc Launch a Windows application
--
-- This is a wrapper around the Win32 /b ShellExecute command.
-- /i command is usually "open". /n
-- /i file is the file or directory to open or run. /n
-- /i style is usually SW_SHOWNORMAL, but can be SW_SHOWMINIMIZED or
-- SW_SHOWMAXIMIZED
--
--/code
--       -- Start up MSAcess on the database.
--       shellExecute("open", "myDB.mdb", SW_SHOWNORMAL)
--/endcode
global procedure shellExecute( object verb, sequence file, atom style)

    VOID = shellExecuteEx(verb, file, "", "", style, 0)

end procedure

-----------------------------------------------------------------------------
------------------------------------------------------------------------------
--/topic Utilities
--/func playSound( sequence FileParm )
--/desc Play the .WAV file.
--/ret /b w32True if succeeds, /b w32False if fails.
-- This is a wrapper around the Win32 /b PlaySound command. /n
-- /i FileName can take one of four forms. /n
-- /li The value 0 or an empty sequence. Use this to immediately stop playing
-- any sound.
-- /li A simple filename, such as a ".WAV" file to play. This sets up the
-- flags as SND_FILENAME and SND_ASYNC. /n
-- /li The form {FileName, Flags} which gives you more control over the flag settings.
-- The /i Flags can be either a single atom or a sequence of sound flags.
--/li The form  {FileName, Flags, ResourceId} is available the sound you need to
-- play is contained in the resources of an executable file. In this case /i FileName
-- is is a sequence with one element in it; a handle to an executable file. /i ResourceId
-- is the id of the resource to play.
--
--Example:
--/code
--      -- Play a sound file and return before it ends.
--      VOID = playSound("announce.wav")
--
--      -- Play a sound file and wait until it ends.
--      VOID = playSound({"announce.wav",{SND_FILENAME,SND_SYNC})
--
--      -- Play a sound file continuously in the background
--      VOID = playSound({"background.wav", {SND_FILENAME,SND_ASYNC,SND_LOOP})
--
--      -- Play a sound file but only if no other sound is already playing.
--      VOID = playSound({"hit.wav",{SND_FILENAME,SND_ASYNC,SND_NOSTOP})
--
--      -- Play a sound named in the system registry.
--      VOID = playSound({"MailBeep",{SND_ALIAS})
--
--      -- Stop playing any sound.
--      VOID = playSound({"",SND_PURGE})
--      -- or
--      VOID = playSound(0)
--
--/endcode
global function playSound( object pFileParms )

    atom lFlags
    atom lResource
    object lFileName

    lResource = 0
    if atom(pFileParms) or length(pFileParms) = 0 then
        lFlags = SND_PURGE
        lFileName = ""

    else
        if sequence(pFileParms[1]) then
            lFileName = pFileParms[1]
            if length(pFileParms) >= 2 then
                if sequence(pFileParms[2]) then
                    lFlags = w32or_all(pFileParms[2])
                else
                    lFlags = pFileParms[2]
                end if
            end if

            if length(pFileParms) >= 3 then
                lResource = pFileParms[3]
                lFlags = or_bits(lFlags, SND_RESOURCE)
                lFileName = pFileParms[1][1]
            end if

        else
            lFileName = pFileParms
            lFlags = or_bits(SND_FILENAME, SND_ASYNC)

        end if
    end if

    -- play the sound
    return w32Func( xPlaySound, {lFileName, lResource, lFlags})

end function

-- Begin Wolf
--/topic Utilities
--/func setStartupFont( integer font )
--/desc Establishes the default font to use when creating a window or control.
--/i font is one of the system constants... /n
--/li    OEM_FIXED_FONT
--/li    ANSI_FIXED_FONT
--/li    ANSI_VAR_FONT
--/li    SYSTEM_FONT
--/li    DEVICE_DEFAULT_FONT
--/li    SYSTEM_FIXED_FONT
--
--Example
--/code
--     setStartupFont(SYSTEM_FIXED_FONT)
--/endcode

global procedure setStartupFont(integer font)
    DefaultFontID   =  w32Func( xGetStockObject, { font } )
    vStockResources[1] = DefaultFontID
end procedure
-- End Wolf

--/topic Miscellaneous
--/proc Beep(atom style)
--/desc Sounds one of the standard beeps.
--
--/i style can be one of ... /n
--/li -1  Standard beep using the computer speaker
--/li MB_ICONASTERISK SystemAsterisk
--/li MB_ICONEXCLAMATION SystemExclamation
--/li MB_ICONHAND SystemHand
--/li MB_ICONQUESTION SystemQuestion
--/li MB_OK
--
--Example
--/code
--  Beep( MB_ICONEXCLAMATION )
--/endcode

global procedure Beep( atom pStyle )
    VOID = w32Func( xBeep, { pStyle } )
end procedure



-----------------------------------------------------------------------------
function libCleanUp(integer pErrCode, sequence pDispMsg, integer pN, integer pLast)
-----------------------------------------------------------------------------

    releaseAllResources(1)
    return 0
end function
r_libCleanUp = routine_id("libCleanUp")

-----------------------------------------------------------------------------
procedure initialize()
-----------------------------------------------------------------------------

    -- various housekeeping tasks
    atom szAppName

    setStartupFont(ANSI_VAR_FONT)  -- sets usual 'tiny' default font
    -- Create the screen and printer controls
    setControlBlocks(2)
    Screen  = createEx( Screen_, "", 0, 0, 0, 0, 0, 0, 0 )
    Printer = createEx( Printer_, "", 0, 0, 0, 0, 0, 0, 0 )
    setControlBlocks(16)

    -- get the proc address
    get_proc_w32address()

    -- set the 'clean up' behavior
    VOID = attachCleanUp(r_libCleanUp)

end procedure


---------------------------
procedure checkPopup( integer self, integer event, sequence parms)
---------------------------
    atom shifts
    object lMenu
    integer lOffsetX
    integer lOffsetY

    shifts = parms[4]
    lOffsetX = -6
    lOffsetY = -6

    if parms[1] = WM_RBUTTONDOWN then

        if and_bits(shifts, ShiftMask + ControlMask) = (ShiftMask + ControlMask) then
            lMenu = ctrl_Popup[self][4]

        elsif and_bits(shifts, ShiftMask) = ShiftMask then
            lMenu = ctrl_Popup[self][2]

        elsif and_bits(shifts, ControlMask) = ControlMask then
            lMenu = ctrl_Popup[self][3]

        else
            lMenu = ctrl_Popup[self][1]
        end if

        if sequence(lMenu) then
            if length(lMenu) >= 3 then
                lOffsetY = lMenu[3]
            end if
            if length(lMenu) >= 2 then
                lOffsetX = lMenu[2]
            end if

            lMenu = lMenu[1]
        end if

        if not equal(lMenu,-1) then
            popup({lMenu,self}, parms[2]+lOffsetX, parms[3]+lOffsetY)
        end if
    end if

end procedure


--/topic Menus
--/func attachPopup(integer pId, object pMenus)
--/desc Associates one or more menus to a control as popup or context menus.
--/ret SEQUENCE: Previously attached menus.
--This will cause the menu(s) supplied in /i pMenu to be linked to
-- the control /i pId such that when the righthand mouse button is pressed,
-- the menu will pop up next to the mouse pointer. /n
-- You can have different menus popup depending on the combination of
-- Ctrl and Shift keys you have pressed. You do this by supplying up to four
-- menu ids in /i pMenu, one for no keys pressed, one for shift key, one for
-- control key, and another for both shift and control keys pressed.
--
-- Each value in /i pMenu is either a Menu id, 0, -1, or a sequence
-- of the form {MenuId, XOffset, YOffset}. /n
-- If a simple menu id, then this is the popup menu that will display when
-- the user right-clicks in the control. /n
-- If -1, then the corresponding current value is retained. Use this to
-- skip over setting previous values of menu ids. /n
-- If 0, then the corresponding menu id is cleared and the popup will /b
-- not display. /n
-- If a sequence, then the /i XOffset and /i YOffset are used to position
-- the menu relative to the mouse pointer. The default values are -6 and -6
-- respectively. Use this when you need the menu to be shown is different
-- position.
--
--First you need to define the menus and any handlers for them, then you
-- can attach them to one or more controls.
--
--Example
--/code
--      -- Define two menus.
--      MenuOne = create(Menu, "One", MainWindow, 0, 0, 0,0, 0)
--        M1_Item1 = create(MenuItem, "Item 1.1", MenuOne, 0, 0, 0,0, 0)
--        M1_Item2 = create(MenuItem, "Item 1.2", MenuOne, 0, 0, 0,0, 0)
--        M1_Item3 = create(MenuItem, "Item 1.3", MenuOne, 0, 0, 0,0, 0)
--      MenuTwo = create(Menu, "Two", MainWindow, 0, 0, 0,0, 0)
--        M2_Item1 = create(MenuItem, "Item 2.1", MenuTwo, 0, 0, 0,0, 0)
--        M2_Item2 = create(MenuItem, "Item 2.2", MenuTwo, 0, 0, 0,0, 0)
--        M2_Item3 = create(MenuItem, "Item 2.3", MenuTwo, 0, 0, 0,0, 0)
--      setHandler(M1_Item1, w32HClick, routine_id("Click_Item11"))
--      setHandler(M1_Item2, w32HClick, routine_id("Click_Item12"))
--      setHandler(M1_Item3, w32HClick, routine_id("Click_Item13"))
--      setHandler(M2_Item1, w32HClick, routine_id("Click_Item21"))
--      setHandler(M2_Item2, w32HClick, routine_id("Click_Item22"))
--      setHandler(M2_Item3, w32HClick, routine_id("Click_Item23"))
--
--  -- Now attach popups for normal and ctrl keys
--  prevMenus = attachPopup(SomeFld,
--                {MenuOne, -- Normal (no keys)
--                  -1,      -- ignore Shift
--                  -- Note the changed X-Y offsets.
--                  {MenuTwo,-20,-10}  -- Ctrl key
--                 })
--
--/endcode
global function attachPopup(integer pId, object pMenus)
    sequence lOldValues
    sequence lNewValues
    integer  lCount
    object lTemp

    -- Save current values
    lOldValues = ctrl_Popup[pId]

    -- fixup the case when only one menu id is supplied.
    if atom(pMenus) then
        pMenus = {pMenus}
    end if

    -- only process up to the 4th menu id.
    lCount = length(pMenus)
    if lCount > 4 then
        lCount = 4
    end if

    -- Update the control's popup values
    for i = 1 to lCount do
        if pMenus[i] = -1 then
            -- Retain previous value

            pMenus[i] = lOldValues[i]

        elsif pMenus[i] = 0 then
            -- Detach this specific combination.
            pMenus[i] = -1
        end if
        ctrl_Popup[pId][i] = pMenus[i]
    end for

    -- Add a handler to trap right-mouse presses for this control.
    lTemp = vOnXXXSupport
    setHandler(pId, w32HMouse, {-2,  routine_id("checkPopup")})
    vOnXXXSupport = lTemp

    return lOldValues
end function
r_attachPopup = routine_id("attachPopup")


integer fn_debug fn_debug = 1
global constant w32DebugLog = -1772
global procedure wDebug(sequence pData)

    if length(pData) = 2 then
        if sequence(pData[1]) then
            printf(fn_debug, pData[1], pData[2])
        else
            if pData[1] = w32DebugLog then
                if fn_debug > 2 then
                    close(fn_debug)
                end if
                fn_debug = w32FileOpen(pData[2], "w")
                if fn_debug < 0 then
                    fn_debug = 1
                end if
            end if
        end if
    else
        puts(fn_debug, w32ToString(pData))
        if not equal(pData[length(pData)], '\n') then
            puts(fn_debug, '\n')
        end if
    end if
end procedure
r_wDebug = routine_id("wDebug")


--/topic Miscellaneous
--/func getRandInt(atom pMin, atom pMax)
--/desc Gets a random number.
--/ret ATOM: A random number from /i Min and /i Max inclusive.
--This uses the cryptographic routines built into Windows. It gathers entropy from
--various sources in between calls and thus you cannot seed this generator
--to produce a known stream of numbers.
--
-- /i pMin and pMax are limited to 32-bit integer values.
--
--Example:
--/code
--      integer guess
--      Get a random number between 4 and 19.
--      guess = getRandInt(4, 19)
--/endcode

global function getRandInt(atom pMin, atom pMax)
    atom lRC
    atom lMem
    atom lValue
    atom lRange
    atom lMax
    sequence lProviders
    atom lTempSeed

    lProviders = {
        PROV_RSA_FULL          ,
        PROV_RSA_SIG           ,
        PROV_DSS               ,
        PROV_FORTEZZA          ,
        PROV_MS_EXCHANGE       ,
        PROV_SSL               ,
        PROV_RSA_SCHANNEL      ,
        PROV_DSS_DH            ,
        PROV_EC_ECDSA_SIG      ,
        PROV_EC_ECNRA_SIG      ,
        PROV_EC_ECDSA_FULL     ,
        PROV_EC_ECNRA_FULL     ,
        PROV_DH_SCHANNEL       ,
        PROV_SPYRUS_LYNKS      ,
        PROV_RNG               ,
        PROV_INTEL_SEC         ,
        PROV_REPLACE_OWF       ,
        PROV_RSA_AES
    }


    if vCSP = 0 then
        set_rand(w32Seed)
        lMem = w32acquire_mem(0, 8)
        -- Locate a default crypto provider.
        for i = 1 to length(lProviders) do
            lRC = w32Func(xCryptAcquireContext, {lMem, 0, 0, lProviders[i], 0})
            if lRC != 0 then
                vCSP = peek4u(lMem)
                exit
            end if
        end for
        if vCSP = 0 then
            -- There are no crypto providers.
            vCSP  = -1
        end if

    elsif vCSP= -1 then
        lTempSeed = rand(w32Seed) * w32Seed
        lTempSeed -= floor(lTempSeed/#3FFFFFFF)*#3FFFFFFF
        w32Seed = remainder(xor_bits(w32Seed, lTempSeed), #100000000)
        set_rand(w32Seed)
    else
        lMem = w32acquire_mem(0, 4)

    end if

    if vCSP > 0 then
        poke4(lMem, w32Seed)
        lRC = w32Func(xCryptGenRandom, {vCSP, 4, lMem})
        lMax = #100000000
        lValue = peek4u(lMem)
        w32release_mem(lMem)
    else
        lMax = #100000000
        lValue = w32rand32(lMax)
    end if


    lRange= pMax - pMin  + 1
    if lRange < 0 then
        lRange = -lRange
    end if
    lValue = pMin + floor((lValue/lMax) * lRange)

    return lValue
end function

sequence vRegisteredNames
sequence vRegisteredRID
vRegisteredNames = {}
vRegisteredRID = {}

--/topic Support Routines
--/func w32routine_id(sequence pRoutineName)
--/desc Returns the routine id for the registered routine /i pRoutineName
--/ret INTEGER: The routine id or -1 if /i pRoutineName is not registered.
--This can only find routines that have been registered via /registerRoutine()
-- and is used by /w32Start.ew to automatically set handlers based on the
-- standard naming convention for even handlers.
--
--Example:
--/code
--  integer id
--  id = w32routine_id( EventType & "_" & ControlName )
--/endcode

global function w32routine_id(sequence pRoutineName)
    integer lPos

    lPos = find(pRoutineName, vRegisteredNames)
    if lPos > 0 then
        return vRegisteredRID[lPos]
    else
        return -1
    end if
end function

--/topic Support Routines
--/proc registerRoutine(sequence pRoutineName, integer pRoutineId)
--/desc Registers a text string with an associated routine_id.
--This is primarily used to add routines to an internal list so that /w32start.ew
-- can automatically find event handlers. However it can be used to link and text string to
-- a routine_id, and later you can use /w32routine_id() to retrieve the routine_id given the
-- text string.
--
--Example:
--/code
--  registerRoutine("Click_BigButton", routine_id("Click_BigButton"))
--  registerRoutine("MainAction", routine_id("Click_BigButton"))
--
--  rid = w32routine_id("MainAction")
--  if rid != -1 then
--      call_proc(rid, { . . . }) -- This calls Click_BigButton procedure.
--  end if
--/endcode
global procedure registerRoutine(sequence pRoutineName, integer pRoutineId)
    vRegisteredNames = append(vRegisteredNames, pRoutineName)
    vRegisteredRID = append(vRegisteredRID, pRoutineId)
end procedure

global function registerControl(sequence pControlName, sequence pRID)
    integer lControl

    -- Is this already registered?

    pControlName = w32trim(pControlName)
    lControl = find(upper(pControlName), vControlNames)
    if lControl != 0 then
        return -1
    end if

    vControlNames = append(vControlNames, upper(pControlName))
    lControl = length(vControlNames)
    vControlTypes = append(vControlTypes, lControl)

    vControlRID = w32MinSequenceSize(vControlRID, lControl, 0)
    vControlRID[lControl] = pRID
    NumClasses += 1

    className = w32MinSequenceSize(className, lControl, 0)
    className[lControl] = call_func(pRID[kCRID_Control], {"className", -1})
    classType = w32MinSequenceSize(classType, lControl, 0)
    classType[lControl] = call_func(pRID[kCRID_Control], {"classType", -1})
    classStyle = w32MinSequenceSize(classStyle, lControl, 0)
    classStyle[lControl] = call_func(pRID[kCRID_Control], {"classStyle", 0})
    classStyleEx = w32MinSequenceSize(classStyleEx, lControl, 0)
    classStyleEx[lControl] = call_func(pRID[kCRID_Control], {"classStyleEx", 0})
    classAttr = w32MinSequenceSize(classAttr, lControl, 0)
    classAttr[lControl] =  call_func(pRID[kCRID_Control], {"classAttr", 0})
    classDefPointer = w32MinSequenceSize(classDefPointer, lControl, 0)
    classDefPointer[lControl] = call_func(pRID[kCRID_Control], {"classDefPointer", IDC_ARROW})
    classBGColor = w32MinSequenceSize(classBGColor, lControl, 0)
    classBGColor[lControl] = call_func(pRID[kCRID_Control], {"classBGColor", WindowColor})
    classFGColor = w32MinSequenceSize(classFGColor, lControl, 0)
    classFGColor[lControl] = call_func(pRID[kCRID_Control], {"classFGColor", w32Color_WINDOWTEXT})

    return lControl

end function


global procedure registerNotification(integer pSender, integer pAction, integer pEvent, integer pReceiver, object pUserData)
    sequence lCurrentIds
    sequence lCurrentEvents
    sequence lCurrentUP
    integer lPosR
    integer lPosE

    lCurrentIds = ctrl_Notify_List[pSender][1]
    lPosR = find(pReceiver, lCurrentIds)

    if lPosR then
        lCurrentEvents = ctrl_Notify_List[pSender][2][lPosR]
        lCurrentUP  = ctrl_Notify_List[pSender][3][lPosR]
    else
        lCurrentEvents = {}
        lCurrentUP = {}
    end if

    if pAction = 1 then
        -- Add
        lPosE =  find(pEvent, lCurrentEvents)
        if lPosE = 0 then
            lCurrentEvents &= 0
            lCurrentUP &= 0
            lPosE = length(lCurrentEvents)
        end if
        lCurrentEvents[lPosE] = pEvent
        lCurrentUP[lPosE] = pUserData

        if lPosR = 0 then
            lCurrentIds &= pReceiver
            ctrl_Notify_List[pSender][2] &= 0
            ctrl_Notify_List[pSender][3] &= 0
            lPosR = length(lCurrentIds)
        end if

        ctrl_Notify_List[pSender][1] = lCurrentIds
        ctrl_Notify_List[pSender][2][lPosR] = lCurrentEvents
        ctrl_Notify_List[pSender][3][lPosR] = lCurrentUP

    else
        -- Delete
        -- ??????? NOT IMPLEMENTED YET ????????????
    end if


end procedure
r_registerNotification = routine_id("registerNotification")

initialize()


-----------------------
--/topic Degraded Routines and Constants
--/info These are identifiers that will be removed in future releases.
-- There is nearly always an alternative routine or constant to use.

--/topic Degraded Routines and Constants
--/proc setPosition()
--/desc See /setPenPos

--/topic Degraded Routines and Constants
--/proc moveWindow()
--/desc See /setRect

--/topic Degraded Routines and Constants
--/func getExtent()
--/desc See /getCtlSize

--/topic Degraded Routines and Constants
--/proc getSize()
--/desc See /getRect

--/topic Degraded Routines and Constants
--/proc SetPointerPosn()
--/desc See /setPointerPos

--/topic Degraded Routines and Constants
--/proc GetPointerPosn()
--/desc See /getPointerPos

--/topic Degraded Routines and Constants
--/proc ClickPointerLeft()
--/desc See /clickPointerLeft

--/topic Degraded Routines and Constants
--/proc DragPointerTo()
--/desc See /dragPointerTo

--/topic Degraded Routines and Constants
--/proc setPenPosition()
--/desc See /setPenPos

--/topic Degraded Routines and Constants
--/proc insertListViewColumn()
--/desc See /insertLVColumn

--/topic Degraded Routines and Constants
--/func getMousePos()
--/desc See /getPointerPos

--/topic Degraded Routines and Constants
--/func getMouseRelPos()
--/desc See /getPointerRelPos

--/topic Degraded Routines and Constants
--/func setPenROP2()
--/desc See /setPenMode

--/topic Degraded Routines and Constants
--/Const onXXX
--/desc By default, the onXXX syntax is supported.


include compat01.ew

